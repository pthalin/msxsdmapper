0001   0000             ; Projeto MSX SD Mapper
0002   0000             
0003   0000             ; Copyright (c) 2014 Fabio Belavenuto
0004   0000             ; Enhanced by FRS
0005   0000             
0006   0000             ; This documentation describes Open Hardware and is licensed under the CERN OHL v. 1.1.
0007   0000             ; You may redistribute and modify this documentation under the terms of the
0008   0000             ; CERN OHL v.1.1. (http://ohwr.org/cernohl). This documentation is distributed
0009   0000             ; WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING OF MERCHANTABILITY,
0010   0000             ; SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.
0011   0000             ; Please see the CERN OHL v.1.1 for applicable conditions
0012   0000             
0013   0000             ; Technical info:
0014   0000             ; 7B00h~7EFFh	: SPI data transfer window (read/write)
0015   0000             ; 7F00h		: Interface status and card select register (read/write)
0016   0000             ;	<read>
0017   0000             ;	If no SD card is selected:
0018   0000             ;	    b7-b2 : always 0
0019   0000             ;	    b1 : SW1 status (Driver selection)
0020   0000             ;	    b0 : SW0 status. 0=RAM disabled, 1=RAM enabled
0021   0000             ;	If any SD card is selected:
0022   0000             ;	    b7-b3 : always 0
0023   0000             ;	    b2 : 1=Write protecton enabled for SD card-slot selected
0024   0000             ;	    b1 : 0=SD card present in the selected card-slot
0025   0000             ;	    b0 : 1=SD Card on slot selected changed since last read
0026   0000             ;	<write>
0027   0000             ;	    b0 : SD card slot-0 chip-select (1=selected)
0028   0000             ;	    b1 : SD card slot-1 chip-select (1=selected)
0029   0000             
0030   0000             ; 7F02h		: 8-bit timer (97.65625 KHz frequency, 10.24uS resolution) (read/write)
0031   0000             ; When a value is written, the timer will decrease it until it reaches zero
0032   0000             
0033   0000             	output	"driver.bin"
0034   0000             
0035   0000             ;-----------------------------------------------------------------------------
0036   0000             ;
0037   0000             ; Driver configuration constants
0038   0000             ;
0039   0000             
0040   0000             ; DEFINE HASMEGARAM	; Driver for an SD-Mapper with MegaRAM
0041   0000             ; DEFINE TURBOINIT	; Disable for the interfaces with the CPLD firmware turbo bug 
0042   0000             ; DEFINE DEBUG		; Set for debugging output
0043   0000             
0044   0000             ;Driver type:
0045   0000             ;   0 for drive-based
0046   0000             ;   1 for device-based
0047   0000             
0048   0000             DRV_TYPE	equ	1
0049   0000             
0050   0000             ;Hot-plug devices support (device-based drivers only):
0051   0000             ;   0 for no hot-plug support
0052   0000             ;   1 for hot-plug support
0053   0000             
0054   0000             DRV_HOTPLUG	equ	1
0055   0000             
0056   0000             
0057   0000             ;Driver version
0058   0000             
0059   0000             VER_MAIN	equ	1
0060   0000             VER_SEC		equ	0
0061   0000             VER_REV		equ	10
0062   0000             
0063   0000             ;-----------------------------------------------------------------------------
0064   0000             ; SPI addresses. Check the Technical info above for the bit contents
0065   0000             
0066   0000             SPIDATA		= $7B00
0067   0000             SPICTRL		= $7FF0
0068   0000             SPISTATUS	= $7FF0
0069   0000             TIMERREG	= $7FF1
0070   0000             
0071   0000             ; Interface status flags
0072   0000             IF_RAM		= 0		; 1=Interface RAM is enabled
0073   0000             IF_DRVER	= 1		; RAM mode: 0=MegaRAM, 1=MemoryMapper
0074   0000             IF_M_RAM	= (1 shl IF_RAM)		; bitmask for IF_RAM
0075   0000             IF_M_DRVER	= (1 shl IF_DRVER)		; bitmask for IF_DRVER
0076   0000             
0077   0000             ; card slot status flags
0078   0000             SD_DSKCHG	= 0		; SD card changed since last status check
0079   0000             SD_PRESENT	= 1		; SD card present
0080   0000             SD_WRTPROT	= 2		; SD card is write protected
0081   0000             SD_M_DSKCHG	= (1 shl SD_DSKCHG)		; bitmask for SD_DSKCHG
0082   0000             SD_M_PRESENT	= (1 shl SD_PRESENT)		; bitmask for SD_PRESENT
0083   0000             SD_M_WRTPROT	= (1 shl SD_WRTPROT)		; bitmask for SD_WRTPROT
0084   0000             
0085   0000             ; SPI commands: 
0086   0000             CMD0	= 0  | $40
0087   0000             CMD1	= 1  | $40
0088   0000             CMD8	= 8  | $40
0089   0000             CMD9	= 9  | $40
0090   0000             CMD10	= 10 | $40
0091   0000             CMD12	= 12 | $40
0092   0000             CMD16	= 16 | $40
0093   0000             CMD17	= 17 | $40
0094   0000             CMD18	= 18 | $40
0095   0000             CMD24	= 24 | $40
0096   0000             CMD25	= 25 | $40
0097   0000             CMD55	= 55 | $40
0098   0000             CMD58	= 58 | $40
0099   0000             ACMD23	= 23 | $40
0100   0000             ACMD41	= 41 | $40
0101   0000             
0102   0000             ; Work area variables 
0103   0000              STRUCT WRKAREA
0104   0000~            BCSD 		ds 16	; Card Specific Data
0105   0000~            BCID1		ds 16	; Card-ID of card1
0106   0000~            BCID2		ds 16	; Card-ID of card2
0107   0000~            NUMSD		db 	; Currently selected card: 1 or 2 
0108   0000~            CARDFLAGS	db 	; Flags that indicate card-change or card error 
0109   0000~            NUMBLOCKS	db 	; Number of blocks in multi-block operations 
0110   0000~            BLOCKS1		ds 3	; 3 bytes. Size of card1, in blocks.
0111   0000~            BLOCKS2		ds 3	; 3 bytes. Size of card2, in blocks.
0112   0000~            TEMP		db	; Temporary data
0113   0000~            TRLDIR		ds 8	; R800 data transfer helper 
0114   0000              ENDS
0115   0000             
0116   0000             
0117   0000             ;-----------------------------------------------------------------------------
0118   0000             ;
0119   0000             ; Standard BIOS and work area entries
0120   0000             CALSLT	= $001C		; Call routine in any slot
0121   0000             CALLF	= $0030		; Call routine in any slot
0122   0000             INITXT	= $006C		; Inicializa SCREEN0
0123   0000             CHSNS	= $009C		; Sense keyboard buffer for character
0124   0000             CHGET	= $009F		; Get character from keyboard buffer
0125   0000             CHPUT	= $00A2		; A=char
0126   0000             CLS	= $00C3		; Chamar com A=0
0127   0000             ERAFNK	= $00CC		; Erase function key display
0128   0000             SNSMAT	= $0141		; Read row of keyboard matrix
0129   0000             KILBUF	= $0156		; Clear keyboard buffer
0130   0000             EXTROM	= $015F
0131   0000             CHGCPU	= $0180		; Change the turbo mode
0132   0000             GETCPU	= $0183		; Get the turbo mode
0133   0000             
0134   0000             ; subROM functions
0135   0000             SDFSCR	= $0185
0136   0000             REDCLK	= $01F5
0137   0000             
0138   0000             
0139   0000             ; System variables
0140   0000             MSXVER	= $002D
0141   0000             LINL40	= $F3AE		; Width
0142   0000             LINLEN	= $F3B0
0143   0000             INTFLG	= $FC9B
0144   0000             SCRMOD	= $FCAF
0145   0000             EXPTBL	 =$FCC1
0146   0000             
0147   0000             
0148   0000             ;-----------------------------------------------------------------------------
0149   0000             
0150   0000             
0151   0000             	org		$4000
0152   4000             
0153   4000 FF          	ds		256, $FF		; 256 dummy bytes
0154   4100             
0155   4100             DRV_START: 
0156   4100             
0157   4100             ;-----------------------------------------------------------------------------
0158   4100             ;
0159   4100             ; Miscellaneous constants
0160   4100             ;
0161   4100             
0162   4100             ;This is a 2 byte buffer to store the address of code to be executed.
0163   4100             ;It is used by some of the kernel page 0 routines.
0164   4100             
0165   4100             CODE_ADD: 	equ	0F84Ch
0166   4100             
0167   4100             
0168   4100             ;-----------------------------------------------------------------------------
0169   4100             ;
0170   4100             ; Error codes for DEV_RW
0171   4100             ;
0172   4100             
0173   4100             ENCOMP	equ	0FFh
0174   4100             EWRERR	equ	0FEh
0175   4100             EDISK	equ	0FDh
0176   4100             ENRDY	equ	0FCh
0177   4100             EDATA	equ	0FAh
0178   4100             ERNF	equ	0F9h
0179   4100             EWPROT	equ	0F8h
0180   4100             EUFORM	equ	0F7h
0181   4100             ESEEK	equ	0F3h
0182   4100             EIFORM	equ	0F0h
0183   4100             EIDEVL	equ	0B5h
0184   4100             EIPARM	equ	08Bh
0185   4100             
0186   4100             ;-----------------------------------------------------------------------------
0187   4100             ;
0188   4100             ; Macros
0189   4100             ;
0190   4100             
0191   4100              MACRO BYTE2STR value
0192   4100~            0193   4100~             IF value > 99
0194   4100~            	db	((value / 100) % 10)+$30
0195   4100~             ENDIF
0196   4100~             IF value > 9
0197   4100~            	db	((value / 10) % 10)+$30
0198   4100~             ENDIF
0199   4100~            	db	(value % 10)+$30
0200   4100~            0201   4100              ENDM
0202   4100             
0203   4100             
0204   4100             ;-----------------------------------------------------------------------------
0205   4100             ;
0206   4100             ; Routines and information available on kernel page 0
0207   4100             ;
0208   4100             
0209   4100             ;* Get in A the current slot for page 1. Corrupts F.
0210   4100             ;  Must be called by using CALBNK to bank 0:
0211   4100             ;    xor a
0212   4100             ;    ld ix,GSLOT1
0213   4100             ;    call CALBNK
0214   4100             
0215   4100             GSLOT1	equ	402Dh
0216   4100             
0217   4100             
0218   4100             ;* This routine reads a byte from another bank.
0219   4100             ;  Must be called by using CALBNK to the desired bank,
0220   4100             ;  passing the address to be read in HL:
0221   4100             ;    ld a,<bank number>
0222   4100             ;    ld hl,<byte address>
0223   4100             ;    ld ix,RDBANK
0224   4100             ;    call CALBNK
0225   4100             
0226   4100             RDBANK	equ	403Ch
0227   4100             
0228   4100             
0229   4100             ;* This routine temporarily switches kernel main bank
0230   4100             ;  (usually bank 0, but will be 3 when running in MSX-DOS 1 mode),
0231   4100             ;  then invokes the routine whose address is at (CODE_ADD).
0232   4100             ;  It is necessary to use this routine to invoke CALBAS
0233   4100             ;  (so that kernel bank is correct in case of BASIC error)
0234   4100             ;  and to invoke DOS functions via F37Dh hook.
0235   4100             ;
0236   4100             ;  Input:  Address of code to invoke in (CODE_ADD).
0237   4100             ;          AF, BC, DE, HL, IX, IY passed to the called routine.
0238   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0239   4100             
0240   4100             CALLB0	equ	403Fh
0241   4100             
0242   4100             
0243   4100             ;* Call a routine in another bank.
0244   4100             ;  Must be used if the driver spawns across more than one bank.
0245   4100             ;
0246   4100             ;  Input:  A = bank number
0247   4100             ;          IX = routine address
0248   4100             ;          AF' = AF for the routine
0249   4100             ;          HL' = Ix for the routine
0250   4100             ;          BC, DE, HL, IY = input for the routine
0251   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0252   4100             
0253   4100             CALBNK	equ	4042h
0254   4100             
0255   4100             
0256   4100             ;* Get in IX the address of the SLTWRK entry for the slot passed in A,
0257   4100             ;  which will in turn contain a pointer to the allocated page 3
0258   4100             ;  work area for that slot (0 if no work area was allocated).
0259   4100             ;  If A=0, then it uses the slot currently switched in page 1.
0260   4100             ;  Returns A=current slot for page 1, if A=0 was passed.
0261   4100             ;  Corrupts F.
0262   4100             ;  Must be called by using CALBNK to bank 0:
0263   4100             ;    ld a,<slot number> (xor a for current page 1 slot)
0264   4100             ;    ex af,af'
0265   4100             ;    xor a
0266   4100             ;    ld ix,GWORK
0267   4100             ;    call CALBNK
0268   4100             
0269   4100             GWORK	equ	4045h
0270   4100             
0271   4100             
0272   4100             ;* This address contains one byte that tells how many banks
0273   4100             ;  form the Nextor kernel (or alternatively, the first bank
0274   4100             ;  number of the driver).
0275   4100             
0276   4100             K_SIZE	equ	40FEh
0277   4100             
0278   4100             
0279   4100             ;* This address contains one byte with the current bank number.
0280   4100             
0281   4100             CUR_BANK	equ	40FFh
0282   4100             
0283   4100             
0284   4100             ;-----------------------------------------------------------------------------
0285   4100             ;
0286   4100             ; Built-in format choice strings
0287   4100             ;
0288   4100             
0289   4100             NULL_MSG  equ     781Fh	;Null string (disk can't be formatted)
0290   4100             SING_DBL  equ     7820h ;"1-Single side / 2-Double side"
0291   4100             
0292   4100             
0293   4100             ;-----------------------------------------------------------------------------
0294   4100             ;
0295   4100             ; Driver signature
0296   4100             ;
0297   4100             	db	"NEXTOR_DRIVER",0
0297   4100 4E4558544F525F44524956455200
0298   410E             
0299   410E             
0300   410E             ;-----------------------------------------------------------------------------
0301   410E             ;
0302   410E             ; Driver flags:
0303   410E             ;    bit 0: 0 for drive-based, 1 for device-based
0304   410E             ;    bit 1: 1 for hot-plug devices supported (device-based drivers only)
0305   410E             
0306   410E 03          	db 1+(2*DRV_HOTPLUG)
0307   410F             
0308   410F             ;-----------------------------------------------------------------------------
0309   410F             ;
0310   410F             ; Reserved byte
0311   410F             ;
0312   410F 00          	db	0
0313   4110             
0314   4110             ;-----------------------------------------------------------------------------
0315   4110             ;
0316   4110             ; Driver name
0317   4110             ;
0318   4110             ; It will be shown in the FDISK interface selection menu
0319   4110             
0320   4110             DRV_NAME: 
0321   4110             	db	"FBLabs SDHC"
0321   4110 46424C6162732053444843
0322   411B 20          	ds	32-($-DRV_NAME)," "
0323   4130             
0324   4130             
0325   4130             ;-----------------------------------------------------------------------------
0326   4130             ;
0327   4130             ; Jump table for the driver public routines
0328   4130             ;
0329   4130             
0330   4130             	; These routines are mandatory for all drivers
0331   4130                     ; (but probably you need to implement only DRV_INIT)
0332   4130             
0333   4130 C3 6C 41    	jp	DRV_TIMI
0334   4133 C3 47 42    	jp	DRV_VERSION
0335   4136 C3 6D 41    	jp	DRV_INIT
0336   4139 C3 4E 42    	jp	DRV_BASSTAT
0337   413C C3 50 42    	jp	DRV_BASDEV
0338   413F C3 52 42    	jp	DRV_EXTBIO
0339   4142 C3 53 42    	jp	DRV_DIRECT0
0340   4145 C3 53 42    	jp	DRV_DIRECT1
0341   4148 C3 53 42    	jp	DRV_DIRECT2
0342   414B C3 53 42    	jp	DRV_DIRECT3
0343   414E C3 53 42    	jp	DRV_DIRECT4
0344   4151             
0345   4151 00          	ds	15
0346   4160             
0347   4160             	; These routines are mandatory for device-based drivers
0348   4160             
0349   4160 C3 54 42    	jp	DEV_RW
0350   4163 C3 DA 42    	jp	DEV_INFO
0351   4166 C3 62 43    	jp	DEV_STATUS
0352   4169 C3 AE 43    	jp	LUN_INFO
0353   416C             
0354   416C             
0355   416C             ;=====
0356   416C             ;=====  END of data that must be at fixed addresses
0357   416C             ;=====
0358   416C             
0359   416C             
0360   416C             ;-----------------------------------------------------------------------------
0361   416C             ;
0362   416C             ; Timer interrupt routine, it will be called on each timer interrupt
0363   416C             ; (at 50 or 60Hz), but only if DRV_INIT returns Cy=1 on its first execution.
0364   416C             
0365   416C             DRV_TIMI: 
0366   416C C9          	ret
0367   416D             
0368   416D             ;-----------------------------------------------------------------------------
0369   416D             ;
0370   416D             ; Driver initialization routine, it is called twice:
0371   416D             ;
0372   416D             ; 1) First execution, for information gathering.
0373   416D             ;    Input:
0374   416D             ;      A = 0
0375   416D             ;      B = number of available drives
0376   416D             ;      HL = maximum size of allocatable work area in page 3
0377   416D             ;    Output:
0378   416D             ;      A = number of required drives (for drive-based driver only)
0379   416D             ;      HL = size of required work area in page 3
0380   416D             ;      Cy = 1 if DRV_TIMI must be hooked to the timer interrupt, 0 otherwise
0381   416D             ;
0382   416D             ; 2) Second execution, for work area and hardware initialization.
0383   416D             ;    Input:
0384   416D             ;      A = 1
0385   416D             ;      B = number of allocated drives for this controller
0386   416D             ;
0387   416D             ;    The work area address can be obtained by using GWORK.
0388   416D             ;
0389   416D             ;    If first execution requests more work area than available,
0390   416D             ;    second execution will not be done and DRV_TIMI will not be hooked
0391   416D             ;    to the timer interrupt.
0392   416D             ;
0393   416D             ;    If first execution requests more drives than available,
0394   416D             ;    as many drives as possible will be allocated, and the initialization
0395   416D             ;    procedure will continue the normal way
0396   416D             ;    (for drive-based drivers only. Device-based drivers always
0397   416D             ;     get two allocated drives.)
0398   416D             
0399   416D             DRV_INIT: 
0400   416D B7          	or	a		; Is this the 1st call? 
0401   416E 20 0F       	jr	nz,.call2
0402   4170             ; 1st call:
0403   4170 21 3A 00    	ld	hl,WRKAREA.TRLDIR ; size of work area needed for the Z80
0404   4173 3A 2D 00    	ld	a,(MSXVER)
0405   4176 FE 03       	cp	3		; MSX Turbo-R?
0406   4178 3F          	ccf
0407   4179 D0          	ret	nc		; No, return with Cy off
0408   417A 21 42 00    	ld	hl,WRKAREA	; size of work area needed for the TR
0409   417D B7          	or	a		; Clear Cy
0410   417E C9          	ret
0411   417F             
0412   417F             
0413   417F             .call2: 
0414   417F             ; 2nd call: 
0415   417F              IFDEF TURBOINIT
0416   417F~            	ld	a,(CHGCPU)
0417   417F~            	cp	#C3		; IS CHGCPU present?
0418   417F~            	jr	nz,.call2ini
0419   417F~            	call	GETCPU
0420   417F~            	push	af		; Save the current CPU
0421   417F~            	ld	a,#82
0422   417F~            	call	CHGCPU		; Enable the turbo
0423   417F~            .call2ini: 
0424   417F              ENDIF ; TURBOINIT
0425   417F CD AC 48    	call	MYSETSCR		; Set the screen mode
0426   4182 CD ED 43    	call	pegaWorkArea		; HL=IY=Work area pointer
0427   4185             
0428   4185 11 74 4D    	ld	de,strTitle		; prints the title 
0429   4188 CD 66 47    	call	printString
0430   418B             
0431   418B             
0432   418B             .sdhcinit: 	; FBLabs SDHC Interface initialization
0433   418B CD 23 42    	call	.printmode		; Print the switches configuration
0434   418E AF          	xor	a			; zera flags do cartao
0435   418F FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
0436   4192             
0437   4192 3E 01       	ld	a, 1			; detectar cartao 1
0438   4194 CD AE 41    	call	.detecta
0439   4197 3E 02       	ld	a, 2			; detectar cartao 2
0440   4199 CD AE 41    	call	.detecta
0441   419C 01 00 00    	ld	bc, 0
0442   419F 1E 05       	ld	e, 5
0443   41A1             
0444   41A1 CD 3F 49    	call	INSTR800HLP		; Install R800 data copy on workarea
0445   41A4             
0446   41A4 CD F0 48    	call	INICHKSTOP		; Check if the STOP key was pressed
0447   41A7             
0448   41A7 11 40 4E    	ld	de, strCrLf
0449   41AA              
0450   41AA CD 66 47    	call	printString
0451   41AD              IFDEF TURBOINIT
0452   41AD~            .drv_init_end: 
0453   41AD~            	; ***Workaround for a bug in Nextor that causes it to freeze if
0454   41AD~            	; CTRL+STOP was pressed on boot
0455   41AD~            	ld	a,(INTFLG)
0456   41AD~            	cp	3		; Is CTRL+STOP still signaled?
0457   41AD~            	jr	nz,.restCPU	; no, skip
0458   41AD~            	xor	a
0459   41AD~            	ld	(INTFLG),a	; Clear CTRL+STOP otherwise Nextor will freeze
0460   41AD~            0461   41AD~            .restCPU: 	; Restore the CPU if necessary
0462   41AD~            	ld	a,(CHGCPU)
0463   41AD~            	cp	#C3		; IS CHGCPU present?
0464   41AD~            	ret	nz
0465   41AD~            	pop	af
0466   41AD~            	or	#80
0467   41AD~            	jp	CHGCPU
0468   41AD              ELSE
0469   41AD C9          	ret
0470   41AE              ENDIF ; TURBOINIT
0471   41AE             
0472   41AE             
0473   41AE             ;------- DRV_INIT aux routines ----------
0474   41AE             
0475   41AE             .detecta: 
0476   41AE FD 77 30    	ld	(iy+WRKAREA.NUMSD), a	; Save the requested card slot
0477   41B1 11 43 4E    	ld	de, strCartao
0478   41B4 CD 66 47    	call	printString
0479   41B7 FD 4E 30    	ld	c, (iy+WRKAREA.NUMSD)
0480   41BA 79          	ld	a,c
0481   41BB C6 30       	add	'0'
0482   41BD CD A2 00    	call	CHPUT
0483   41C0 3E 3A       	ld	a, ':'
0484   41C2 CD A2 00    	call	CHPUT
0485   41C5 3E 20       	ld	a, ' '
0486   41C7 CD A2 00    	call	CHPUT
0487   41CA 79          	ld	a,c			; Get card slot#
0488   41CB             ;	cpl				; invert bits
0489   41CB             ;	and	3
0490   41CB 32 F0 7F    	ld	(SPICTRL), a		; Select card slot
0491   41CE 3A F0 7F    	ld	a, (SPISTATUS)		; get card slot status
0492   41D1 CD BA 45    	call	disableSDs
0493   41D4 E6 02       	and	SD_M_PRESENT		; Is there an card present?
0494   41D6 28 06       	jr	z,.naoVazio		; Yes, skip
0495   41D8 11 4B 4E    	ld	de, strVazio		; Empty SD card slot message
0496   41DB C3 66 47    	jp	printString
0497   41DE             ;	jp	.marcaErro
0498   41DE             .naoVazio: 
0499   41DE CD 6D 44    	call	detectaCartao		; tem cartao no slot, inicializar e detectar
0500   41E1 30 09       	jr	nc,.detectou
0501   41E3 CD BA 45    	call	disableSDs
0502   41E6 11 53 4E    	ld	de, strNaoIdentificado
0503   41E9 C3 66 47    	jp	printString
0504   41EC             ;.marcaErro:
0505   41EC             ;	jp	marcaErroCartao		; slot vazio ou erro de deteccao, marcar nas flags
0506   41EC             .detectou: 
0507   41EC CD 45 44    	call	calculaCIDoffset	; calculamos em IX a posicao correta do offset CID dependendo do cartao atual
0508   41EF DD 7E 0F    	ld	a,(ix+15)	; pegar byte SDV1 ou SDV2
0509   41F2 11 C7 4E    	ld	de, strSDV1	; e imprimir
0510   41F5 B7          	or	a
0511   41F6 28 03       	jr	z,.pula1
0512   41F8 11 CE 4E    	ld	de, strSDV2
0513   41FB             .pula1: 
0514   41FB CD 66 47    	call	printString
0515   41FE 3E 28       	ld	a,'('
0516   4200 CD A2 00    	call	CHPUT
0517   4203 DD 7E 00    	ld	a,(ix)		; pegar byte do fabricante
0518   4206 CD B3 47    	call	printDecToAscii	; Imprimir Manufacturer ID
0519   4209 3E 29       	ld	a,')'
0520   420B CD A2 00    	call	CHPUT
0521   420E 3E 20       	ld	a,' '
0522   4210 CD A2 00    	call	CHPUT
0523   4213 DD 7E 00    	ld	a,(ix)		; pegar byte do fabricante
0524   4216 CD DF 47    	call	pegaFabricante	; achar nome do fabricante
0525   4219 EB          	ex	de,hl
0526   421A CD 66 47    	call	printString	; e imprimir
0527   421D 11 40 4E    	ld	de,strCrLf
0528   4220 C3 66 47    	jp	printString
0529   4223             
0530   4223             
0531   4223             .printmode: 		; Print the two switches configuration
0532   4223 AF          	xor	a			; 0=Interface status
0533   4224 32 F0 7F    	ld	(SPICTRL),a
0534   4227 3A F0 7F    	ld	a, (SPISTATUS)		; Check if the mapper/megaRAM is active
0535   422A 11 76 4E    	ld	de,strNextorSS0
0536   422D E6 01       	and	IF_M_RAM		; Is the RAM enabled?
0537   422F 20 03       	jr	nz,.skip1
0538   4231 11 5E 4E    	ld	de,strMapperSS0
0539   4234             .skip1: 
0540   4234 CD 66 47    	call	printString		; Yes, print
0541   4237 3A F0 7F    	ld	a, (SPISTATUS)		; Get the MainBIOS/DevBIOS switch status
0542   423A E6 02       	and	IF_M_DRVER
0543   423C 11 8E 4E    	ld	de,strDrvMain
0544   423F 20 03       	jr	nz,.printdrv
0545   4241 11 A7 4E    	ld	de, strDrvDev
0546   4244             .printdrv: 
0547   4244 C3 66 47    	jp	printString
0548   4247             
0549   4247             
0550   4247             
0551   4247             
0552   4247             
0553   4247             
0554   4247             ;-----------------------------------------------------------------------------
0555   4247             ;
0556   4247             ; Obtain driver version
0557   4247             ;
0558   4247             ; Input:  -
0559   4247             ; Output: A = Main version number
0560   4247             ;         B = Secondary version number
0561   4247             ;         C = Revision number
0562   4247             
0563   4247             DRV_VERSION: 
0564   4247 3E 01       	ld	a, VER_MAIN
0565   4249 06 00       	ld	b, VER_SEC
0566   424B 0E 0A       	ld	c, VER_REV
0567   424D C9          	ret
0568   424E             
0569   424E             
0570   424E             ;-----------------------------------------------------------------------------
0571   424E             ;
0572   424E             ; BASIC expanded statement ("CALL") handler.
0573   424E             ; Works the expected way, except that if invoking CALBAS is needed,
0574   424E             ; it must be done via the CALLB0 routine in kernel page 0.
0575   424E             
0576   424E             DRV_BASSTAT: 
0577   424E 37          	scf
0578   424F C9          	ret
0579   4250             
0580   4250             
0581   4250             ;-----------------------------------------------------------------------------
0582   4250             ;
0583   4250             ; BASIC expanded device handler.
0584   4250             ; Works the expected way, except that if invoking CALBAS is needed,
0585   4250             ; it must be done via the CALLB0 routine in kernel page 0.
0586   4250             
0587   4250             DRV_BASDEV: 
0588   4250 37          	scf
0589   4251 C9          	ret
0590   4252             
0591   4252             ;-----------------------------------------------------------------------------
0592   4252             ;
0593   4252             ; Extended BIOS hook.
0594   4252             ; Works the expected way, except that it must return
0595   4252             ; D'=1 if the old hook must be called, D'=0 otherwise.
0596   4252             ; It is entered with D'=1.
0597   4252             
0598   4252             DRV_EXTBIO: 
0599   4252 C9          	ret
0600   4253             
0601   4253             ;-----------------------------------------------------------------------------
0602   4253             ;
0603   4253             ; Direct calls entry points.
0604   4253             ; Calls to addresses 7850h, 7853h, 7856h, 7859h and 785Ch
0605   4253             ; in kernel banks 0 and 3 will be redirected
0606   4253             ; to DIRECT0/1/2/3/4 respectively.
0607   4253             ; Receives all register data from the caller except IX and AF'.
0608   4253             
0609   4253             DRV_DIRECT0: 
0610   4253             DRV_DIRECT1: 
0611   4253             DRV_DIRECT2: 
0612   4253             DRV_DIRECT3: 
0613   4253             DRV_DIRECT4: 
0614   4253 C9          	ret
0615   4254             
0616   4254             
0617   4254             ;=====
0618   4254             ;=====  BEGIN of DEVICE-BASED specific routines
0619   4254             ;=====
0620   4254             
0621   4254             ;-----------------------------------------------------------------------------
0622   4254             ;
0623   4254             ; Read or write logical sectors from/to a logical unit
0624   4254             ;
0625   4254             ;Input:    Cy=0 to read, 1 to write
0626   4254             ;          A = Device number, 1 to 7
0627   4254             ;          B = Number of sectors to read or write
0628   4254             ;          C = Logical unit number, 1 to 7
0629   4254             ;          HL = Source or destination memory address for the transfer
0630   4254             ;          DE = Address where the 4 byte sector number is stored.
0631   4254             ;Output:   A = Error code (the same codes of MSX-DOS are used):
0632   4254             ;              0: Ok
0633   4254             ;              .IDEVL: Invalid device or LUN
0634   4254             ;              .NRDY: Not ready
0635   4254             ;              .DISK: General unknown disk error
0636   4254             ;              .DATA: CRC error when reading
0637   4254             ;              .RNF: Sector not found
0638   4254             ;              .UFORM: Unformatted disk
0639   4254             ;              .WPROT: Write protected media, or read-only logical unit
0640   4254             ;              .WRERR: Write error
0641   4254             ;              .NCOMP: Incompatible disk.
0642   4254             ;              .SEEK: Seek error.
0643   4254             ;          B = Number of sectors actually read (in case of error only)
0644   4254             
0645   4254             DEV_RW: 
0646   4254 F5          	push	af
0647   4256 BF FE 03    	cp	a, 3		; somente 2 dispositivos
0648   4258 30 1C       	jr	nc,.saicomerroidl
0649   425A 0D          	dec	c		; somente 1 logical unit
0650   425B 20 19       	jr	nz,.saicomerroidl
0651   425D CD ED 43    	call	pegaWorkArea	; IY=Work area pointer
0652   4260 FD 77 30    	ld	(iy+WRKAREA.NUMSD),a
0653   4263 FD 70 32    	ld	(iy+WRKAREA.NUMBLOCKS),b	; save the number of blocks to transfer 
0654   4266 CD 5C 46    	call	setaSDAtual
0655   4269 3A F0 7F    	ld	a,(SPISTATUS)	; Get this card slot status
0656   426C E6 02       	and	SD_M_PRESENT	; Is there a card present?
0657   426E 28 0C       	jr	z,.cardok	; Yes, skip
0658   4270 F1          	pop	af
0659   4271 3E FC       	ld	a, ENRDY	; Not ready
0660   4273 06 00       	ld	b, 0
0661   4275 C9          	ret
0662   4276             .saicomerroidl: 
0663   4276 F1          	pop	af
0664   4277 3E B5       	ld	a, EIDEVL	; error: Invalid device or LUN 
0665   4279 06 00       	ld	b, 0
0666   427B C9          	ret
0667   427C             .cardok: 
0668   427C             ;	exx
0669   427C D5 E5       	push	de,hl
0670   427E             
0671   427E CD 5E 4D    	call	SETLDIRHLPR	; hl'=Pointer to LDIR helper in RAM
0672   4281 CD 45 44    	call	calculaCIDoffset	; ix=CID offset 
0673   4284 DD 7E 0F    	ld	a,(ix+15)	; verificar se eh SDV1 ou SDV2
0674   4287 DD 6F       	ld	ixl,a		; ixl=SDcard version
0675   4289 E1 D1       	pop	hl,de
0676   428B F1          	pop	af		; a=Device number, f=read/write flag 
0677   428C             ;	exx			; hl=Source/dest Address, de=Pointer to sect#
0678   428C             ;	ld	ixh, b 		; ixh=Number of blocks to transfer
0679   428C 38 20       	jr	c,DEV_W	; Skip if it's a write operation 
0680   428E             
0681   428E             DEV_R: 
0682   428E 1A          	ld	a, (de)		; 1. n. bloco
0683   428F F5          	push	af
0684   4290 13          	inc	de
0685   4291 1A          	ld	a, (de)		; 2. n. bloco
0686   4292 F5          	push	af
0687   4293 13          	inc	de
0688   4294 1A          	ld	a, (de)		; 3. n. bloco
0689   4295 4F          	ld	c, a
0690   4296 13          	inc	de
0691   4297 1A          	ld	a, (de)		; 4. n. bloco
0692   4298 13          	inc	de
0693   4299 47          	ld	b, a
0694   429A F1          	pop	af
0695   429B 57          	ld	d, a
0696   429C F1          	pop	af		; HL = ponteiro destino
0697   429D 5F          	ld	e, a		; BC DE = 32 bits numero do bloco
0698   429E CD 04 47    	call	LerBloco	; chamar rotina de leitura de dados
0699   42A1 D0          	ret	nc		; Return with A=0 if no error occurred
0700   42A2 CD 2E 44    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0701   42A5 FD 7E 32    	ld	a,(iy+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0702   42A8 DD 94       	sub	ixh		; subtract the number of remaining blocks
0703   42AA 47          	ld	b,a		; b=number of blocks written
0704   42AB 3E FD       	ld	a, EDISK	; General unknown disk error
0705   42AD C9          	ret
0706   42AE             
0707   42AE             DEV_W: 
0708   42AE             	; Test if the card is write protected
0709   42AE 3A F0 7F    	ld	a,(SPISTATUS)	; Get this card slot status
0710   42B1 E6 04       	and	SD_M_WRTPROT	; Is the card write protected?
0711   42B3 28 05       	jr	z,.ok
0712   42B5 3E F8       	ld	a, EWPROT	; disco protegido
0713   42B7 06 00       	ld	b,0		; 0 blocks were written
0714   42B9 C9          	ret
0715   42BA             .ok: 
0716   42BA 1A          	ld	a, (de)		; 1. n. bloco
0717   42BB F5          	push	af
0718   42BC 13          	inc	de
0719   42BD 1A          	ld	a, (de)		; 2. n. bloco
0720   42BE F5          	push	af
0721   42BF 13          	inc	de
0722   42C0 1A          	ld	a, (de)		; 3. n. bloco
0723   42C1 13          	inc	de
0724   42C2 4F          	ld	c, a
0725   42C3 1A          	ld	a, (de)		; 4. n. bloco
0726   42C4 13          	inc	de
0727   42C5 47          	ld	b, a
0728   42C6 F1          	pop	af
0729   42C7 57          	ld	d, a
0730   42C8 F1          	pop	af		; HL = ponteiro destino
0731   42C9 5F          	ld	e, a		; BC DE = 32 bits numero do bloco
0732   42CA CD 68 46    	call	GravarBloco	; chamar rotina de gravacao de dados
0733   42CD D0          	ret	nc		; Return with A=0 if no error occurred
0734   42CE             
0735   42CE CD 2E 44    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0736   42D1 FD 7E 32    	ld	a,(iy+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0737   42D4 DD 94       	sub	ixh		; subtract the number of remaining blocks
0738   42D6 47          	ld	b,a		; b=number of blocks written
0739   42D7 3E FE       	ld	a,EWRERR	; Write error
0740   42D9 C9          	ret
0741   42DA             
0742   42DA             ;-----------------------------------------------------------------------------
0743   42DA             ;
0744   42DA             ; Device information gathering
0745   42DA             ;
0746   42DA             ;Input:   A = Device index, 1 to 7
0747   42DA             ;         B = Information to return:
0748   42DA             ;             0: Basic information
0749   42DA             ;             1: Manufacturer name string
0750   42DA             ;             2: Device name string
0751   42DA             ;             3: Serial number string
0752   42DA             ;         HL = Pointer to a buffer in RAM
0753   42DA             ;Output:  A = Error code:
0754   42DA             ;             0: Ok
0755   42DA             ;             1: Device not available or invalid device index
0756   42DA             ;             2: Information not available, or invalid information index
0757   42DA             ;         When basic information is requested,
0758   42DA             ;         buffer filled with the following information:
0759   42DA             ;
0760   42DA             ;+0 (1): Numer of logical units, from 1 to 7. 1 if the device has no logical
0761   42DA             ;        units (which is functionally equivalent to having only one).
0762   42DA             ;+1 (1): Device flags, always zero in Beta 2.
0763   42DA             ;
0764   42DA             ; The strings must be printable ASCII string (ASCII codes 32 to 126),
0765   42DA             ; left justified and padded with spaces. All the strings are optional,
0766   42DA             ; if not available, an error must be returned.
0767   42DA             ; If a string is provided by the device in binary format, it must be reported
0768   42DA             ; as an hexadecimal, upper-cased string, preceded by the prefix "0x".
0769   42DA             ; The maximum length for a string is 64 characters;
0770   42DA             ; if the string is actually longer, the leftmost 64 characters
0771   42DA             ; should be provided.
0772   42DA             ;
0773   42DA             ; In the case of the serial number string, the same rules for the strings
0774   42DA             ; apply, except that it must be provided right-justified,
0775   42DA             ; and if it is too long, the rightmost characters must be
0776   42DA             ; provided, not the leftmost.
0777   42DA             
0778   42DA             DEV_INFO: 
0779   42DB BF FE 03    	cp	a,3		; somente 2 dispositivos
0780   42DD 38 03       	jr	c,.devok
0781   42DF 3E 01       	ld	a,1		; invalid device index
0782   42E1 C9          	ret
0783   42E2             .devok: 
0784   42E2 CD ED 43    	call	pegaWorkArea	; IY=Work area pointer
0785   42E5 FD 77 30    	ld	(iy+WRKAREA.NUMSD),a
0786   42E8 CD 5C 46    	call	setaSDAtual
0787   42EB 04          	inc	b
0788   42EC 10 06       	djnz	.naoBasic
0789   42EE             
0790   42EE             ; Basic information:
0791   42EE 36 01       	ld	(hl), 1		; 1 logical unit somente
0792   42F0 23          	inc	hl
0793   42F1 AF          	xor	a
0794   42F2 77          	ld	(hl),a		; reservado, deve ser 0
0795   42F3 C9          	ret			; retorna com A=0 (OK)
0796   42F4             
0797   42F4             .naoBasic: 
0798   42F4 3E 02       	ld	a,2
0799   42F6             ;	ret	c		; No card present? Quit with info not available
0800   42F6             
0801   42F6 E5          	push	hl
0802   42F7 CD 45 44    	call	calculaCIDoffset	; calculamos em IX a posicao correta do offset CID dependendo do cartao atual
0803   42FA E1          	pop	hl
0804   42FB 10 26       	djnz	.naoManuf
0805   42FD             ; Manufacturer Name:
0806   42FD E5          	push	hl		; salva ponteiro do buffer
0807   42FE 06 40       	ld	b, 64		; preenche buffer com espaco
0808   4300 3E 20       	ld	a, ' '
0809   4302             .loop1: 
0810   4302 77          	ld	(hl), a
0811   4303 23          	inc	hl
0812   4304 10 FC       	djnz	.loop1
0813   4306 D1          	pop	de		; recuperamos ponteiro do buffer em DE
0814   4307 3E 28       	ld	a, '('		; colocamos (xx) xxx no buffer
0815   4309 12          	ld	(de), a
0816   430A 13          	inc	de
0817   430B DD 7E 00    	ld	a, (ix)		; byte do fabricante
0818   430E CD 6F 47    	call	DecToAscii
0819   4311 3E 29       	ld	a, ')'
0820   4313 12          	ld	(de), a
0821   4314 13          	inc	de
0822   4315 3E 20       	ld	a, ' '
0823   4317 12          	ld	(de), a
0824   4318 13          	inc	de
0825   4319 DD 7E 00    	ld	a, (ix)		; byte do fabricante
0826   431C CD DF 47    	call	pegaFabricante	; pegar nome do fabricante em HL
0827   431F ED B0       	ldir			; e colocar no buffer
0828   4321 AF          	xor	a		; Return with A=0 (Ok)
0829   4322 C9          	ret
0830   4323             
0831   4323             .naoManuf: 
0832   4323 10 1A       	djnz	.naoProduct
0833   4325             ; Product Name:
0834   4325 E5          	push	hl		; guarda HL que aponta para buffer do Nextor
0835   4326 DD E5       	push	ix
0836   4328 E1          	pop	hl		; joga IX para HL
0837   4329 16 00       	ld	d, 0
0838   432B 1E 03       	ld	e, 3		; adiciona offset do productname em HL
0839   432D 19          	add	hl, de
0840   432E D1          	pop	de		; recupera buffer do Nextor em DE
0841   432F 01 05 00    	ld	bc, 5		; 5 caracteres
0842   4332 ED B0       	ldir			; copia nome do produto
0843   4334 EB          	ex	de,hl		; troca DE com HL, agora HL aponta para Buffer do nextor atualizado
0844   4335 06 3B       	ld	b, 59		; Coloca espaco no restante do buffer
0845   4337 3E 20       	ld	a, ' '
0846   4339             .loop2: 
0847   4339 77          	ld	(hl), a
0848   433A 23          	inc	hl
0849   433B 10 FC       	djnz	.loop2
0850   433D AF          	xor	a		; Return with A=0 (Ok)
0851   433E C9          	ret
0852   433F             
0853   433F             .naoProduct: 
0854   433F             ; Serial Number:
0855   433F 36 30       	ld	(hl),'0'	; Coloca prefixo "0x"
0856   4341 23          	inc	hl
0857   4342 36 78       	ld	(hl), 'x'
0858   4344 23          	inc	hl
0859   4345 E5          	push	hl		; guarda HL que aponta para buffer do Nextor
0860   4346 DD E5       	push	ix
0861   4348 E1          	pop	hl		; joga IX para HL
0862   4349 16 00       	ld	d, 0
0863   434B 1E 09       	ld	e, 9		; adiciona offset do productname em HL
0864   434D 19          	add	hl, de
0865   434E D1          	pop	de		; recupera buffer do nextor em DE
0866   434F 06 04       	ld	b, 4		; 4 bytes do serial
0867   4351             .loop3: 
0868   4351 7E          	ld	a, (hl)
0869   4352 CD 9F 47    	call	HexToAscii	; converter HEXA para ASCII
0870   4355 23          	inc	hl
0871   4356 10 F9       	djnz	.loop3
0872   4358 06 36       	ld	b, 54		; Coloca espaco no restante
0873   435A 3E 20       	ld	a, ' '
0874   435C             .loop4: 
0875   435C 12          	ld	(de), a
0876   435D 13          	inc	de
0877   435E 10 FC       	djnz	.loop4
0878   4360 AF          	xor	a		; Return with A=0 (Ok)
0879   4361 C9          	ret
0880   4362             
0881   4362             ;-----------------------------------------------------------------------------
0882   4362             ;
0883   4362             ; Obtain device status
0884   4362             ;
0885   4362             ;Input:   A = Device index, 1 to 7
0886   4362             ;         B = Logical unit number, 1 to 7
0887   4362             ;             0 to return the status of the device itself.
0888   4362             ;Output:  A = Status for the specified logical unit,
0889   4362             ;             or for the whole device if 0 was specified:
0890   4362             ;                0: The device or logical unit is not available, or the
0891   4362             ;                   device or logical unit number supplied is invalid.
0892   4362             ;                1: The device or logical unit is available and has not
0893   4362             ;                   changed since the last status request.
0894   4362             ;                2: The device or logical unit is available and has changed
0895   4362             ;                   since the last status request
0896   4362             ;                   (for devices, the device has been unplugged and a
0897   4362             ;                    different device has been plugged which has been
0898   4362             ;                    assigned the same device index; for logical units,
0899   4362             ;                    the media has been changed).
0900   4362             ;                3: The device or logical unit is available, but it is not
0901   4362             ;                   possible to determine whether it has been changed
0902   4362             ;                   or not since the last status request.
0903   4362             ;
0904   4362             ; Devices not supporting hot-plugging must always return status value 1.
0905   4362             ; Non removable logical units may return values 0 and 1.
0906   4362             ;
0907   4362             ; The returned status is always relative to the previous invokation of
0908   4362             ; DEV_STATUS itself. Please read the Driver Developer Guide for more info.
0909   4362             
0910   4362             DEV_STATUS: 
0911   4362 4F          	ld	c,a		; c=Device number
0912   4363 FE 03       	cp	3		; 2 dispositivos somente
0913   4365 30 42       	jr	nc,.nodev
0914   4367 78          	ld	a,b
0915   4368 B7          	or	a		; Device itself status?
0916   4369 28 40       	jr	z,.devok	; I'm fine, thanks
0917   436B 3D          	dec	a		; Only LUN=1 are allowed
0918   436C 20 3B       	jr	nz,.nodev
0919   436E              IFDEF DEBUG
0920   436E~            	push	af
0921   436E~            	ld	a,'S'
0922   436E~            	call	PRTCHAR
0923   436E~            	pop	af
0924   436E              ENDIF
0925   436E C5          	push	bc
0926   436F 79          	ld	a,c
0927   4370 CD ED 43    	call	pegaWorkArea	; HL=IY=Work area pointer
0928   4373 C1          	pop	bc
0929   4374 FD 71 30    	ld	(iy+WRKAREA.NUMSD),c	; salva numero do device atual (1 ou 2)
0930   4377 79          	ld	a,c
0931   4378 32 F0 7F    	ld	(SPICTRL), a	; selects SD
0932   437B 3A F0 7F    	ld	a, (SPISTATUS)	; Get this card-slot status
0933   437E CD BA 45    	call	disableSDs
0934   4381 CB 4F       	bit	SD_PRESENT,a	; Any card here?
0935   4383 20 24       	jr	nz,.saicomerro	; Report that there's no card here
0936   4385 E6 01       	and	SD_M_DSKCHG	; Has the card changed since last time?
0937   4387 20 06       	jr	nz,.detcard	; Yes, force a detection
0938   4389             .tsterror: 
0939   4389 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; testar bit de erro do cartao nas flags
0940   438C A1          	and	c		; Test against the card #
0941   438D 28 14       	jr	z,.semMudanca	; cartao nao marcado com erro, pula
0942   438F             .detcard: 
0943   438F CD 6D 44    	call	detectaCartao	; erro na deteccao do cartao, tentar re-detectar
0944   4392 38 12       	jr	c,.cartaoComErro	; nao conseguimos detectar, sai com erro
0945   4394 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)		; conseguimos detectar, tira erro nas flags
0946   4397 2F          	cpl			; inverte bits para fazer o AND
0947   4398 4F          	ld	c, a
0948   4399 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)
0949   439C A1          	and	c		; clear the error bit 
0950   439D FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
0951   43A0             .comMudanca: 
0952   43A0              IFDEF DEBUG
0953   43A0~            	ld	a,'2'
0954   43A0~            	call	PRTCHAR
0955   43A0              ENDIF
0956   43A0 3E 02       	ld	a, 2		; informa ao Nextor que cartao esta OK e mudou
0957   43A2 C9          	ret
0958   43A3             .semMudanca: 
0959   43A3              IFDEF DEBUG
0960   43A3~            	ld	a,'1'
0961   43A3~            	call	PRTCHAR
0962   43A3              ENDIF
0963   43A3 3E 01       	ld	a, 1		; informa ao Nextor que cartao esta OK e nao mudou
0964   43A5 C9          	ret
0965   43A6             .cartaoComErro: 
0966   43A6 CD 2E 44    	call	marcaErroCartao	; marcar erro do cartao nas flags
0967   43A9              IFDEF DEBUG
0968   43A9~            	ld	a,'E'
0969   43A9~            	call	PRTCHAR
0970   43A9~            	xor	a
0971   43A9~            	ret
0972   43A9              ENDIF
0973   43A9             .nodev: 
0974   43A9              IFDEF DEBUG
0975   43A9~            	ld	a,'s'
0976   43A9~            	call	PRTCHAR
0977   43A9~            	xor	a
0978   43A9~            	ret
0979   43A9              ENDIF
0980   43A9             .saicomerro: 
0981   43A9              IFDEF DEBUG
0982   43A9~            	ld	a,'0'
0983   43A9~            	call	PRTCHAR
0984   43A9              ENDIF
0985   43A9 AF          	xor	a		; this device has an error 
0986   43AA C9          	ret
0987   43AB             .devok: 
0988   43AB 3E 03       	ld	a,3
0989   43AD C9          	ret
0990   43AE             
0991   43AE             
0992   43AE             ;-----------------------------------------------------------------------------
0993   43AE             ;
0994   43AE             ; Obtain logical unit information
0995   43AE             ;
0996   43AE             ;Input:   A  = Device index, 1 to 7
0997   43AE             ;         B  = Logical unit number, 1 to 7
0998   43AE             ;         HL = Pointer to buffer in RAM.
0999   43AE             ;Output:  A = 0: Ok, buffer filled with information.
1000   43AE             ;             1: Error, device or logical unit not available,
1001   43AE             ;                or device index or logical unit number invalid.
1002   43AE             ;         On success, buffer filled with the following information:
1003   43AE             ;
1004   43AE             ;+0 (1): Medium type:
1005   43AE             ;        0: Block device
1006   43AE             ;        1: CD or DVD reader or recorder
1007   43AE             ;        2-254: Unused. Additional codes may be defined in the future.
1008   43AE             ;        255: Other
1009   43AE             ;+1 (2): Sector size, 0 if this information does not apply or is
1010   43AE             ;        not available.
1011   43AE             ;+3 (4): Total number of available sectors.
1012   43AE             ;        0 if this information does not apply or is not available.
1013   43AE             ;+7 (1): Flags:
1014   43AE             ;        bit 0: 1 if the medium is removable.
1015   43AE             ;        bit 1: 1 if the medium is read only. A medium that can dinamically
1016   43AE             ;               be write protected or write enabled is not considered
1017   43AE             ;               to be read-only.
1018   43AE             ;        bit 2: 1 if the LUN is a floppy disk drive.
1019   43AE             ;+8 (2): Number of cylinders
1020   43AE             ;+10 (1): Number of heads
1021   43AE             ;+11 (1): Number of sectors per track
1022   43AE             ;
1023   43AE             ; Number of cylinders, heads and sectors apply to hard disks only.
1024   43AE             ; For other types of device, these fields must be zero.
1025   43AE             
1026   43AE             LUN_INFO: 
1027   43AF BF FE 03    	cp	a, 3		; somente 2 dispositivo
1028   43B1 30 0A       	jr	nc,.saicomerro
1029   43B3 05          	dec	b		; somente 1 logical unit
1030   43B4 20 07       	jr	nz,.saicomerro
1031   43B6 E5          	push	hl
1032   43B7 CD 05 44    	call	testaCartao
1033   43BA E1          	pop	hl
1034   43BB 30 03       	jr	nc,.ok		; nao tem erro com o cartao
1035   43BD             .saicomerro: 
1036   43BD 3E 01       	ld	a, 1		; informar erro
1037   43BF C9          	ret
1038   43C0             .ok: 
1039   43C0 E5          	push	hl
1040   43C1 CD 59 44    	call	calculaBLOCOSoffset	; calcular em IX e HL o offset correto do buffer que armazena total de blocos
1041   43C4 E1          	pop	hl		; do cartao dependendo do cartao atual solicitado
1042   43C5 AF          	xor	a
1043   43C6 77          	ld	(hl), a		; Informar que o dispositivo eh do tipo block device
1044   43C7 23          	inc	hl
1045   43C8 77          	ld	(hl), a		; tamanho de um bloco = 512 bytes (coloca $00, $02 que  $200 = 512)
1046   43C9 23          	inc	hl
1047   43CA 3E 02       	ld	a, 2
1048   43CC 77          	ld	(hl), a
1049   43CD 23          	inc	hl
1050   43CE DD 7E 00    	ld	a, (ix)		; copia numero de blocos total
1051   43D1 77          	ld	(hl), a
1052   43D2 23          	inc	hl
1053   43D3 DD 7E 01    	ld	a, (ix+1)
1054   43D6 77          	ld	(hl), a
1055   43D7 23          	inc	hl
1056   43D8 DD 7E 02    	ld	a, (ix+2)
1057   43DB 77          	ld	(hl), a
1058   43DC 23          	inc	hl
1059   43DD AF          	xor	a		; cartoes SD tem total de blocos em 24 bits, mas o Nextor pede numero de
1060   43DE 77          	ld	(hl), a 	; 32 bits, entao coloca 0 no MSB
1061   43DF 23          	inc	hl
1062   43E0 3E 01       	ld	a, 1		; flags: dispositivo R/W removivel
1063   43E2 77          	ld	(hl), a
1064   43E3 23          	inc	hl
1065   43E4 AF          	xor	a		; CHS = 0
1066   43E5 77          	ld	(hl), a
1067   43E6 23          	inc	hl
1068   43E7 77          	ld	(hl), a
1069   43E8 23          	inc	hl
1070   43E9 77          	ld	(hl), a
1071   43EA 23          	inc	hl
1072   43EB AF          	xor	a		; informar que dados foram preenchidos
1073   43EC C9          	ret
1074   43ED             
1075   43ED             ;=====
1076   43ED             ;=====  END of DEVICE-BASED specific routines
1077   43ED             ;=====
1078   43ED             
1079   43ED             ;------------------------------------------------
1080   43ED             ; Rotinas auxiliares
1081   43ED             ;------------------------------------------------
1082   43ED             
1083   43ED             ;------------------------------------------------
1084   43ED             ; Pedir ao Nextor o ponteiro de dados de trabalho
1085   43ED             ; na RAM e colocar em HL e IY
1086   43ED             ; Output: 
1087   43ED             ; IY = WorkArea pointer
1088   43ED             ; Modifies: IX
1089   43ED             ;------------------------------------------------
1090   43ED             pegaWorkArea: 
1091   43ED F5 E5       	push	af,hl
1092   43EF AF          	xor	a		; Pegar endereco da area de trabalho
1093   43F0 08          	ex	af,af'
1094   43F1 AF          	xor	a
1095   43F2 DD 21 45 40 	ld	ix, GWORK
1096   43F6 CD 42 40    	call	CALBNK
1097   43F9 DD 6E 00    	ld	l,(ix)		; em HL tem o ponteiro da nossa area da RAM
1098   43FC DD 66 01    	ld	h,(ix+1)
1099   43FF E5          	push	hl
1100   4400 FD E1       	pop	iy		; em IY temos o mesmo ponteiro
1101   4402 E1 F1       	pop	hl,af
1102   4404 C9          	ret
1103   4405             
1104   4405             ;------------------------------------------------
1105   4405             ; Testa se cartao esta inserido e/ou houve erro
1106   4405             ; na ultima vez que foi acessado. Carry indica
1107   4405             ; erro
1108   4405             ; Destroi AF, HL, IX, C
1109   4405             ;------------------------------------------------
1110   4405             testaCartao: 
1111   4405 F5          	push	af
1112   4406 CD ED 43    	call	pegaWorkArea	; HL=IY=Work area pointer
1113   4409 F1          	pop	af
1114   440A FD 77 30    	ld	(iy+WRKAREA.NUMSD), a	; salva numero do device atual (1 ou 2)
1115   440D 4F          	ld	c, a
1116   440E 32 F0 7F    	ld	(SPICTRL), a	; Selects SD
1117   4411 3A F0 7F    	ld	a, (SPISTATUS)	; testar se cartao esta inserido
1118   4414 CD BA 45    	call	disableSDs
1119   4417 E6 02       	and	$02
1120   4419 20 0A       	jr	nz,.saicomerro				
1121   441B FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; testar bit de erro do cartao nas flags
1122   441E A1          	and	c
1123   441F 28 02       	jr	z,.ok
1124   4421 37          	scf			; indica erro
1125   4422 C9          	ret
1126   4423             .ok: 
1127   4423 AF          	xor	a		; zera carry indicando sem erro
1128   4424 C9          	ret
1129   4425             .saicomerro: 
1130   4425 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; marca bit de erro nas flags
1131   4428 B1          	or	c
1132   4429 FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
1133   442C 37          	scf
1134   442D C9          	ret
1135   442E             
1136   442E             ;------------------------------------------------
1137   442E             ; Marcar bit de erro nas flags
1138   442E             ; Destroi AF, C
1139   442E             ;------------------------------------------------
1140   442E             marcaErroCartao: 
1141   442E FD 4E 30    	ld	c, (iy+WRKAREA.NUMSD)		; cartao atual (1 ou 2)
1142   4431 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; marcar erro
1143   4434 B1          	or	c
1144   4435 FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
1145   4438 C9          	ret
1146   4439             
1147   4439             ;------------------------------------------------
1148   4439             ; Testar se cartao atual esta protegido contra
1149   4439             ; gravacao, A=0 se protegido
1150   4439             ; Destroi AF, C
1151   4439             ;------------------------------------------------
1152   4439             testaWP: 
1153   4439 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; cartao atual (1 ou 2)
1154   443C 32 F0 7F    	ld	(SPICTRL), a
1155   443F 3A F0 7F    	ld	a, (SPISTATUS)	; testar se cartao esta protegido
1156   4442             ;	call	disableSDs
1157   4442 E6 04       	and	$04
1158   4444 C9          	ret			; se A for 0 cartao esta protegido
1159   4445             
1160   4445             ;------------------------------------------------
1161   4445             ; Calcula offset do buffer na RAM em HL e IX para
1162   4445             ; os dados do CID dependendo do cartao atual
1163   4445             ; Destroi AF, DE, HL e IX
1164   4445             ;------------------------------------------------
1165   4445             calculaCIDoffset: 
1166   4445 FD E5       	push	iy		; copiamos IY para HL
1167   4447 E1          	pop	hl
1168   4448 16 00       	ld	d, 0
1169   444A 1E 10       	ld	e, WRKAREA.BCID1	; DE aponta para buffer BCID1
1170   444C FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; vamos fazer IX apontar para o buffer correto
1171   444F 3D          	dec	a		; dependendo do cartao: BCID1 ou BCID2
1172   4450 28 02       	jr	z,.c1
1173   4452 1E 20       	ld	e, WRKAREA.BCID2	; DE aponta para buffer BCID2
1174   4454             .c1: 
1175   4454 19          	add	hl, de		; HL aponta para buffer correto
1176   4455 E5          	push	hl		
1177   4456 DD E1       	pop	ix		; vamos colocar HL em IX
1178   4458 C9          	ret
1179   4459             
1180   4459             ;------------------------------------------------
1181   4459             ; Calcula offset do buffer na RAM para os dados
1182   4459             ; do total de blocos dependendo do cartao atual
1183   4459             ; Offset fica em HL e IX
1184   4459             ; Destroi AF, DE, HL e IX
1185   4459             ;------------------------------------------------
1186   4459             calculaBLOCOSoffset: 
1187   4459 FD E5       	push	iy		; copiamos IY para HL
1188   445B E1          	pop	hl
1189   445C 16 00       	ld	d, 0
1190   445E 1E 33       	ld	e, WRKAREA.BLOCKS1	; DE aponta para buffer BLOCKS1
1191   4460 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; Vamos fazer IX apontar para o buffer correto
1192   4463 3D          	dec	a		; dependendo do cartao: BLOCKS1 ou BLOCKS2
1193   4464 28 02       	jr	z,.c1
1194   4466 1E 36       	ld	e, WRKAREA.BLOCKS2	; DE aponta para buffer BLOCKS2
1195   4468             .c1: 
1196   4468 19          	add	hl, de		; HL aponta para buffer correto
1197   4469 E5          	push	hl		
1198   446A DD E1       	pop	ix		; Vamos colocar HL em IX
1199   446C C9          	ret
1200   446D             
1201   446D             
1202   446D             ;------------------------------------------------
1203   446D             ; Minhas funcoes para cartao SD
1204   446D             ;------------------------------------------------
1205   446D             
1206   446D             ;------------------------------------------------
1207   446D             ; Processo de inicializacao e deteccao do cartao.
1208   446D             ; Detecta se cartao responde, qual versao (SDV1
1209   446D             ; ou SDV2), faz a leitura do CSD e CID e calcula
1210   446D             ; o numero de blocos do cartao, colocando o CID
1211   446D             ; e total de blocos no buffer correto dependendo
1212   446D             ; do cartao 1 ou 2.
1213   446D             ; Retorna erro no carry. Se for 0 indica deteccao
1214   446D             ; com sucesso.
1215   446D             ; Destroi todos os registradores
1216   446D             ;------------------------------------------------
1217   446D             detectaCartao: 
1218   446D CD 9B 45    	call	iniciaSD	; manda pulsos de clock e comandos iniciais
1219   4470 D8          	ret	c			; retorna se erro
1220   4471 CD 3C 45    	call	testaSDCV2	; tenta inicializar um cartao SDV2
1221   4474 D8          	ret	c
1222   4475 FD E5       	push	iy		; colocar em HL buffer da RAM de trabalho
1223   4477 E1          	pop	hl		; CSD esta no offset 0, nao precisamos somar
1224   4478 3E 49       	ld	a, CMD9		; ler CSD
1225   447A CD 5D 45    	call	lerBlocoCxD
1226   447D D8          	ret	c
1227   447E CD 45 44    	call	calculaCIDoffset	; calculamos em IX e HL a posicao correta do offset CID dependendo do cartao atual
1228   4481 3E 4A       	ld	a, CMD10	; ler CID
1229   4483 CD 5D 45    	call	lerBlocoCxD
1230   4486 D8          	ret	c
1231   4487 3E 7A       	ld	a, CMD58	; ler OCR
1232   4489 11 00 00    	ld	de, 0
1233   448C CD EB 45    	call	SD_SEND_CMD_2_ARGS_GET_R3	; enviar comando e receber resposta tipo R3
1234   448F D8          	ret	c
1235   4490 78          	ld	a, b		; testa bit CCS do OCR que informa se cartao eh SDV1 ou SDV2
1236   4491 E6 40       	and	$40
1237   4493 DD 77 0F    	ld	(ix+15), a	; salva informacao da versao do SD (V1 ou V2) no byte 15 do CID
1238   4496 CC 31 45    	call	z,mudarTamanhoBlocoPara512	; se bit CCS do OCR for 1, eh cartao SDV2 (Block address - SDHC ou SDXD)
1239   4499 D8          	ret	c		; e nao precisamos mudar tamanho do bloco para 512
1240   449A CD BA 45    	call	disableSDs
1241   449D             				; agora vamos calcular o total de blocos dependendo dos dados do CSD
1242   449D CD 59 44    	call	calculaBLOCOSoffset	; calcular em IX e HL o offset correto do buffer que armazena total de blocos
1243   44A0 FD E5       	push	iy		; copiamos IY para HL
1244   44A2 E1          	pop	hl
1245   44A3 16 00       	ld	d, 0
1246   44A5 1E 05       	ld	e, WRKAREA.BCSD+5
1247   44A7 19          	add	hl, de		; HL aponta para buffer BCSD+5
1248   44A8 FD 7E 00    	ld	a, (iy+WRKAREA.BCSD)
1249   44AB E6 C0       	and	$C0		; testa versao do registro CSD
1250   44AD 28 06       	jr	z,.calculaCSD1
1251   44AF FE 40       	cp	$40
1252   44B1 28 54       	jr	z,.calculaCSD2
1253   44B3 37          	scf			; versao do registro CSD nao reconhecida, informa erro na deteccao
1254   44B4 C9          	ret
1255   44B5             
1256   44B5             ; -----------------------------------
1257   44B5             ; Registro CSD versao 1, calcular da
1258   44B5             ; maneira correta para a versao 1
1259   44B5             ; -----------------------------------
1260   44B5             .calculaCSD1: 
1261   44B5 7E          	ld	a, (hl)
1262   44B6 E6 0F       	and	$0F		; isola READ_BL_LEN
1263   44B8 F5          	push	af
1264   44B9 23          	inc	hl
1265   44BA 7E          	ld	a, (hl)		; 2 primeiros bits de C_SIZE
1266   44BB E6 03       	and	3
1267   44BD 57          	ld	d, a
1268   44BE 23          	inc	hl
1269   44BF 5E          	ld	e, (hl)		; 8 bits de C_SIZE (DE contem os primeiros 10 bits de C_SIZE)
1270   44C0 23          	inc	hl
1271   44C1 7E          	ld	a, (hl)
1272   44C2 E6 C0       	and	$C0		; 2 ultimos bits de C_SIZE
1273   44C4 87          	add	a, a		; rotaciona a esquerda
1274   44C5 CB 13       	rl	e		; rotaciona para DE
1275   44C7 CB 12       	rl	d
1276   44C9 87          	add	a, a		; mais uma rotacao
1277   44CA CB 13       	rl	e		; rotaciona para DE
1278   44CC CB 12       	rl	d
1279   44CE 13          	inc	de		; agora DE contem todos os 12 bits de C_SIZE, incrementa 1
1280   44CF 23          	inc	hl
1281   44D0 7E          	ld	a, (hl)		; proximo byte
1282   44D1 E6 03       	and	3		; 2 bits de C_SIZE_MUL
1283   44D3 47          	ld	b, a		; B contem os 2 bits de C_SIZE_MUL
1284   44D4 23          	inc	hl						
1285   44D5 7E          	ld	a, (hl)		; proximo byte
1286   44D6 E6 80       	and	$80		; 1 bit de C_SIZE_MUL
1287   44D8 87          	add	a, a		; rotaciona para esquerda jogando no carry
1288   44D9 CB 10       	rl	b		; rotaciona para B
1289   44DB 04          	inc	b		; agora B contem os 3 bits de C_SIZE_MUL
1290   44DC 04          	inc	b		; faz B = C_SIZE_MUL + 2
1291   44DD F1          	pop	af		; volta em A o READ_BL_LEN
1292   44DE 80          	add	a, b		; A = READ_BL_LEN + (C_SIZE_MUL+2)
1293   44DF 01 00 00    	ld	bc, 0
1294   44E2 CD FB 44    	call	.eleva2
1295   44E5 5A          	ld	e, d		; aqui temos 32 bits (BC DE) com o tamanho do cartao
1296   44E6 51          	ld	d, c		; ignoramos os 8 ultimos bits em E, fazemos BC DE => 0B CD (divide por 256)
1297   44E7 48          	ld	c, b
1298   44E8 06 00       	ld	b, 0
1299   44EA CB 39       	srl	c		; rotacionamos a direita o C, carry = LSB (divide por 2)
1300   44EC CB 1A       	rr	d		; rotacionamos D e E
1301   44EE CB 1B       	rr	e		; no final BC DE contem tamanho do cartao / 512 = numero de blocos
1302   44F0             .salvaBlocos: 
1303   44F0 DD 71 02    	ld	(ix+2), c	; colocar no buffer BLOCOS correto a quantidade de blocos
1304   44F3 DD 72 01    	ld	(ix+1), d	; que o cartao (1 ou 2) tem
1305   44F6 DD 73 00    	ld	(ix), e
1306   44F9 AF          	xor	a		; limpa carry
1307   44FA C9          	ret
1308   44FB             
1309   44FB             .eleva2: 			; aqui temos: A = (READ_BL_LEN + (C_SIZE_MUL+2))
1310   44FB             				; BC = 0
1311   44FB             				; DE = C_SIZE
1312   44FB CB 23       	sla	e		; rotacionamos C_SIZE por 'A' vezes
1313   44FD CB 12       	rl	d
1314   44FF CB 11       	rl	c
1315   4501 CB 10       	rl	b
1316   4503 3D          	dec	a		; subtraimos 1
1317   4504 20 F5       	jr	nz,.eleva2
1318   4506 C9          	ret			; em BC DE temos o tamanho do cartao (bytes) em 32 bits
1319   4507             
1320   4507             ; -----------------------------------
1321   4507             ; Registro CSD versao 2, calcular da
1322   4507             ; maneira correta para a versao 2
1323   4507             ; -----------------------------------
1324   4507             .calculaCSD2: 
1325   4507 23          	inc	hl		; HL ja aponta para BCSD+5, fazer HL apontar para BCSD+7
1326   4508 23          	inc	hl
1327   4509 7E          	ld	a, (hl)
1328   450A E6 3F       	and	$3F
1329   450C 4F          	ld	c, a
1330   450D 23          	inc	hl
1331   450E 56          	ld	d, (hl)
1332   450F 23          	inc	hl
1333   4510 5E          	ld	e, (hl)
1334   4511 CD 1D 45    	call	.inc32		; soma 1
1335   4514 CD 25 45    	call	.desloca32	; multiplica por 512
1336   4517 CD 2A 45    	call	.rotaciona24	; multiplica por 2
1337   451A C3 F0 44    	jp		.salvaBlocos
1338   451D             
1339   451D             .inc32: 
1340   451D 1C          	inc	e
1341   451E C0          	ret	nz
1342   451F 14          	inc	d
1343   4520 C0          	ret	nz
1344   4521 0C          	inc	c
1345   4522 C0          	ret	nz
1346   4523 04          	inc	b
1347   4524 C9          	ret
1348   4525             
1349   4525             .desloca32: 
1350   4525 41          	ld	b, c
1351   4526 4A          	ld	c, d
1352   4527 53          	ld	d, e
1353   4528 1E 00       	ld	e, 0
1354   452A             .rotaciona24: 
1355   452A CB 22       	sla	d
1356   452C CB 11       	rl	c
1357   452E CB 10       	rl	b
1358   4530 C9          	ret
1359   4531             
1360   4531             ; ------------------------------------------------
1361   4531             ; Setar o tamanho do bloco para 512 se o cartao
1362   4531             ; for SDV1
1363   4531             ; ------------------------------------------------
1364   4531             mudarTamanhoBlocoPara512: 
1365   4531 3E 50       	ld	a, CMD16
1366   4533 01 00 00    	ld	bc, 0
1367   4536 11 00 02    	ld	de, 512
1368   4539 C3 D6 45    	jp	SD_SEND_CMD_GET_ERROR
1369   453C             
1370   453C             ; ------------------------------------------------
1371   453C             ; Tenta inicializar um cartao SDV2, se houver erro
1372   453C             ; o cartao deve ser SDV1
1373   453C             ; ------------------------------------------------
1374   453C             testaSDCV2: 
1375   453C 3E 48       	ld	a, CMD8
1376   453E 11 AA 01    	ld	de, $1AA
1377   4541 CD EB 45    	call	SD_SEND_CMD_2_ARGS_GET_R3
1378   4544 21 CF 45    	ld	hl, SD_SEND_CMD1	; HL aponta para rotina correta
1379   4547 38 03       	jr	c,.pula		; cartao recusou CMD8, enviar comando CMD1
1380   4549 21 C1 45    	ld	hl, SD_SEND_ACMD41	; cartao aceitou CMD8, enviar comando ACMD41
1381   454C             .pula: 
1382   454C 01 14 00    	ld	bc, 20		; B = 0, C = 20: 5120 tentativas
1383   454F             .loop: 
1384   454F C5          	push	bc
1385   4550 CD 5C 45    	call	.jumpHL		; chamar rotina correta em HL
1386   4553 C1          	pop	bc
1387   4554 D0          	ret	nc
1388   4555 10 F8       	djnz	.loop
1389   4557 0D          	dec	c
1390   4558 20 F5       	jr	nz,.loop
1391   455A 37          	scf
1392   455B C9          	ret
1393   455C             .jumpHL: 
1394   455C E9          	jp	(hl)		; chamar rotina correta em HL
1395   455D             
1396   455D             ; ------------------------------------------------
1397   455D             ; Ler registro CID ou CSD, o comando vem em A
1398   455D             ; ------------------------------------------------
1399   455D             lerBlocoCxD: 
1400   455D CD D1 45    	call	SD_SEND_CMD_NO_ARGS
1401   4560 D8          	ret	c
1402   4561 CD 30 46    	call	WAIT_RESP_FE
1403   4564 D8          	ret	c
1404   4565 EB          	ex	de,hl
1405   4566             
1406   4566             	; Check for a Z80 or R800
1407   4566             ;	or 	a		; Clear Cy
1408   4566 3E 14       	ld	a,20
1409   4568 ED F9       	db	#ED,#F9		; mulub a,a
1410   456A 21 00 7B    	ld	hl, SPIDATA
1411   456D 38 25       	jr	c,.r800		; Use LDIR for R800
1412   456F ED A0       > ldi	
1412   4571 ED A0       > ldi	
1412   4573 ED A0       > ldi	
1412   4575 ED A0       > ldi	
1412   4577 ED A0       > ldi	
1412   4579 ED A0       > ldi	
1412   457B ED A0       > ldi	
1412   457D ED A0       > ldi	
1412   457F ED A0       > ldi	
1412   4581 ED A0       > ldi	
1412   4583 ED A0       > ldi	
1412   4585 ED A0       > ldi	
1412   4587 ED A0       > ldi	
1412   4589 ED A0       > ldi	
1412   458B ED A0       > ldi	
1412   458D ED A0       > ldi	
1413   458F             .end
1414   458F 7E           	ld	a, (hl)
1415   4590 7E          	ld	a, (hl)		; byte de resposta
1416   4591 B7          	or	a
1417   4592 EB          	ex	de,hl
1418   4593             ;	jr	disableSDs
1419   4593 C9          	ret
1420   4594             
1421   4594             .r800: 
1422   4594 01 10 00    	ld	bc,16
1423   4597 ED B0       	ldir
1424   4599 18 F4       	jr	.end
1425   459B             
1426   459B             ; ------------------------------------------------
1427   459B             ; Algoritmo para inicializar um cartao SD
1428   459B             ; Destroi AF, B, DE
1429   459B             ; ------------------------------------------------
1430   459B             iniciaSD: 
1431   459B CD BA 45    	call	disableSDs
1432   459E             
1433   459E 06 0A       	ld	b, 10		; enviar 80 pulsos de clock com cartao desabilitado
1434   45A0             enviaClocksInicio: 
1435   45A0 3E FF       	ld	a, $FF		; manter MOSI em 1
1436   45A2 32 00 7B    	ld	(SPIDATA), a
1437   45A5 10 F9       	djnz	enviaClocksInicio
1438   45A7 CD 5C 46    	call	setaSDAtual	; ativar cartao atual
1439   45AA 06 08       	ld	b, 8		; 8 tentativas para CMD0
1440   45AC             SD_SEND_CMD0: 
1441   45AC 3E 40       	ld	a, CMD0		; primeiro comando: CMD0
1442   45AE 11 00 00    	ld	de, 0
1443   45B1 C5          	push	bc
1444   45B2 CD DE 45    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
1445   45B5 C1          	pop	bc
1446   45B6 D0          	ret	nc			; retorna se cartao respondeu ao CMD0
1447   45B7 10 F3       	djnz	SD_SEND_CMD0
1448   45B9 37          	scf			; cartao nao respondeu ao CMD0, informar erro
1449   45BA             	; fall throw
1450   45BA             
1451   45BA             ; ------------------------------------------------
1452   45BA             ; Desabilitar (de-selecionar) todos os cartoes
1453   45BA             ; Nao destroi registradores
1454   45BA             ; ------------------------------------------------
1455   45BA             disableSDs: 
1456   45BA F5          	push	af
1457   45BB AF          	xor	a
1458   45BC 32 F0 7F    	ld	(SPICTRL), a
1459   45BF F1          	pop	af
1460   45C0 C9          	ret
1461   45C1             
1462   45C1             ; ------------------------------------------------
1463   45C1             ; Enviar comando ACMD41
1464   45C1             ; ------------------------------------------------
1465   45C1             SD_SEND_ACMD41: 
1466   45C1 3E 77       	ld	a, CMD55
1467   45C3 CD D1 45    	call	SD_SEND_CMD_NO_ARGS
1468   45C6 3E 69       	ld	a, ACMD41
1469   45C8 01 00 40    	ld	bc, $4000
1470   45CB 51          	ld	d, c
1471   45CC 59          	ld	e, c
1472   45CD 18 07       	jr		SD_SEND_CMD_GET_ERROR
1473   45CF             
1474   45CF             ; ------------------------------------------------
1475   45CF             ; Enviar CMD1 para cartao. Carry indica erro
1476   45CF             ; Destroi AF, BC, DE
1477   45CF             ; ------------------------------------------------
1478   45CF             SD_SEND_CMD1: 
1479   45CF 3E 41       	ld	a, CMD1
1480   45D1             SD_SEND_CMD_NO_ARGS: 
1481   45D1 01 00 00    	ld	bc, 0
1482   45D4 50          	ld	d, b
1483   45D5 59          	ld	e, c
1484   45D6             SD_SEND_CMD_GET_ERROR: 
1485   45D6 CD 04 46    	call	SD_SEND_CMD
1486   45D9 B7          	or	a
1487   45DA C8          	ret	z			; se A=0 nao houve erro, retornar
1488   45DB             	; fall throw
1489   45DB             
1490   45DB             ; ------------------------------------------------
1491   45DB             ; Informar erro
1492   45DB             ; Nao destroi registradores
1493   45DB             ; ------------------------------------------------
1494   45DB             setaErro: 
1495   45DB 37          	scf
1496   45DC 18 DC       	jr		disableSDs
1497   45DE             
1498   45DE             ; ------------------------------------------------
1499   45DE             ; Enviar comando em A com 2 bytes de parametros
1500   45DE             ; em DE e testar retorno BUSY
1501   45DE             ; Retorna em A a resposta do cartao
1502   45DE             ; Destroi AF, BC
1503   45DE             ; ------------------------------------------------
1504   45DE             SD_SEND_CMD_2_ARGS_TEST_BUSY: 
1505   45DE 01 00 00    	ld	bc, 0
1506   45E1 CD 04 46    	call	SD_SEND_CMD
1507   45E4 47          	ld	b, a
1508   45E5 E6 FE       	and	$FE		; testar bit 0 (flag BUSY)
1509   45E7 78          	ld	a, b
1510   45E8 20 F1       	jr	nz,setaErro	; BUSY em 1, informar erro
1511   45EA C9          	ret			; sem erros
1512   45EB             
1513   45EB             ; ------------------------------------------------
1514   45EB             ; Enviar comando em A com 2 bytes de parametros
1515   45EB             ; em DE e ler resposta do tipo R3 em BC DE
1516   45EB             ; Retorna em A a resposta do cartao
1517   45EB             ; Destroi AF, BC, DE, HL
1518   45EB             ; ------------------------------------------------
1519   45EB             SD_SEND_CMD_2_ARGS_GET_R3: 
1520   45EB CD DE 45    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
1521   45EE D8          	ret	c
1522   45EF F5          	push	af
1523   45F0 CD 3E 46    	call	WAIT_RESP_NO_FF
1524   45F3 67          	ld	h, a
1525   45F4 CD 3E 46    	call	WAIT_RESP_NO_FF
1526   45F7 6F          	ld	l, a
1527   45F8 CD 3E 46    	call	WAIT_RESP_NO_FF
1528   45FB 57          	ld	d, a
1529   45FC CD 3E 46    	call	WAIT_RESP_NO_FF
1530   45FF 5F          	ld	e, a
1531   4600 44          	ld	b, h
1532   4601 4D          	ld	c, l
1533   4602 F1          	pop	af
1534   4603 C9          	ret
1535   4604             
1536   4604             ; ------------------------------------------------
1537   4604             ; Enviar comando em A com 4 bytes de parametros
1538   4604             ; em BC DE e enviar CRC correto se for CMD0 ou 
1539   4604             ; CMD8 e aguardar processamento do cartao
1540   4604             ; Output  : A=0 if there was no error
1541   4604             ; Modifies:  AF, B, AF'
1542   4604             ; ------------------------------------------------
1543   4604             SD_SEND_CMD: 
1544   4604 CD 5C 46    	call	setaSDAtual
1545   4607 32 00 7B    	ld	(SPIDATA), a
1546   460A F5          	push	af
1547   460B 78          	ld	a, b
1548   460C 32 00 7B    	ld	(SPIDATA), a
1549   460F 79          	ld	a, c
1550   4610 32 00 7B    	ld	(SPIDATA), a
1551   4613 7A          	ld	a, d
1552   4614 32 00 7B    	ld	(SPIDATA), a
1553   4617 7B          	ld	a, e
1554   4618 32 00 7B    	ld	(SPIDATA), a
1555   461B F1          	pop	af
1556   461C FE 40       	cp	CMD0
1557   461E 06 95       	ld	b, $95		; CRC para CMD0
1558   4620 28 08       	jr	z,enviaCRC
1559   4622 FE 48       	cp	CMD8
1560   4624 06 87       	ld	b, $87		; CRC para CMD8
1561   4626 28 02       	jr	z,enviaCRC
1562   4628 06 FF       	ld	b, $FF		; CRC dummy
1563   462A             enviaCRC: 
1564   462A 78          	ld	a, b
1565   462B 32 00 7B    	ld	(SPIDATA), a
1566   462E 18 0E       	jr	WAIT_RESP_NO_FF
1567   4630             
1568   4630             ; ------------------------------------------------
1569   4630             ; Esperar que resposta do cartao seja $FE
1570   4630             ; Destroi AF, B
1571   4630             ; ------------------------------------------------
1572   4630             WAIT_RESP_FE: 
1573   4630 06 0A       	ld	b, 10		; 10 tentativas
1574   4632             .loop: 
1575   4632 C5          	push	bc
1576   4633 CD 3E 46    	call	WAIT_RESP_NO_FF	; esperar resposta diferente de $FF
1577   4636 C1          	pop	bc
1578   4637 FE FE       	cp	$FE		; resposta  $FE ?
1579   4639 C8          	ret	z		; sim, retornamos com carry=0
1580   463A 10 F6       	djnz	.loop
1581   463C 37          	scf			; erro, carry=1
1582   463D C9          	ret
1583   463E             
1584   463E             ; ------------------------------------------------
1585   463E             ; Esperar que resposta do cartao seja diferente
1586   463E             ; de $FF
1587   463E             ; Destroi AF, BC
1588   463E             ; ------------------------------------------------
1589   463E             WAIT_RESP_NO_FF: 
1590   463E 01 01 00    	ld	bc, 1		; 256 tentativas
1591   4641             .loop: 
1592   4641 3A 00 7B    	ld	a, (SPIDATA)
1593   4644 FE FF       	cp	$FF		; testa $FF
1594   4646 C0          	ret		nz		; sai se nao for $FF
1595   4647 10 F8       	djnz	.loop
1596   4649 0D          	dec	c
1597   464A 20 F5       	jr	nz,.loop
1598   464C C9          	ret
1599   464D             
1600   464D             ; ------------------------------------------------
1601   464D             ; Esperar que resposta do cartao seja diferente
1602   464D             ; de $00
1603   464D             ; Destroi A, BC
1604   464D             ; ------------------------------------------------
1605   464D             WAIT_RESP_NO_00: 
1606   464D 01 80 00    	ld	bc, 128		; 32768 tentativas
1607   4650             .loop: 
1608   4650 3A 00 7B    	ld	a, (SPIDATA)
1609   4653 B7          	or	a
1610   4654 C0          	ret	nz			; se resposta for <> $00, sai
1611   4655 10 F9       	djnz	.loop
1612   4657 0D          	dec	c
1613   4658 20 F6       	jr	nz,.loop
1614   465A 37          	scf			; erro
1615   465B C9          	ret
1616   465C             
1617   465C             ; ------------------------------------------------
1618   465C             ; Sets the requested card slot and check its status
1619   465C             ; In case it detects that the card was changed, it will call the detection
1620   465C             ; routine to re-dectect the card type
1621   465C             ; Input: Target card slot
1622   465C             ; Output: Cy = No SD card is present
1623   465C             ;         A: 0=The same card is still present
1624   465C             ;            1=The card was changed since the last check
1625   465C             ; ------------------------------------------------
1626   465C             setaSDAtual: 
1627   465C F5          	push	af
1628   465D 3A 00 7B    	ld	a, (SPIDATA)	; dummy read
1629   4660 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)
1630   4663 32 F0 7F    	ld	(SPICTRL), a
1631   4666 F1          	pop	af
1632   4667 C9          	ret
1633   4668             
1634   4668              IFDEF BLA
1635   4668~            	ld	a, (SPIDATA)	; dummy read
1636   4668~            	ld	a, (iy+WRKAREA.NUMSD)
1637   4668~            ;	cpl			; invert bits
1638   4668~            ;	and	3
1639   4668~            	ld	(SPICTRL), a
1640   4668~            	;
1641   4668~            	ld	a,(SPISTATUS)	; Get this card slot status
1642   4668~            	bit	SD_PRESENT,a	; Is there a card present?
1643   4668~            	scf
1644   4668~            	ret	nz		; No, return with error
1645   4668~            1646   4668~            	; ***Workaround for the problem that Nextor doesn't call DEV_STATUS to
1647   4668~            	; check if the media has changed before every disk operation, so we
1648   4668~            	; need to always check if it changed.
1649   4668~            	and	SD_M_DSKCHG	; Was the card changed since last checked?
1650   4668~            	ret	z		; No, return
1651   4668~            	push	bc,de,hl,ix
1652   4668~            	call	detectaCartao	; Detect the new card
1653   4668~            	pop	ix,hl,de,bc
1654   4668~            	ret	c		; Error? Then return
1655   4668~            	ld	a,1
1656   4668~            	ret
1657   4668              ENDIF ; BLA
1658   4668             
1659   4668             ; ------------------------------------------------
1660   4668             ; Grava um bloco de 512 bytes no cartao
1661   4668             ; HL = aponta para o inicio dos dados
1662   4668             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
1663   4668             ; IXH = Number of blocks
1664   4668             ; IXL = SDcard version (0 or 1)
1665   4668             ; Modifies:  AF, BC, DE, HL, IXL
1666   4668             ; ------------------------------------------------
1667   4668             GravarBloco: 
1668   4668              IFDEF DEBUG
1669   4668~            	push	af
1670   4668~            	ld	a,'G'
1671   4668~            	call	PRTCHAR
1672   4668~            	pop	af
1673   4668              ENDIF
1674   4668             ;	ld	a, (ix+15)	; verificar se eh SDV1 ou SDV2
1675   4668 DD 7D       	ld	a,ixl
1676   466A B7          	or	a
1677   466B CC 5A 47    	call	z,blocoParaByte		; se for SDV1 coverter blocos para bytes
1678   466E             ;	call	setaSDAtual	; selecionar cartao atual
1679   466E FD 7E 32    	ld	a, (iy+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
1680   4671 DD 67       	ld	ixh,a		; ixh=Number of blocks
1681   4673 3D          	dec	a
1682   4674 CA D5 46    	jp	z,.umBloco	; somente um bloco, gravar usando CMD24
1683   4677             
1684   4677             ; multiplos blocos
1685   4677              IFDEF DEBUG
1686   4677~            	push	af
1687   4677~            	ld	a,'M'
1688   4677~            	call	PRTCHAR
1689   4677~            	pop	af
1690   4677              ENDIF
1691   4677 C5          	push	bc
1692   4678 D5          	push	de
1693   4679 3E 77       	ld	a, CMD55	; Multiplos blocos, mandar ACMD23 com total de blocos
1694   467B CD D1 45    	call	SD_SEND_CMD_NO_ARGS
1695   467E 3E 57       	ld	a, ACMD23
1696   4680 01 00 00    	ld	bc, 0
1697   4683 51          	ld	d, c
1698   4684 FD 5E 32    	ld	e, (iy+WRKAREA.NUMBLOCKS)	; parametro = total de blocos a gravar
1699   4687 CD D6 45    	call	SD_SEND_CMD_GET_ERROR
1700   468A D1          	pop	de
1701   468B C1          	pop	bc
1702   468C DA 00 47    	jp	c,terminaLeituraEscritaBloco	; erro no ACMD23
1703   468F              IFDEF DEBUG
1704   468F~            	call	PRTDOT
1705   468F              ENDIF
1706   468F 3E 59       	ld	a, CMD25	; comando CMD25 = write multiple blocks
1707   4691 CD D6 45    	call	SD_SEND_CMD_GET_ERROR
1708   4694 DA 00 47    	jp	c,terminaLeituraEscritaBloco	; erro
1709   4697              IFDEF DEBUG
1710   4697~            	call	PRTDOT
1711   4697              ENDIF
1712   4697             .loop: 
1713   4697              IFDEF DEBUG
1714   4697~            	call	PRTDASH
1715   4697              ENDIF
1716   4697 3E FC       	ld	a, $FC		; mandar $FC para indicar que os proximos dados sao
1717   4699 32 00 7B    	ld	(SPIDATA),a	; dados para gravacao
1718   469C             
1719   469C 11 00 7B    	ld	de,SPIDATA
1720   469F CD 5C 4D    	call	RUN_HLPR
1721   46A2             
1722   46A2             ;	ld	de,$FFFF	; envia dummy CRC
1723   46A2             ;	ld	(SPIDATA),de
1724   46A2 32 00 7B    	ld	(SPIDATA),a
1725   46A5 32 00 7B    	ld	(SPIDATA),a
1726   46A8 CD 3E 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1727   46AB E6 1F       	and	$1F		; testa bits erro
1728   46AD FE 05       	cp	5
1729   46AF 37          	scf
1730   46B0 C2 00 47    	jp	nz,terminaLeituraEscritaBloco	; resposta errada, informar erro
1731   46B3 CD 4D 46    	call	WAIT_RESP_NO_00	; esperar cartao
1732   46B6 DA 00 47    	jp	c,terminaLeituraEscritaBloco
1733   46B9 DD 25       	dec	ixh		; Next block
1734   46BB C2 97 46    	jp	nz,.loop
1735   46BE             
1736   46BE             ;	ld	hl, (SPIDATA)	; acabou os blocos, fazer 2 dummy reads
1737   46BE 3A 00 7B    	ld	a, (SPIDATA)
1738   46C1 3A 00 7B    	ld	a, (SPIDATA)
1739   46C4 3E FD       	ld	a, $FD		; enviar $FD para informar ao cartao que acabou os dados
1740   46C6 32 00 7B    	ld	(SPIDATA),a
1741   46C9             ;	ld	hl,(SPIDATA)	; 2 dummy reads
1742   46C9 3A 00 7B    	ld	a, (SPIDATA)
1743   46CC 3A 00 7B    	ld	a, (SPIDATA)
1744   46CF CD 4D 46    	call	WAIT_RESP_NO_00	; esperar cartao
1745   46D2 C3 FF 46    	jp	.fim		; CMD25 concluido, sair informando nenhum erro
1746   46D5             
1747   46D5             .umBloco: 
1748   46D5              IFDEF DEBUG
1749   46D5~            	push	af
1750   46D5~            	ld	a,'S'
1751   46D5~            	call	PRTCHAR
1752   46D5~            	pop	af
1753   46D5              ENDIF
1754   46D5 3E 58       	ld	a, CMD24	; gravar somente um bloco com comando CMD24 = Write Single Block
1755   46D7 CD D6 45    	call	SD_SEND_CMD_GET_ERROR
1756   46DA DA 00 47    	jp	c,terminaLeituraEscritaBloco	; erro
1757   46DD             
1758   46DD              IFDEF DEBUG
1759   46DD~            	call	PRTDOT
1760   46DD              ENDIF
1761   46DD 3E FE       	ld	a, $FE		; mandar $FE para indicar que vamos mandar dados para gravacao
1762   46DF 32 00 7B    	ld	(SPIDATA),a
1763   46E2             
1764   46E2 11 00 7B    	ld	de,SPIDATA
1765   46E5 CD 5C 4D    	call	RUN_HLPR
1766   46E8             
1767   46E8             ;	ld	de,$FFFF	; envia dummy CRC
1768   46E8             ;	ld	(SPIDATA),de
1769   46E8 32 00 7B    	ld	(SPIDATA),a
1770   46EB 32 00 7B    	ld	(SPIDATA),a
1771   46EE CD 3E 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1772   46F1 E6 1F       	and	$1F		; testa bits erro
1773   46F3 FE 05       	cp	5
1774   46F5 37          	scf
1775   46F6 C2 00 47    	jp	nz,terminaLeituraEscritaBloco	; resposta errada, informar erro
1776   46F9             .esp: 
1777   46F9 CD 3E 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1778   46FC B7          	or	a
1779   46FD 28 FA       	jr	z,.esp
1780   46FF             .fim: 
1781   46FF AF          	xor	a		; zera carry e informa nenhum erro
1782   4700             terminaLeituraEscritaBloco: 
1783   4700             ;	push	af
1784   4700 CD BA 45    	call	disableSDs	; desabilitar todos os cartoes
1785   4703             ;	pop	af
1786   4703 C9          	ret
1787   4704             
1788   4704             
1789   4704             ; ------------------------------------------------
1790   4704             ; Ler um bloco de 512 bytes do cartao
1791   4704             ; HL =  aponta para o inicio dos dados
1792   4704             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
1793   4704             ; IXH = Number of blocks
1794   4704             ; IXL = SDcard version (0 or 1)
1795   4704             ; Destroi AF, BC, DE, HL, IXL
1796   4704             ; ------------------------------------------------
1797   4704             LerBloco: 
1798   4704             ;	ld	a, (ix+15)	; verificar se eh SDV1 ou SDV2
1799   4704 DD 7D       	ld	a,ixl
1800   4706 B7          	or	a
1801   4707 CC 5A 47    	call	z,blocoParaByte	; se for SDV1 coverter blocos para bytes
1802   470A             ;	call	setaSDAtual
1803   470A             
1804   470A FD 7E 32    	ld	a, (iy+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
1805   470D DD 67       	ld	ixh,a		; ixh=Number of blocks
1806   470F 3D          	dec	a
1807   4710 CA 3B 47    	jp	z,.umBloco	; only one block
1808   4713             
1809   4713             ; multiplos blocos
1810   4713 3E 52       	ld	a, CMD18	; ler multiplos blocos com CMD18 = Read Multiple Blocks
1811   4715 CD D6 45    	call	SD_SEND_CMD_GET_ERROR
1812   4718 DA 00 47    	jp	c,terminaLeituraEscritaBloco
1813   471B EB          	ex	de,hl		; de=Destination address
1814   471C             .loop: 
1815   471C CD 30 46    	call	WAIT_RESP_FE
1816   471F DA 00 47    	jp	c,terminaLeituraEscritaBloco
1817   4722             
1818   4722 21 00 7B    	ld	hl, SPIDATA
1819   4725 CD 5C 4D    	call	RUN_HLPR
1820   4728             
1821   4728             ;	ld	hl, (SPIDATA)	; descarta CRC
1822   4728 3A 00 7B    	ld	a, (SPIDATA)
1823   472B 3A 00 7B    	ld	a, (SPIDATA)
1824   472E DD 25       	dec	ixh
1825   4730 C2 1C 47    	jp	nz,.loop
1826   4733 3E 4C       	ld	a, CMD12	; acabou os blocos, mandar CMD12 para cancelar leitura
1827   4735 CD D1 45    	call	SD_SEND_CMD_NO_ARGS
1828   4738 C3 56 47    	jp	.fim
1829   473B             
1830   473B             .umBloco: 
1831   473B 3E 51       	ld	a, CMD17	; ler somente um bloco com CMD17 = Read Single Block
1832   473D CD D6 45    	call	SD_SEND_CMD_GET_ERROR
1833   4740 DA 00 47    	jp	c,terminaLeituraEscritaBloco
1834   4743             
1835   4743 CD 30 46    	call	WAIT_RESP_FE
1836   4746 DA 00 47    	jp	c,terminaLeituraEscritaBloco
1837   4749 EB          	ex	de,hl
1838   474A             
1839   474A 21 00 7B    	ld	hl, SPIDATA
1840   474D CD 5C 4D    	call	RUN_HLPR
1841   4750             
1842   4750             ;	ld	hl, (SPIDATA)	; descarta CRC
1843   4750 3A 00 7B    	ld	a, (SPIDATA)
1844   4753 3A 00 7B    	ld	a, (SPIDATA)
1845   4756             .fim: 
1846   4756 AF          	xor	a		; zera carry para informar leitura sem erros
1847   4757 C3 00 47    	jp	terminaLeituraEscritaBloco
1848   475A             
1849   475A             
1850   475A             ; ------------------------------------------------
1851   475A             ; Converte blocos para bytes. Na pratica faz
1852   475A             ; BC DE = (BC DE) * 512
1853   475A             ; ------------------------------------------------
1854   475A             blocoParaByte: 
1855   475A 41          	ld	b, c
1856   475B 4A          	ld	c, d
1857   475C 53          	ld	d, e
1858   475D 1E 00       	ld	e, 0
1859   475F CB 22       	sla	d
1860   4761 CB 11       	rl	c
1861   4763 CB 10       	rl	b
1862   4765 C9          	ret
1863   4766             
1864   4766             ; ------------------------------------------------
1865   4766             ; Funcoes utilitarias
1866   4766             ; ------------------------------------------------
1867   4766             
1868   4766             
1869   4766             ; ------------------------------------------------
1870   4766             ; Imprime string na tela apontada por DE
1871   4766             ; Destroi todos os registradores
1872   4766             ; ------------------------------------------------
1873   4766             printString: 
1874   4766 1A          	ld	a, (de)
1875   4767 B7          	or	a
1876   4768 C8          	ret	z
1877   4769 CD A2 00    	call	CHPUT
1878   476C 13          	inc	de
1879   476D 18 F7       	jr	printString
1880   476F             
1881   476F             
1882   476F             ; ------------------------------------------------
1883   476F             ; Converte o byte em A para string em decimal no
1884   476F             ; buffer apontado por DE
1885   476F             ; Destroi AF, BC, HL, DE
1886   476F             ; ------------------------------------------------
1887   476F             DecToAscii: 
1888   476F 26 00       	ld	h, 0
1889   4771 6F          	ld	l, a		; copiar A para HL
1890   4772 FD 36 39 01 	ld	(iy+WRKAREA.TEMP),1	; flag para indicar que devemos cortar os zeros a esquerda
1891   4776 01 9C FF    	ld	bc, -100	; centenas
1892   4779 CD 87 47    	call	.num1
1893   477C 0E F6       	ld	c, -10		; dezenas
1894   477E CD 87 47    	call	.num1
1895   4781 FD 36 39 02 	ld	(iy+WRKAREA.TEMP),2	; unidade deve exibir 0 se for zero e nao corta-lo
1896   4785 0E FF       	ld	c, -1		; unidades
1897   4787             .num1: 
1898   4787 3E 2F       	ld	a, '0'-1
1899   4789             .num2: 
1900   4789 3C          	inc	a		; contar o valor em ascii de '0' a '9'
1901   478A 09          	add	hl, bc		; somar com negativo
1902   478B 38 FC       	jr	c,.num2		; ainda nao zeramos
1903   478D ED 42       	sbc	hl, bc		; retoma valor original
1904   478F FD 35 39    	dec	(iy+WRKAREA.TEMP)	; se flag do corte do zero indicar para nao cortar, pula
1905   4792 20 08       	jr	nz,.naozero
1906   4794 FE 30       	cp	'0'		; devemos cortar os zeros a esquerda. Eh zero?
1907   4796 20 04       	jr	nz,.naozero
1908   4798 FD 34 39    	inc	(iy+WRKAREA.TEMP)	; se for zero, nao salvamos e voltamos a flag
1909   479B C9          	ret
1910   479C             .naozero: 
1911   479C 12          	ld	(de), a		; eh zero ou eh outro numero, salvar
1912   479D 13          	inc	de		; incrementa ponteiro de destino
1913   479E C9          	ret
1914   479F             
1915   479F             ; ------------------------------------------------
1916   479F             ; Converte o byte em A para string em hexa no
1917   479F             ; buffer apontado por DE
1918   479F             ; Destroi AF, C, DE
1919   479F             ; ------------------------------------------------
1920   479F             HexToAscii: 
1921   479F 4F          	ld	c, a
1922   47A0 1F          	rra
1923   47A1 1F          	rra
1924   47A2 1F          	rra
1925   47A3 1F          	rra
1926   47A4 CD A8 47    	call	.conv
1927   47A7 79          	ld  	a, c
1928   47A8             .conv: 
1929   47A8 E6 0F       	and	$0F
1930   47AA C6 90       	add	a, $90
1931   47AC 27          	daa
1932   47AD CE 40       	adc	a, $40
1933   47AF 27          	daa
1934   47B0 12          	ld	(de), a
1935   47B1 13          	inc	de
1936   47B2 C9          	ret
1937   47B3             
1938   47B3             ; ------------------------------------------------
1939   47B3             ; Converte o byte em A para string em decimal e
1940   47B3             ; imprime na tela
1941   47B3             ; Destroi AF, BC, HL, DE
1942   47B3             ; ------------------------------------------------
1943   47B3             printDecToAscii: 
1944   47B3 26 00       	ld	h, 0
1945   47B5 6F          	ld	l, a		; copiar A para HL
1946   47B6 06 01       	ld	b, 1		; flag para indicar que devemos cortar os zeros a esquerda
1947   47B8 11 9C FF    	ld	de, -100	; centenas
1948   47BB CD C7 47    	call	.num1
1949   47BE 1E F6       	ld	e, -10		; dezenas
1950   47C0 CD C7 47    	call	.num1
1951   47C3 06 02       	ld	b, 2		; unidade deve exibir 0 se for zero e nao corta-lo
1952   47C5 1E FF       	ld	e, -1		; unidades
1953   47C7             .num1: 
1954   47C7 3E 2F       	ld	a, '0'-1
1955   47C9             .num2: 
1956   47C9 3C          	inc	a		; contar o valor em ascii de '0' a '9'
1957   47CA 19          	add	hl, de		; somar com negativo
1958   47CB 38 FC       	jr	c,.num2		; ainda nao zeramos
1959   47CD ED 52       	sbc	hl, de		; retoma valor original
1960   47CF 10 06       	djnz	.naozero	; se flag do corte do zero indicar para nao cortar, pula
1961   47D1 FE 30       	cp	'0'		; devemos cortar os zeros a esquerda. Eh zero?
1962   47D3 20 02       	jr	nz,.naozero
1963   47D5 04          	inc	b		; se for zero, nao imprimimos e voltamos a flag
1964   47D6 C9          	ret
1965   47D7             .naozero: 
1966   47D7 E5          	push	hl		; nao eh zero ou eh outro numero, imprimir
1967   47D8 C5          	push	bc
1968   47D9 CD A2 00    	call	CHPUT
1969   47DC C1          	pop	bc
1970   47DD E1          	pop	hl
1971   47DE C9          	ret
1972   47DF             
1973   47DF             ; ------------------------------------------------
1974   47DF             ; Procura pelo nome do fabricante em uma tabela.
1975   47DF             ; A contem o byte do fabricante
1976   47DF             ; Devolve HL apontando para o buffer do fabricante
1977   47DF             ; e BC com o comprimento do texto
1978   47DF             ; Destroi AF, BC, HL
1979   47DF             ; ------------------------------------------------
1980   47DF             pegaFabricante: 
1981   47DF 4F          	ld	c, a
1982   47E0 21 01 48    	ld	hl, tblFabricantes
1983   47E3             
1984   47E3             .loop: 
1985   47E3 7E          	ld	a, (hl)
1986   47E4 23          	inc	hl
1987   47E5 B9          	cp	c
1988   47E6 28 0C       	jr	z,.achado
1989   47E8 B7          	or	a
1990   47E9 28 09       	jr	z,.achado
1991   47EB C5          	push	bc
1992   47EC CD F4 47    	call	.achado
1993   47EF 09          	add	hl, bc
1994   47F0 23          	inc	hl
1995   47F1 C1          	pop	bc
1996   47F2 18 EF       	jr	.loop
1997   47F4             
1998   47F4             .achado: 
1999   47F4 0E 00       	ld	c, 0
2000   47F6 E5          	push	hl
2001   47F7 AF          	xor	a
2002   47F8             .loop2: 
2003   47F8 0C          	inc	c
2004   47F9 23          	inc	hl
2005   47FA BE          	cp	(hl)
2006   47FB 20 FB       	jr	nz,.loop2
2007   47FD E1          	pop	hl
2008   47FE 06 00       	ld	b, 0
2009   4800 C9          	ret
2010   4801             
2011   4801             tblFabricantes: 
2012   4801 01          	db	1
2013   4802             	db	"Panasonic",0
2013   4802 50616E61736F6E696300
2014   480C 02          	db	2
2015   480D             	db	"Toshiba",0
2015   480D 546F736869626100
2016   4815 03          	db	3
2017   4816             	db	"SanDisk",0
2017   4816 53616E4469736B00
2018   481E 04          	db	4
2019   481F             	db	"SMI-S",0
2019   481F 534D492D5300
2020   4825 06          	db	6
2021   4826             	db	"Renesas",0
2021   4826 52656E6573617300
2022   482E 11          	db	17
2023   482F             	db	"Dane-Elec",0
2023   482F 44616E652D456C656300
2024   4839 13          	db	19
2025   483A             	db	"KingMax",0
2025   483A 4B696E674D617800
2026   4842 15          	db	21
2027   4843             	db	"Samsung",0
2027   4843 53616D73756E6700
2028   484B 18          	db	24
2029   484C             	db	"Infineon",0
2029   484C 496E66696E656F6E00
2030   4855 1A          	db	26
2031   4856 50 51 49 00 	db	"PQI",0
2032   485A 1B          	db	27
2033   485B 536F6E7900  	db	"Sony",0
2034   4860 1C          	db	28
2035   4861             	db	"Transcend",0
2035   4861 5472616E7363656E6400
2036   486B 1D          	db	29
2037   486C             	db	"A-DATA",0
2037   486C 412D4441544100
2038   4873 1F          	db	31
2039   4874             	db	"SiliconPower",0
2039   4874 53696C69636F6E506F77657200
2040   4881 27          	db	39
2041   4882             	db	"Verbatim",0
2041   4882 566572626174696D00
2042   488B 41          	db	65
2043   488C 4F 4B 49 00 	db	"OKI",0
2044   4890 73          	db	115
2045   4891             	db	"SilverHT",0
2045   4891 53696C766572485400
2046   489A 89          	db	137
2047   489B             	db	"L.Data",0
2047   489B 4C2E4461746100
2048   48A2 00          	db	0
2049   48A3             	db	"Generico",0
2049   48A3 47656E657269636F00
2050   48AC             
2051   48AC             
2052   48AC             ; ------------------------------------------------
2053   48AC             ; Restore screen parameters on MSX>=2 if they're
2054   48AC             ; not set yet
2055   48AC             ; ------------------------------------------------
2056   48AC             MYSETSCR: 
2057   48AC 3A 2D 00    	ld	a,(MSXVER)
2058   48AF B7          	or	a			; MSX1?
2059   48B0 20 08       	jr	nz,.notMSX1		; No, skip
2060   48B2             .MSX1: 
2061   48B2 3A AF FC    	ld	a,(SCRMOD)
2062   48B5 B7          	or	a			; SCREEN0 already?
2063   48B6 C8          	ret	z			; Yes, quit
2064   48B7 C3 6C 00    	jp	INITXT			; set screen0
2065   48BA             
2066   48BA             .notMSX1: 
2067   48BA 0E 23       	ld	c,$23			; Block-2, R#3
2068   48BC DD 21 F5 01 	ld 	ix,REDCLK
2069   48C0 CD 5F 01    	call	EXTROM
2070   48C3 E6 01       	and	1
2071   48C5 47          	ld	b,a
2072   48C6 3A AF FC    	ld	a,(SCRMOD)
2073   48C9 B8          	cp	b
2074   48CA 20 1C       	jr	nz,.restore
2075   48CC 0C          	inc	c
2076   48CD DD 21 F5 01 	ld 	ix,REDCLK
2077   48D1 CD 5F 01    	call	EXTROM
2078   48D4 47          	ld	b,a
2079   48D5 0C          	inc	c
2080   48D6 DD 21 F5 01 	ld 	ix,REDCLK
2081   48DA CD 5F 01    	call	EXTROM
2082   48DD 87          	add	a,a
2083   48DE 87          	add	a,a
2084   48DF 87          	add	a,a
2085   48E0 87          	add	a,a
2086   48E1 B0          	or	b
2087   48E2 47          	ld	b,a
2088   48E3 3A B0 F3    	ld	a,(LINLEN)
2089   48E6 B8          	cp	b
2090   48E7 C8          	ret	z
2091   48E8             .restore: 
2092   48E8 AF          	xor	a		; Don't displat the function keys
2093   48E9 DD 21 85 01 	ld	ix,SDFSCR
2094   48ED C3 5F 01    	jp	EXTROM
2095   48F0             
2096   48F0             ; ------------------------------------------------
2097   48F0             ; Check if the STOP key was signaled on DRV_INIT
2098   48F0             ; ------------------------------------------------
2099   48F0             INICHKSTOP: 
2100   48F0 3A 9B FC    	ld	a,(INTFLG)
2101   48F3 FE 04       	cp	4			; Was STOP pressed?
2102   48F5 C0          	ret	nz			; No, quit as fast as possible 
2103   48F6             
2104   48F6             	; Handle STOP to pause and read messages, and ask for the copyright info
2105   48F6 11 94 4D    	ld	de,strBootpaused
2106   48F9 CD 66 47    	call	printString
2107   48FC 3E 07       .wait1: 	ld	a,7
2108   48FE CD 41 01    	call	SNSMAT
2109   4901 E6 10       	and	$10			; Is STOP still pressed?
2110   4903 28 F7       	jr	z,.wait1		; Wait for STOP to be released
2111   4905 AF          	xor	a
2112   4906 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2113   4909 06 00       	ld	b,0			; b=inhibit 'i' key flag
2114   490B CD 9C 00    .wait2:  call	CHSNS
2115   490E C4 2B 49    	call	nz,.chkikey		; Wait until a key is pressed
2116   4911 3A 9B FC    	ld	a,(INTFLG)
2117   4914 FE 04       	cp	4			; Was STOP pressed?
2118   4916 20 F3       	jr	nz,.wait2		; No, return
2119   4918 AF          	xor	a
2120   4919 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2121   491C CD 56 01    	call	KILBUF
2122   491F 06 1E       	ld	b,30			; Since the user is trying pause the
2123   4921 76          .wait3: 	halt				; boot messages, this gives him enough
2124   4922             					; time to react and pause the next
2125   4922             					; driver
2126   4922 3A 9B FC    	ld	a,(INTFLG)
2127   4925 FE 04       	cp	4			; Was STOP pressed?
2128   4927 C8          	ret	z			; quit so the next driver can process it
2129   4928 10 F7       	djnz	.wait3			; The user will have the impression
2130   492A             					; that he has a perfect timing.   ;)
2131   492A C9          	ret
2132   492B             
2133   492B             .chkikey: 
2134   492B CB 40       	bit	0,b			; Was the copyright message shown?
2135   492D C0          	ret	nz			; Yes, return
2136   492E CD 9F 00    	call	CHGET
2137   4931 FE 69       	cp	'i'
2138   4933 28 03       	jr	z,.showcopyright
2139   4935 FE 49       	cp	'I'
2140   4937 C0          	ret	nz
2141   4938             .showcopyright: 
2142   4938 04          	inc	b			; Inhibit further presses of the i key 
2143   4939 11 BF 4D    	ld	de,strCopyright
2144   493C C3 66 47    	jp	printString
2145   493F             
2146   493F             
2147   493F             
2148   493F             ; ------------------------------------------------
2149   493F             ; Install the R800 data transfer helper routine on WorkArea 
2150   493F             ; ------------------------------------------------
2151   493F             INSTR800HLP: 
2152   493F 3A 2D 00    	ld	a,(MSXVER)
2153   4942 FE 03       	cp	3		; MSX Turbo-R?
2154   4944 D8          	ret	c		; No, return
2155   4945 CD 6B 4D    	call	GTR800LDIR
2156   4948 D9          	exx
2157   4949 EB          	ex	de,hl
2158   494A 21 53 49    	ld	hl,R800DATHLP
2159   494D 01 07 00    	ld	bc,R800DATHLP.end-R800DATHLP
2160   4950 ED B0       	ldir
2161   4952 C9          	ret
2162   4953             
2163   4953             ; ------------------------------------------------
2164   4953             ; R800 optimized data transfer routine, copied to the WorkArea
2165   4953             ; ------------------------------------------------
2166   4953             R800DATHLP: 
2167   4953 D9          	exx
2168   4954 01 00 02    	ld	bc,512
2169   4957 ED B0       	ldir
2170   4959 C9          	ret
2171   495A             .end
2172   495A              
2173   495A             
2174   495A             ; ------------------------------------------------
2175   495A             ; Z80 optimized data transfer routine, kept in ROM 
2176   495A             ; ------------------------------------------------
2177   495A             LDI512: 	; Z80 optimized 512 byte transfer
2178   495A D9          	exx
2179   495B ED A0       > ldi
2179   495D ED A0       > ldi
2179   495F ED A0       > ldi
2179   4961 ED A0       > ldi
2179   4963 ED A0       > ldi
2179   4965 ED A0       > ldi
2179   4967 ED A0       > ldi
2179   4969 ED A0       > ldi
2179   496B ED A0       > ldi
2179   496D ED A0       > ldi
2179   496F ED A0       > ldi
2179   4971 ED A0       > ldi
2179   4973 ED A0       > ldi
2179   4975 ED A0       > ldi
2179   4977 ED A0       > ldi
2179   4979 ED A0       > ldi
2179   497B ED A0       > ldi
2179   497D ED A0       > ldi
2179   497F ED A0       > ldi
2179   4981 ED A0       > ldi
2179   4983 ED A0       > ldi
2179   4985 ED A0       > ldi
2179   4987 ED A0       > ldi
2179   4989 ED A0       > ldi
2179   498B ED A0       > ldi
2179   498D ED A0       > ldi
2179   498F ED A0       > ldi
2179   4991 ED A0       > ldi
2179   4993 ED A0       > ldi
2179   4995 ED A0       > ldi
2179   4997 ED A0       > ldi
2179   4999 ED A0       > ldi
2179   499B ED A0       > ldi
2179   499D ED A0       > ldi
2179   499F ED A0       > ldi
2179   49A1 ED A0       > ldi
2179   49A3 ED A0       > ldi
2179   49A5 ED A0       > ldi
2179   49A7 ED A0       > ldi
2179   49A9 ED A0       > ldi
2179   49AB ED A0       > ldi
2179   49AD ED A0       > ldi
2179   49AF ED A0       > ldi
2179   49B1 ED A0       > ldi
2179   49B3 ED A0       > ldi
2179   49B5 ED A0       > ldi
2179   49B7 ED A0       > ldi
2179   49B9 ED A0       > ldi
2179   49BB ED A0       > ldi
2179   49BD ED A0       > ldi
2179   49BF ED A0       > ldi
2179   49C1 ED A0       > ldi
2179   49C3 ED A0       > ldi
2179   49C5 ED A0       > ldi
2179   49C7 ED A0       > ldi
2179   49C9 ED A0       > ldi
2179   49CB ED A0       > ldi
2179   49CD ED A0       > ldi
2179   49CF ED A0       > ldi
2179   49D1 ED A0       > ldi
2179   49D3 ED A0       > ldi
2179   49D5 ED A0       > ldi
2179   49D7 ED A0       > ldi
2179   49D9 ED A0       > ldi
2179   49DB ED A0       > ldi
2179   49DD ED A0       > ldi
2179   49DF ED A0       > ldi
2179   49E1 ED A0       > ldi
2179   49E3 ED A0       > ldi
2179   49E5 ED A0       > ldi
2179   49E7 ED A0       > ldi
2179   49E9 ED A0       > ldi
2179   49EB ED A0       > ldi
2179   49ED ED A0       > ldi
2179   49EF ED A0       > ldi
2179   49F1 ED A0       > ldi
2179   49F3 ED A0       > ldi
2179   49F5 ED A0       > ldi
2179   49F7 ED A0       > ldi
2179   49F9 ED A0       > ldi
2179   49FB ED A0       > ldi
2179   49FD ED A0       > ldi
2179   49FF ED A0       > ldi
2179   4A01 ED A0       > ldi
2179   4A03 ED A0       > ldi
2179   4A05 ED A0       > ldi
2179   4A07 ED A0       > ldi
2179   4A09 ED A0       > ldi
2179   4A0B ED A0       > ldi
2179   4A0D ED A0       > ldi
2179   4A0F ED A0       > ldi
2179   4A11 ED A0       > ldi
2179   4A13 ED A0       > ldi
2179   4A15 ED A0       > ldi
2179   4A17 ED A0       > ldi
2179   4A19 ED A0       > ldi
2179   4A1B ED A0       > ldi
2179   4A1D ED A0       > ldi
2179   4A1F ED A0       > ldi
2179   4A21 ED A0       > ldi
2179   4A23 ED A0       > ldi
2179   4A25 ED A0       > ldi
2179   4A27 ED A0       > ldi
2179   4A29 ED A0       > ldi
2179   4A2B ED A0       > ldi
2179   4A2D ED A0       > ldi
2179   4A2F ED A0       > ldi
2179   4A31 ED A0       > ldi
2179   4A33 ED A0       > ldi
2179   4A35 ED A0       > ldi
2179   4A37 ED A0       > ldi
2179   4A39 ED A0       > ldi
2179   4A3B ED A0       > ldi
2179   4A3D ED A0       > ldi
2179   4A3F ED A0       > ldi
2179   4A41 ED A0       > ldi
2179   4A43 ED A0       > ldi
2179   4A45 ED A0       > ldi
2179   4A47 ED A0       > ldi
2179   4A49 ED A0       > ldi
2179   4A4B ED A0       > ldi
2179   4A4D ED A0       > ldi
2179   4A4F ED A0       > ldi
2179   4A51 ED A0       > ldi
2179   4A53 ED A0       > ldi
2179   4A55 ED A0       > ldi
2179   4A57 ED A0       > ldi
2179   4A59 ED A0       > ldi
2179   4A5B ED A0       > ldi
2179   4A5D ED A0       > ldi
2179   4A5F ED A0       > ldi
2179   4A61 ED A0       > ldi
2179   4A63 ED A0       > ldi
2179   4A65 ED A0       > ldi
2179   4A67 ED A0       > ldi
2179   4A69 ED A0       > ldi
2179   4A6B ED A0       > ldi
2179   4A6D ED A0       > ldi
2179   4A6F ED A0       > ldi
2179   4A71 ED A0       > ldi
2179   4A73 ED A0       > ldi
2179   4A75 ED A0       > ldi
2179   4A77 ED A0       > ldi
2179   4A79 ED A0       > ldi
2179   4A7B ED A0       > ldi
2179   4A7D ED A0       > ldi
2179   4A7F ED A0       > ldi
2179   4A81 ED A0       > ldi
2179   4A83 ED A0       > ldi
2179   4A85 ED A0       > ldi
2179   4A87 ED A0       > ldi
2179   4A89 ED A0       > ldi
2179   4A8B ED A0       > ldi
2179   4A8D ED A0       > ldi
2179   4A8F ED A0       > ldi
2179   4A91 ED A0       > ldi
2179   4A93 ED A0       > ldi
2179   4A95 ED A0       > ldi
2179   4A97 ED A0       > ldi
2179   4A99 ED A0       > ldi
2179   4A9B ED A0       > ldi
2179   4A9D ED A0       > ldi
2179   4A9F ED A0       > ldi
2179   4AA1 ED A0       > ldi
2179   4AA3 ED A0       > ldi
2179   4AA5 ED A0       > ldi
2179   4AA7 ED A0       > ldi
2179   4AA9 ED A0       > ldi
2179   4AAB ED A0       > ldi
2179   4AAD ED A0       > ldi
2179   4AAF ED A0       > ldi
2179   4AB1 ED A0       > ldi
2179   4AB3 ED A0       > ldi
2179   4AB5 ED A0       > ldi
2179   4AB7 ED A0       > ldi
2179   4AB9 ED A0       > ldi
2179   4ABB ED A0       > ldi
2179   4ABD ED A0       > ldi
2179   4ABF ED A0       > ldi
2179   4AC1 ED A0       > ldi
2179   4AC3 ED A0       > ldi
2179   4AC5 ED A0       > ldi
2179   4AC7 ED A0       > ldi
2179   4AC9 ED A0       > ldi
2179   4ACB ED A0       > ldi
2179   4ACD ED A0       > ldi
2179   4ACF ED A0       > ldi
2179   4AD1 ED A0       > ldi
2179   4AD3 ED A0       > ldi
2179   4AD5 ED A0       > ldi
2179   4AD7 ED A0       > ldi
2179   4AD9 ED A0       > ldi
2179   4ADB ED A0       > ldi
2179   4ADD ED A0       > ldi
2179   4ADF ED A0       > ldi
2179   4AE1 ED A0       > ldi
2179   4AE3 ED A0       > ldi
2179   4AE5 ED A0       > ldi
2179   4AE7 ED A0       > ldi
2179   4AE9 ED A0       > ldi
2179   4AEB ED A0       > ldi
2179   4AED ED A0       > ldi
2179   4AEF ED A0       > ldi
2179   4AF1 ED A0       > ldi
2179   4AF3 ED A0       > ldi
2179   4AF5 ED A0       > ldi
2179   4AF7 ED A0       > ldi
2179   4AF9 ED A0       > ldi
2179   4AFB ED A0       > ldi
2179   4AFD ED A0       > ldi
2179   4AFF ED A0       > ldi
2179   4B01 ED A0       > ldi
2179   4B03 ED A0       > ldi
2179   4B05 ED A0       > ldi
2179   4B07 ED A0       > ldi
2179   4B09 ED A0       > ldi
2179   4B0B ED A0       > ldi
2179   4B0D ED A0       > ldi
2179   4B0F ED A0       > ldi
2179   4B11 ED A0       > ldi
2179   4B13 ED A0       > ldi
2179   4B15 ED A0       > ldi
2179   4B17 ED A0       > ldi
2179   4B19 ED A0       > ldi
2179   4B1B ED A0       > ldi
2179   4B1D ED A0       > ldi
2179   4B1F ED A0       > ldi
2179   4B21 ED A0       > ldi
2179   4B23 ED A0       > ldi
2179   4B25 ED A0       > ldi
2179   4B27 ED A0       > ldi
2179   4B29 ED A0       > ldi
2179   4B2B ED A0       > ldi
2179   4B2D ED A0       > ldi
2179   4B2F ED A0       > ldi
2179   4B31 ED A0       > ldi
2179   4B33 ED A0       > ldi
2179   4B35 ED A0       > ldi
2179   4B37 ED A0       > ldi
2179   4B39 ED A0       > ldi
2179   4B3B ED A0       > ldi
2179   4B3D ED A0       > ldi
2179   4B3F ED A0       > ldi
2179   4B41 ED A0       > ldi
2179   4B43 ED A0       > ldi
2179   4B45 ED A0       > ldi
2179   4B47 ED A0       > ldi
2179   4B49 ED A0       > ldi
2179   4B4B ED A0       > ldi
2179   4B4D ED A0       > ldi
2179   4B4F ED A0       > ldi
2179   4B51 ED A0       > ldi
2179   4B53 ED A0       > ldi
2179   4B55 ED A0       > ldi
2179   4B57 ED A0       > ldi
2179   4B59 ED A0       > ldi
2179   4B5B ED A0       > ldi
2179   4B5D ED A0       > ldi
2179   4B5F ED A0       > ldi
2179   4B61 ED A0       > ldi
2179   4B63 ED A0       > ldi
2179   4B65 ED A0       > ldi
2179   4B67 ED A0       > ldi
2179   4B69 ED A0       > ldi
2179   4B6B ED A0       > ldi
2179   4B6D ED A0       > ldi
2179   4B6F ED A0       > ldi
2179   4B71 ED A0       > ldi
2179   4B73 ED A0       > ldi
2179   4B75 ED A0       > ldi
2179   4B77 ED A0       > ldi
2179   4B79 ED A0       > ldi
2179   4B7B ED A0       > ldi
2179   4B7D ED A0       > ldi
2179   4B7F ED A0       > ldi
2179   4B81 ED A0       > ldi
2179   4B83 ED A0       > ldi
2179   4B85 ED A0       > ldi
2179   4B87 ED A0       > ldi
2179   4B89 ED A0       > ldi
2179   4B8B ED A0       > ldi
2179   4B8D ED A0       > ldi
2179   4B8F ED A0       > ldi
2179   4B91 ED A0       > ldi
2179   4B93 ED A0       > ldi
2179   4B95 ED A0       > ldi
2179   4B97 ED A0       > ldi
2179   4B99 ED A0       > ldi
2179   4B9B ED A0       > ldi
2179   4B9D ED A0       > ldi
2179   4B9F ED A0       > ldi
2179   4BA1 ED A0       > ldi
2179   4BA3 ED A0       > ldi
2179   4BA5 ED A0       > ldi
2179   4BA7 ED A0       > ldi
2179   4BA9 ED A0       > ldi
2179   4BAB ED A0       > ldi
2179   4BAD ED A0       > ldi
2179   4BAF ED A0       > ldi
2179   4BB1 ED A0       > ldi
2179   4BB3 ED A0       > ldi
2179   4BB5 ED A0       > ldi
2179   4BB7 ED A0       > ldi
2179   4BB9 ED A0       > ldi
2179   4BBB ED A0       > ldi
2179   4BBD ED A0       > ldi
2179   4BBF ED A0       > ldi
2179   4BC1 ED A0       > ldi
2179   4BC3 ED A0       > ldi
2179   4BC5 ED A0       > ldi
2179   4BC7 ED A0       > ldi
2179   4BC9 ED A0       > ldi
2179   4BCB ED A0       > ldi
2179   4BCD ED A0       > ldi
2179   4BCF ED A0       > ldi
2179   4BD1 ED A0       > ldi
2179   4BD3 ED A0       > ldi
2179   4BD5 ED A0       > ldi
2179   4BD7 ED A0       > ldi
2179   4BD9 ED A0       > ldi
2179   4BDB ED A0       > ldi
2179   4BDD ED A0       > ldi
2179   4BDF ED A0       > ldi
2179   4BE1 ED A0       > ldi
2179   4BE3 ED A0       > ldi
2179   4BE5 ED A0       > ldi
2179   4BE7 ED A0       > ldi
2179   4BE9 ED A0       > ldi
2179   4BEB ED A0       > ldi
2179   4BED ED A0       > ldi
2179   4BEF ED A0       > ldi
2179   4BF1 ED A0       > ldi
2179   4BF3 ED A0       > ldi
2179   4BF5 ED A0       > ldi
2179   4BF7 ED A0       > ldi
2179   4BF9 ED A0       > ldi
2179   4BFB ED A0       > ldi
2179   4BFD ED A0       > ldi
2179   4BFF ED A0       > ldi
2179   4C01 ED A0       > ldi
2179   4C03 ED A0       > ldi
2179   4C05 ED A0       > ldi
2179   4C07 ED A0       > ldi
2179   4C09 ED A0       > ldi
2179   4C0B ED A0       > ldi
2179   4C0D ED A0       > ldi
2179   4C0F ED A0       > ldi
2179   4C11 ED A0       > ldi
2179   4C13 ED A0       > ldi
2179   4C15 ED A0       > ldi
2179   4C17 ED A0       > ldi
2179   4C19 ED A0       > ldi
2179   4C1B ED A0       > ldi
2179   4C1D ED A0       > ldi
2179   4C1F ED A0       > ldi
2179   4C21 ED A0       > ldi
2179   4C23 ED A0       > ldi
2179   4C25 ED A0       > ldi
2179   4C27 ED A0       > ldi
2179   4C29 ED A0       > ldi
2179   4C2B ED A0       > ldi
2179   4C2D ED A0       > ldi
2179   4C2F ED A0       > ldi
2179   4C31 ED A0       > ldi
2179   4C33 ED A0       > ldi
2179   4C35 ED A0       > ldi
2179   4C37 ED A0       > ldi
2179   4C39 ED A0       > ldi
2179   4C3B ED A0       > ldi
2179   4C3D ED A0       > ldi
2179   4C3F ED A0       > ldi
2179   4C41 ED A0       > ldi
2179   4C43 ED A0       > ldi
2179   4C45 ED A0       > ldi
2179   4C47 ED A0       > ldi
2179   4C49 ED A0       > ldi
2179   4C4B ED A0       > ldi
2179   4C4D ED A0       > ldi
2179   4C4F ED A0       > ldi
2179   4C51 ED A0       > ldi
2179   4C53 ED A0       > ldi
2179   4C55 ED A0       > ldi
2179   4C57 ED A0       > ldi
2179   4C59 ED A0       > ldi
2179   4C5B ED A0       > ldi
2179   4C5D ED A0       > ldi
2179   4C5F ED A0       > ldi
2179   4C61 ED A0       > ldi
2179   4C63 ED A0       > ldi
2179   4C65 ED A0       > ldi
2179   4C67 ED A0       > ldi
2179   4C69 ED A0       > ldi
2179   4C6B ED A0       > ldi
2179   4C6D ED A0       > ldi
2179   4C6F ED A0       > ldi
2179   4C71 ED A0       > ldi
2179   4C73 ED A0       > ldi
2179   4C75 ED A0       > ldi
2179   4C77 ED A0       > ldi
2179   4C79 ED A0       > ldi
2179   4C7B ED A0       > ldi
2179   4C7D ED A0       > ldi
2179   4C7F ED A0       > ldi
2179   4C81 ED A0       > ldi
2179   4C83 ED A0       > ldi
2179   4C85 ED A0       > ldi
2179   4C87 ED A0       > ldi
2179   4C89 ED A0       > ldi
2179   4C8B ED A0       > ldi
2179   4C8D ED A0       > ldi
2179   4C8F ED A0       > ldi
2179   4C91 ED A0       > ldi
2179   4C93 ED A0       > ldi
2179   4C95 ED A0       > ldi
2179   4C97 ED A0       > ldi
2179   4C99 ED A0       > ldi
2179   4C9B ED A0       > ldi
2179   4C9D ED A0       > ldi
2179   4C9F ED A0       > ldi
2179   4CA1 ED A0       > ldi
2179   4CA3 ED A0       > ldi
2179   4CA5 ED A0       > ldi
2179   4CA7 ED A0       > ldi
2179   4CA9 ED A0       > ldi
2179   4CAB ED A0       > ldi
2179   4CAD ED A0       > ldi
2179   4CAF ED A0       > ldi
2179   4CB1 ED A0       > ldi
2179   4CB3 ED A0       > ldi
2179   4CB5 ED A0       > ldi
2179   4CB7 ED A0       > ldi
2179   4CB9 ED A0       > ldi
2179   4CBB ED A0       > ldi
2179   4CBD ED A0       > ldi
2179   4CBF ED A0       > ldi
2179   4CC1 ED A0       > ldi
2179   4CC3 ED A0       > ldi
2179   4CC5 ED A0       > ldi
2179   4CC7 ED A0       > ldi
2179   4CC9 ED A0       > ldi
2179   4CCB ED A0       > ldi
2179   4CCD ED A0       > ldi
2179   4CCF ED A0       > ldi
2179   4CD1 ED A0       > ldi
2179   4CD3 ED A0       > ldi
2179   4CD5 ED A0       > ldi
2179   4CD7 ED A0       > ldi
2179   4CD9 ED A0       > ldi
2179   4CDB ED A0       > ldi
2179   4CDD ED A0       > ldi
2179   4CDF ED A0       > ldi
2179   4CE1 ED A0       > ldi
2179   4CE3 ED A0       > ldi
2179   4CE5 ED A0       > ldi
2179   4CE7 ED A0       > ldi
2179   4CE9 ED A0       > ldi
2179   4CEB ED A0       > ldi
2179   4CED ED A0       > ldi
2179   4CEF ED A0       > ldi
2179   4CF1 ED A0       > ldi
2179   4CF3 ED A0       > ldi
2179   4CF5 ED A0       > ldi
2179   4CF7 ED A0       > ldi
2179   4CF9 ED A0       > ldi
2179   4CFB ED A0       > ldi
2179   4CFD ED A0       > ldi
2179   4CFF ED A0       > ldi
2179   4D01 ED A0       > ldi
2179   4D03 ED A0       > ldi
2179   4D05 ED A0       > ldi
2179   4D07 ED A0       > ldi
2179   4D09 ED A0       > ldi
2179   4D0B ED A0       > ldi
2179   4D0D ED A0       > ldi
2179   4D0F ED A0       > ldi
2179   4D11 ED A0       > ldi
2179   4D13 ED A0       > ldi
2179   4D15 ED A0       > ldi
2179   4D17 ED A0       > ldi
2179   4D19 ED A0       > ldi
2179   4D1B ED A0       > ldi
2179   4D1D ED A0       > ldi
2179   4D1F ED A0       > ldi
2179   4D21 ED A0       > ldi
2179   4D23 ED A0       > ldi
2179   4D25 ED A0       > ldi
2179   4D27 ED A0       > ldi
2179   4D29 ED A0       > ldi
2179   4D2B ED A0       > ldi
2179   4D2D ED A0       > ldi
2179   4D2F ED A0       > ldi
2179   4D31 ED A0       > ldi
2179   4D33 ED A0       > ldi
2179   4D35 ED A0       > ldi
2179   4D37 ED A0       > ldi
2179   4D39 ED A0       > ldi
2179   4D3B ED A0       > ldi
2179   4D3D ED A0       > ldi
2179   4D3F ED A0       > ldi
2179   4D41 ED A0       > ldi
2179   4D43 ED A0       > ldi
2179   4D45 ED A0       > ldi
2179   4D47 ED A0       > ldi
2179   4D49 ED A0       > ldi
2179   4D4B ED A0       > ldi
2179   4D4D ED A0       > ldi
2179   4D4F ED A0       > ldi
2179   4D51 ED A0       > ldi
2179   4D53 ED A0       > ldi
2179   4D55 ED A0       > ldi
2179   4D57 ED A0       > ldi
2179   4D59 ED A0       > ldi
2180   4D5B C9          	ret
2181   4D5C             
2182   4D5C             ; ------------------------------------------------
2183   4D5C             ; Jumps to a helper routine, usually in RAM
2184   4D5C             ; Input: HL': Address of the target routine
2185   4D5C             ; ------------------------------------------------
2186   4D5C             RUN_HLPR: 
2187   4D5C D9          	exx
2188   4D5D E9          	jp	(hl)
2189   4D5E             
2190   4D5E             ; ------------------------------------------------
2191   4D5E             ; Setup the arbitrary block size LDIR helper to be used
2192   4D5E             ; Input   : none
2193   4D5E             ; Output  : HL': Address of the block transfer routine to be used 
2194   4D5E             ; Modifies: AF, DE', HL'
2195   4D5E             ; ------------------------------------------------
2196   4D5E             SETLDIRHLPR: 
2197   4D5E D9          	exx
2198   4D5F             	; Check for a Z80 or R800
2199   4D5F AF          	xor	a		; Clear Cy
2200   4D60 3D          	dec	a		; A=#FF
2201   4D61 ED F9       	db	#ED,#F9		; mulub a,a
2202   4D63 38 05       	jr	c,.useLDIR	; Always use LDIR in RAM for the R800
2203   4D65             
2204   4D65 21 5A 49    	ld	hl,LDI512
2205   4D68 D9          	exx
2206   4D69 C9          	ret
2207   4D6A             
2208   4D6A             .useLDIR: 
2209   4D6A D9          	exx
2210   4D6B             	; ***Continues on GTR800LDIR
2211   4D6B             
2212   4D6B             ; ------------------------------------------------
2213   4D6B             ; Obtain the pointer to the R800 data transfer helper routine
2214   4D6B             ; Input   : IY=Pointer to the WorkArea
2215   4D6B             ; Output  : HL=pointer to R800 data transfer helper routine 
2216   4D6B             ; Modifies: DE
2217   4D6B             ;	    - Does an exx at the end
2218   4D6B             ; ------------------------------------------------
2219   4D6B             GTR800LDIR: 
2220   4D6B FD E5       	push	iy
2221   4D6D E1          	pop	hl			; hl=WorkArea
2222   4D6E 11 3A 00    	ld	de,WRKAREA.TRLDIR
2223   4D71 19          	add	hl,de
2224   4D72 D9          	exx
2225   4D73 C9          	ret
2226   4D74             
2227   4D74             
2228   4D74             ; ------------------------------------------------
2229   4D74             ; Debugging routines
2230   4D74             ; ------------------------------------------------
2231   4D74              IFDEF DEBUG
2232   4D74~            PRTCHAR: 
2233   4D74~            	push	ix,iy
2234   4D74~            	ld	ix,CHPUT
2235   4D74~            	ld	iy,(EXPTBL-1)
2236   4D74~            	call	CALSLT
2237   4D74~            	pop	iy,ix
2238   4D74~            	ret
2239   4D74~            PRTDOT: 
2240   4D74~            	push	af
2241   4D74~            	ld	a,'.'
2242   4D74~            	call	PRTCHAR
2243   4D74~            	pop	af
2244   4D74~            	ret
2245   4D74~            PRTDASH: 
2246   4D74~            	push	af
2247   4D74~            	ld	a,'-'
2248   4D74~            	call	PRTCHAR
2249   4D74~            	pop	af
2250   4D74~            	ret
2251   4D74              ENDIF
2252   4D74             
2253   4D74             
2254   4D74             
2255   4D74             ; ==========================================================================
2256   4D74             strTitle: 
2257   4D74             	db	13,"FBLabs SDHC driver v",27,'J'
2257   4D74 0D46424C61627320534448432064726976657220761B4A
2258   4D8B             	BYTE2STR VER_MAIN
2258   4D8B 31          >	db	(value % 10)+$30
2259   4D8C 2E          	db	'.'
2260   4D8D             	BYTE2STR VER_SEC
2260   4D8D 30          >	db	(value % 10)+$30
2261   4D8E 2E          	db	'.'
2262   4D8F             	BYTE2STR VER_REV
2262   4D8F 31          >	db	((value / 10) % 10)+$30
2262   4D90 30          >	db	(value % 10)+$30
2263   4D91 0D 0A 00    	db	13,10,0
2264   4D94             
2265   4D94             ;		 |-------------39 chars----------------|
2266   4D94             strBootpaused: 
2267   4D94             	db	"Paused. Press <i> for the copyright info",13,10,0
2267   4D94 5061757365642E205072657373203C693E20666F722074686520636F70797269
2267   4DB4 67687420696E666F0D0A00
2268   4DBF             
2269   4DBF             strCopyright: 
2270   4DBF             	db	"(c) 2014 Fabio Belavenuto",13,10
2270   4DBF 286329203230313420466162696F2042656C6176656E75746F0D0A
2271   4DDA             	db	"(c) 2017 FRS",13,10
2271   4DDA 2863292032303137204652530D0A
2272   4DE8             	db	"Licenced under CERN OHL v1.1",13,10
2272   4DE8 4C6963656E63656420756E646572204345524E204F484C2076312E310D0A
2273   4E06             	db	"http://ohwr.org/cernohl",13,10
2273   4E06 687474703A2F2F6F6877722E6F72672F6365726E6F686C0D0A
2274   4E1F             	db	"PCB designed by Luciano Sturaro",13,10
2274   4E1F 5043422064657369676E6564206279204C756369616E6F205374757261726F0D
2274   4E3F 0A
2275   4E40             	; will use the CR+LF+EOS bellow 
2276   4E40             strCrLf: 
2277   4E40 0D 0A 00    	db	13,10,0
2278   4E43             strCartao: 
2279   4E43             	db	"- Slot ",0
2279   4E43 2D20536C6F742000
2280   4E4B             strVazio: 
2281   4E4B             	db	"Empty",13,10,0
2281   4E4B 456D7074790D0A00
2282   4E53             strNaoIdentificado: 
2283   4E53             	db	"Unknown!",13,10,0
2283   4E53 556E6B6E6F776E210D0A00
2284   4E5E             ;		 |-------------39 chars----------------|
2285   4E5E             strMapperSS0: 
2286   4E5E             	db	"- Mapper in subslot 0",13,10,0
2286   4E5E 2D204D617070657220696E20737562736C6F7420300D0A00
2287   4E76             strNextorSS0: 
2288   4E76             	db	"- Nextor in subslot 0",13,10,0
2288   4E76 2D204E6578746F7220696E20737562736C6F7420300D0A00
2289   4E8E              IFDEF HASMEGARAM
2290   4E8E~            strMapper: 
2291   4E8E~            	db	"- Slot expander & Mem Mapper enabled",13,10,0
2292   4E8E~            strMegaram: 
2293   4E8E~            	db	"- Slot expander & MegaRAM enabled",13,10,0
2294   4E8E              ELSE
2295   4E8E             strDrvMain: 
2296   4E8E             	db	"- Main driver selected",13,10,0
2296   4E8E 2D204D61696E206472697665722073656C65637465640D0A00
2297   4EA7             strDrvDev: 
2298   4EA7             	db	"- Development driver selected",13,10,0
2298   4EA7 2D20446576656C6F706D656E74206472697665722073656C65637465640D0A00
2299   4EC7              ENDIF
2300   4EC7             strSDV1: 
2301   4EC7             	db	"SDV1, ",0
2301   4EC7 534456312C2000
2302   4ECE             strSDV2: 
2303   4ECE             	db	"SDV2, ",0
2303   4ECE 534456322C2000
2304   4ED5             
2305   4ED5             ;-----------------------------------------------------------------------------
2306   4ED5             ;
2307   4ED5             ; End of the driver code
2308   4ED5             
2309   4ED5             DRV_END: 
2310   4ED5             
2311   4ED5             ;	ds	3ED0h-(DRV_END-DRV_START), $FF
2312   4ED5 FF          	ds	$7B00-$, #FF
2313   7B00             
2314   7B00             
