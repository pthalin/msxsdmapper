0001   0000             ; Projeto MSX SD-Mapper
0002   0000             
0003   0000             ; Copyright (c) 2014 Fabio Belavenuto
0004   0000             ; Copyright (c) 2017, 2018 Fabio R. Schmidlin 
0005   0000             
0006   0000             ; This documentation describes Open Hardware and is licensed under the CERN OHL v. 1.1.
0007   0000             ; You may redistribute and modify this documentation under the terms of the
0008   0000             ; CERN OHL v.1.1. (http://ohwr.org/cernohl). This documentation is distributed
0009   0000             ; WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING OF MERCHANTABILITY,
0010   0000             ; SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.
0011   0000             ; Please see the CERN OHL v.1.1 for applicable conditions
0012   0000             
0013   0000             ; Technical info:
0014   0000             ; 7B00h~7EFFh	: SPI data transfer window (read/write)
0015   0000             ; 7F00h		: Interface status and card select register (read/write)
0016   0000             ;	<read>
0017   0000             ;	If no SD card is selected:
0018   0000             ;	    b7-b2 : always 0
0019   0000             ;	    b1 : SW1 status (Driver selection)
0020   0000             ;	    b0 : SW0 status. 0=RAM disabled, 1=RAM enabled
0021   0000             ;	If any SD card is selected:
0022   0000             ;	    b7-b3 : always 0
0023   0000             ;	    b2 : 1=Write protecton enabled for SD card-slot selected
0024   0000             ;	    b1 : 0=SD card present in the selected card-slot
0025   0000             ;	    b0 : 1=SD Card on slot selected changed since last read
0026   0000             ;	<write>
0027   0000             ;	    b0 : SD card slot-0 chip-select (1=selected)
0028   0000             ;	    b1 : SD card slot-1 chip-select (1=selected)
0029   0000             
0030   0000             ; 7F02h		: 8-bit timer (97.65625 KHz frequency, 10.24uS resolution) (read/write)
0031   0000             ; When a value is written, the timer will decrease it until it reaches zero
0032   0000             ;
0033   0000             ;
0034   0000             ; A Special thanks goes to Elm-chan, for publishing the documentation we used to
0035   0000             ; create this driver. http://elm-chan.org/docs/mmc/mmc_e.html
0036   0000             
0037   0000             	output	"Driver/driver.bin"
0038   0000             
0039   0000             ;-----------------------------------------------------------------------------
0040   0000             ;
0041   0000             ; Driver configuration constants
0042   0000             ;
0043   0000             
0044   0000             ; DEFINE HASMEGARAM	; Driver for an SD-Mapper with MegaRAM
0045   0000             ; DEFINE TURBOINIT	; Disable for the interfaces with the CPLD firmware turbo bug 
0046   0000             ; DEFINE DEBUG1		; Enable level-1 debugging (Only status queries)
0047   0000             ; DEFINE DEBUG2		; Enable level-2 debugging (RW calls)
0048   0000             ; DEFINE DEBUG3		; Enable level-3 debugging (requires level-1). Also logs invalid DEVs and LUN numbers
0049   0000             
0050   0000             
0051   0000             ;Driver type:
0052   0000             ;   0 for drive-based
0053   0000             ;   1 for device-based
0054   0000             
0055   0000             DRV_TYPE	equ	1
0056   0000             
0057   0000             ;Hot-plug devices support (device-based drivers only):
0058   0000             ;   0 for no hot-plug support
0059   0000             ;   1 for hot-plug support
0060   0000             
0061   0000             DRV_HOTPLUG	equ	1
0062   0000             
0063   0000             
0064   0000             ;Driver version
0065   0000             
0066   0000             VER_MAIN	equ	1
0067   0000             VER_SEC		equ	0
0068   0000             VER_REV		equ	11
0069   0000             
0070   0000             ;-----------------------------------------------------------------------------
0071   0000             ; SPI addresses. Check the Technical info above for the bit contents
0072   0000             
0073   0000             SPIDATA		= $7B00
0074   0000             SPICTRL		= $7FF0
0075   0000             SPISTATUS	= $7FF0
0076   0000             TIMERREG	= $7FF1
0077   0000             
0078   0000             ; Interface status flags
0079   0000             IF_RAM		= 0		; 1=Interface RAM is enabled
0080   0000             IF_DRVER	= 1		; RAM mode: 0=MegaRAM, 1=MemoryMapper
0081   0000             IF_M_RAM	= (1 shl IF_RAM)		; bitmask for IF_RAM
0082   0000             IF_M_DRVER	= (1 shl IF_DRVER)		; bitmask for IF_DRVER
0083   0000             
0084   0000             ; card slot status flags
0085   0000             SD_DSKCHG	= 0		; SD card changed since last status check
0086   0000             SD_PRESENT	= 1		; SD card present
0087   0000             SD_WRTPROT	= 2		; SD card is write protected
0088   0000             SD_M_DSKCHG	= (1 shl SD_DSKCHG)		; bitmask for SD_DSKCHG
0089   0000             SD_M_PRESENT	= (1 shl SD_PRESENT)		; bitmask for SD_PRESENT
0090   0000             SD_M_WRTPROT	= (1 shl SD_WRTPROT)		; bitmask for SD_WRTPROT
0091   0000             
0092   0000             ; SPI commands: 
0093   0000             CMD0	= 0  | $40
0094   0000             CMD1	= 1  | $40
0095   0000             CMD8	= 8  | $40
0096   0000             CMD9	= 9  | $40
0097   0000             CMD10	= 10 | $40
0098   0000             CMD12	= 12 | $40
0099   0000             CMD16	= 16 | $40
0100   0000             CMD17	= 17 | $40
0101   0000             CMD18	= 18 | $40
0102   0000             CMD24	= 24 | $40
0103   0000             CMD25	= 25 | $40
0104   0000             CMD55	= 55 | $40
0105   0000             CMD58	= 58 | $40
0106   0000             ACMD23	= 23 | $40
0107   0000             ACMD41	= 41 | $40
0108   0000             
0109   0000             ; SD card errors
0110   0000             R1ERR: 
0111   0000             .IDLE		= 1	; In idle state
0112   0000             .ERARST		= 2	; Erase reset
0113   0000             .ILLGCMD	= 3	; Illegal command
0114   0000             .CRCERR		= 4	; Communication CRC error
0115   0000             .ERAERR		= 5	; Erase sequence error
0116   0000             .ADDRERR	= 6	; Address error
0117   0000             .PARMERR	= 7	; Parameter error
0118   0000             .M_IDLE		= (1 shl .IDLE)
0119   0000             .M_ERARST	= (1 shl .ERARST)
0120   0000             .M_ILLGCMD	= (1 shl .ILLGCMD)
0121   0000             .M_CRCERR	= (1 shl .CRCERR)
0122   0000             .M_ERAERR	= (1 shl .ERAERR)
0123   0000             .M_ADDRERR	= (1 shl .ADDRERR)
0124   0000             .M_PARMERR	= (1 shl .PARMERR)
0125   0000             
0126   0000             ; Work area stuctures 
0127   0000              STRUCT WRKAREA
0128   0000~            TRLDIR		dw	; Pointer to the R800 data transfer helper
0129   0000~            NUMSD		db 	; Currently selected card: 1 or 2 
0130   0000~            CARDFLAGS	db 	; Flags that indicate card-change or card error 
0131   0000~            			; b0: card1 error
0132   0000~            			; b1: card2 error
0133   0000~            			; b2: card1 LUN changed flag
0134   0000~            			; b3: card2 LUN changed flag
0135   0000~            			; b4: card1 DEV changed flag
0136   0000~            			; b5: card2 DEV changed flag
0137   0000~            			; b6: card1 version
0138   0000~            			; b7: card2 version
0139   0000~            NUMBLOCKS	db 	; Number of blocks in multi-block operations 
0140   0000~            TEMP		ds 3	; Buffer for temporary data 
0141   0000              ENDS
0142   0000             
0143   0000             ; WRKAREA.CARDFLAGS shift amount and direction
0144   0000             WCF_N_ERROR	= 0	; SD card error
0145   0000             WCF_L_LUNCHG	= 2	; LUN has changed software flag
0146   0000             WCF_L_DEVCHG	= 4	; Device has changed software flag
0147   0000             WCF_R_CRDVER	= 2	; Current card version
0148   0000             
0149   0000             
0150   0000             
0151   0000              STRUCT CID
0152   0000~            MID		db	; Manufacturer ID
0153   0000~            OID		ds 2	; OEM ID
0154   0000~            PNM		ds 5	; Product Name
0155   0000~            PRV		db
0156   0000~            PSN		ds 4	; Product Serial Number
0157   0000~            RSVMDT		dw	; Reserved, Manufacturing date
0158   0000~            CRC		db	; b7=1, b6~b0 = CRC7 checksum
0159   0000              ENDS
0160   0000             
0161   0000             
0162   0000             
0163   0000             ;-----------------------------------------------------------------------------
0164   0000             ;
0165   0000             ; Standard BIOS and work area entries
0166   0000             CALSLT	= $001C		; Call routine in any slot
0167   0000             CALLF	= $0030		; Call routine in any slot
0168   0000             INITXT	= $006C		; Inicializa SCREEN0
0169   0000             CHSNS	= $009C		; Sense keyboard buffer for character
0170   0000             CHGET	= $009F		; Get character from keyboard buffer
0171   0000             CHPUT	= $00A2		; A=char
0172   0000             CLS	= $00C3		; Chamar com A=0
0173   0000             ERAFNK	= $00CC		; Erase function key display
0174   0000             SNSMAT	= $0141		; Read row of keyboard matrix
0175   0000             KILBUF	= $0156		; Clear keyboard buffer
0176   0000             EXTROM	= $015F
0177   0000             CHGCPU	= $0180		; Change the turbo mode
0178   0000             GETCPU	= $0183		; Get the turbo mode
0179   0000             
0180   0000             ; subROM functions
0181   0000             SDFSCR	= $0185
0182   0000             REDCLK	= $01F5
0183   0000             
0184   0000             
0185   0000             ; System variables
0186   0000             MSXVER	= $002D
0187   0000             LINL40	= $F3AE		; Width
0188   0000             LINLEN	= $F3B0
0189   0000             TEMP3	= $F69D
0190   0000             INTFLG	= $FC9B
0191   0000             SCRMOD	= $FCAF
0192   0000             EXPTBL	 =$FCC1
0193   0000             
0194   0000             
0195   0000             
0196   0000             ;-----------------------------------------------------------------------------
0197   0000             
0198   0000             
0199   0000             	org		$4000
0200   4000             
0201   4000 FF          	ds		256, $FF		; 256 dummy bytes
0202   4100             
0203   4100             DRV_START: 
0204   4100             
0205   4100             ;-----------------------------------------------------------------------------
0206   4100             ;
0207   4100             ; Miscellaneous constants
0208   4100             ;
0209   4100             
0210   4100             ;This is a 2 byte buffer to store the address of code to be executed.
0211   4100             ;It is used by some of the kernel page 0 routines.
0212   4100             
0213   4100             CODE_ADD: 	equ	0F84Ch
0214   4100             
0215   4100             
0216   4100             ;-----------------------------------------------------------------------------
0217   4100             ;
0218   4100             ; Error codes for DEV_RW
0219   4100             ;
0220   4100             
0221   4100             ENCOMP	equ	0FFh
0222   4100             EWRERR	equ	0FEh
0223   4100             EDISK	equ	0FDh
0224   4100             ENRDY	equ	0FCh
0225   4100             EDATA	equ	0FAh
0226   4100             ERNF	equ	0F9h
0227   4100             EWPROT	equ	0F8h
0228   4100             EUFORM	equ	0F7h
0229   4100             ESEEK	equ	0F3h
0230   4100             EIFORM	equ	0F0h
0231   4100             EIDEVL	equ	0B5h
0232   4100             EIPARM	equ	08Bh
0233   4100             
0234   4100             ;-----------------------------------------------------------------------------
0235   4100             ;
0236   4100             ; Macros
0237   4100             ;
0238   4100             
0239   4100              MACRO BYTE2STR value
0240   4100~            
0241   4100~             IF value > 99
0242   4100~            	db	((value / 100) % 10)+$30
0243   4100~             ENDIF
0244   4100~             IF value > 9
0245   4100~            	db	((value / 10) % 10)+$30
0246   4100~             ENDIF
0247   4100~            	db	(value % 10)+$30
0248   4100~            
0249   4100              ENDM
0250   4100             
0251   4100              IFDEF DEBUG1
0252   4100~             MACRO PRTSTR	string
0253   4100~            	call	PRTSTRCALL
0254   4100~            	ABYTEZ 0 string
0255   4100~             ENDM
0256   4100              ENDIF
0257   4100             
0258   4100             ;-----------------------------------------------------------------------------
0259   4100             ;
0260   4100             ; Routines and information available on kernel page 0
0261   4100             ;
0262   4100             
0263   4100             ;* Get in A the current slot for page 1. Corrupts F.
0264   4100             ;  Must be called by using CALBNK to bank 0:
0265   4100             ;    xor a
0266   4100             ;    ld ix,GSLOT1
0267   4100             ;    call CALBNK
0268   4100             
0269   4100             GSLOT1	equ	402Dh
0270   4100             
0271   4100             
0272   4100             ;* This routine reads a byte from another bank.
0273   4100             ;  Must be called by using CALBNK to the desired bank,
0274   4100             ;  passing the address to be read in HL:
0275   4100             ;    ld a,<bank number>
0276   4100             ;    ld hl,<byte address>
0277   4100             ;    ld ix,RDBANK
0278   4100             ;    call CALBNK
0279   4100             
0280   4100             RDBANK	equ	403Ch
0281   4100             
0282   4100             
0283   4100             ;* This routine temporarily switches kernel main bank
0284   4100             ;  (usually bank 0, but will be 3 when running in MSX-DOS 1 mode),
0285   4100             ;  then invokes the routine whose address is at (CODE_ADD).
0286   4100             ;  It is necessary to use this routine to invoke CALBAS
0287   4100             ;  (so that kernel bank is correct in case of BASIC error)
0288   4100             ;  and to invoke DOS functions via F37Dh hook.
0289   4100             ;
0290   4100             ;  Input:  Address of code to invoke in (CODE_ADD).
0291   4100             ;          AF, BC, DE, HL, IX, IY passed to the called routine.
0292   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0293   4100             
0294   4100             CALLB0	equ	403Fh
0295   4100             
0296   4100             
0297   4100             ;* Call a routine in another bank.
0298   4100             ;  Must be used if the driver spawns across more than one bank.
0299   4100             ;
0300   4100             ;  Input:  A = bank number
0301   4100             ;          IX = routine address
0302   4100             ;          AF' = AF for the routine
0303   4100             ;          HL' = Ix for the routine
0304   4100             ;          BC, DE, HL, IY = input for the routine
0305   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0306   4100             
0307   4100             CALBNK	equ	4042h
0308   4100             
0309   4100             
0310   4100             ;* Get in IX the address of the SLTWRK entry for the slot passed in A,
0311   4100             ;  which will in turn contain a pointer to the allocated page 3
0312   4100             ;  work area for that slot (0 if no work area was allocated).
0313   4100             ;  If A=0, then it uses the slot currently switched in page 1.
0314   4100             ;  Returns A=current slot for page 1, if A=0 was passed.
0315   4100             ;  Corrupts F.
0316   4100             ;  Must be called by using CALBNK to bank 0:
0317   4100             ;    ld a,<slot number> (xor a for current page 1 slot)
0318   4100             ;    ex af,af'
0319   4100             ;    xor a
0320   4100             ;    ld ix,GWORK
0321   4100             ;    call CALBNK
0322   4100             
0323   4100             GWORK	equ	4045h
0324   4100             
0325   4100             
0326   4100             ;* This address contains one byte that tells how many banks
0327   4100             ;  form the Nextor kernel (or alternatively, the first bank
0328   4100             ;  number of the driver).
0329   4100             
0330   4100             K_SIZE	equ	40FEh
0331   4100             
0332   4100             
0333   4100             ;* This address contains one byte with the current bank number.
0334   4100             
0335   4100             CUR_BANK	equ	40FFh
0336   4100             
0337   4100             
0338   4100             ;-----------------------------------------------------------------------------
0339   4100             ;
0340   4100             ; Built-in format choice strings
0341   4100             ;
0342   4100             
0343   4100             NULL_MSG  equ     781Fh	;Null string (disk can't be formatted)
0344   4100             SING_DBL  equ     7820h ;"1-Single side / 2-Double side"
0345   4100             
0346   4100             
0347   4100             ;-----------------------------------------------------------------------------
0348   4100             ;
0349   4100             ; Driver signature
0350   4100             ;
0351   4100             	db	"NEXTOR_DRIVER",0
0351   4100 4E4558544F525F44524956455200
0352   410E             
0353   410E             
0354   410E             ;-----------------------------------------------------------------------------
0355   410E             ;
0356   410E             ; Driver flags:
0357   410E             ;    bit 0: 0 for drive-based, 1 for device-based
0358   410E             ;    bit 1: 1 for hot-plug devices supported (device-based drivers only)
0359   410E             ;    bit 2: 1 if the driver implements the DRV_CONFIG routine
0360   410E             
0361   410E 07          	db 1+2*DRV_HOTPLUG+4
0362   410F             
0363   410F             ;-----------------------------------------------------------------------------
0364   410F             ;
0365   410F             ; Reserved byte
0366   410F             ;
0367   410F 00          	db	0
0368   4110             
0369   4110             ;-----------------------------------------------------------------------------
0370   4110             ;
0371   4110             ; Driver name
0372   4110             ;
0373   4110             ; It will be shown in the FDISK interface selection menu
0374   4110             
0375   4110             DRV_NAME: 
0376   4110             	db	"FBLabs SDXC"
0376   4110 46424C6162732053445843
0377   411B 20          	ds	32-($-DRV_NAME)," "
0378   4130             
0379   4130             
0380   4130             ;-----------------------------------------------------------------------------
0381   4130             ;
0382   4130             ; Jump table for the driver public routines
0383   4130             ;
0384   4130             
0385   4130             	; These routines are mandatory for all drivers
0386   4130                     ; (but probably you need to implement only DRV_INIT)
0387   4130             
0388   4130 C3 6C 41    	jp	DRV_TIMI
0389   4133 C3 6F 42    	jp	DRV_VERSION
0390   4136 C3 6D 41    	jp	DRV_INIT
0391   4139 C3 76 42    	jp	DRV_BASSTAT
0392   413C C3 78 42    	jp	DRV_BASDEV
0393   413F C3 7A 42    	jp	DRV_EXTBIO
0394   4142 C3 7B 42    	jp	DRV_DIRECT0
0395   4145 C3 7B 42    	jp	DRV_DIRECT1
0396   4148 C3 7B 42    	jp	DRV_DIRECT2
0397   414B C3 7B 42    	jp	DRV_DIRECT3
0398   414E C3 7B 42    	jp	DRV_DIRECT4
0399   4151 C3 7C 42    	jp	DRV_CONFIG
0400   4154             
0401   4154 00          	ds	12
0402   4160             
0403   4160             	; These routines are mandatory for device-based drivers
0404   4160             
0405   4160 C3 9F 42    	jp	DEV_RW
0406   4163 C3 18 43    	jp	DEV_INFO
0407   4166 C3 E9 43    	jp	DEV_STATUS
0408   4169 C3 59 44    	jp	LUN_INFO
0409   416C             
0410   416C             
0411   416C             ;=====
0412   416C             ;=====  END of data that must be at fixed addresses
0413   416C             ;=====
0414   416C             
0415   416C             
0416   416C             ;-----------------------------------------------------------------------------
0417   416C             ;
0418   416C             ; Timer interrupt routine, it will be called on each timer interrupt
0419   416C             ; (at 50 or 60Hz), but only if DRV_INIT returns Cy=1 on its first execution.
0420   416C             
0421   416C             DRV_TIMI: 
0422   416C C9          	ret
0423   416D             
0424   416D             ;-----------------------------------------------------------------------------
0425   416D             ;
0426   416D             ; Driver initialization routine, it is called twice:
0427   416D             ;
0428   416D             ; 1) First execution, for information gathering.
0429   416D             ;    Input:
0430   416D             ;      A = 0
0431   416D             ;      B = number of available drives
0432   416D             ;      HL = maximum size of allocatable work area in page 3
0433   416D             ;    Output:
0434   416D             ;      A = number of required drives (for drive-based driver only)
0435   416D             ;      HL = size of required work area in page 3
0436   416D             ;      Cy = 1 if DRV_TIMI must be hooked to the timer interrupt, 0 otherwise
0437   416D             ;
0438   416D             ; 2) Second execution, for work area and hardware initialization.
0439   416D             ;    Input:
0440   416D             ;      A = 1
0441   416D             ;      B = number of allocated drives for this controller
0442   416D             ;
0443   416D             ;    The work area address can be obtained by using GWORK.
0444   416D             ;
0445   416D             ;    If first execution requests more work area than available,
0446   416D             ;    second execution will not be done and DRV_TIMI will not be hooked
0447   416D             ;    to the timer interrupt.
0448   416D             ;
0449   416D             ;    If first execution requests more drives than available,
0450   416D             ;    as many drives as possible will be allocated, and the initialization
0451   416D             ;    procedure will continue the normal way
0452   416D             ;    (for drive-based drivers only. Device-based drivers always
0453   416D             ;     get two allocated drives.)
0454   416D             
0455   416D             DRV_INIT: 
0456   416D B7          	or	a		; Is this the 1st call? 
0457   416E 20 0F       	jr	nz,.call2	; No, skip
0458   4170             ; 1st call:
0459   4170 3A 2D 00    	ld	a,(MSXVER)
0460   4173 FE 03       	cp	3		; MSX Turbo-R?
0461   4175 3F          	ccf
0462   4176 21 00 00    	ld	hl,0		; No extra space required
0463   4179 D0          	ret	nc		; No, return with Cy off
0464   417A 21 07 00    	ld	hl,R800DATHLP.end-R800DATHLP	; size of the extra work area needed for the TR
0465   417D B7          	or	a		; Clear Cy
0466   417E C9          	ret
0467   417F             
0468   417F             
0469   417F             .call2: 
0470   417F             ; 2nd call: 
0471   417F              IFDEF TURBOINIT
0472   417F~            	ld	a,(CHGCPU)
0473   417F~            	cp	#C3		; IS CHGCPU present?
0474   417F~            	jr	nz,.call2ini
0475   417F~            	call	GETCPU
0476   417F~            	push	af		; Save the current CPU
0477   417F~            	ld	a,#82
0478   417F~            	call	CHGCPU		; Enable the turbo
0479   417F~            .call2ini: 
0480   417F              ENDIF ; TURBOINIT
0481   417F CD 78 4A    	call	MYSETSCR		; Set the screen mode
0482   4182 CD 35 45    	call	getWorkArea		; IX=Work area pointer
0483   4185             
0484   4185             ;	; Clear the rest of my SLTWRK area 
0485   4185 DD E5       	push	ix
0486   4187 E1          	pop	hl
0487   4188 23          	inc	hl			; Skip the pointer to the additional work Area
0488   4189 23          	inc	hl
0489   418A AF          	xor	a
0490   418B 06 06       	ld	b,6
0491   418D             .loopclr: 
0492   418D 77          	ld	(hl),a
0493   418E 23          	inc	hl
0494   418F 10 FC       	djnz	.loopclr
0495   4191             	
0496   4191 11 6A 4F    	ld	de,strTitle		; prints the title 
0497   4194 CD 55 48    	call	printString
0498   4197             
0499   4197             .sdhcinit: 	; FBLabs SDXC Interface initialization
0500   4197 CD 50 42    	call	.printmode		; Print the switches configuration
0501   419A 3E 3C       	ld	a,$3C			; Initialize the card flags
0502   419C DD 77 03    	ld	(ix+WRKAREA.CARDFLAGS), a
0503   419F             
0504   419F 3E 01       	ld	a, 1			; detectar cartao 1
0505   41A1 CD C6 41    	call	.detecta
0506   41A4 3E 02       	ld	a, 2			; detectar cartao 2
0507   41A6 CD C6 41    	call	.detecta
0508   41A9 01 00 00    	ld	bc, 0
0509   41AC 1E 05       	ld	e, 5
0510   41AE             
0511   41AE CD 37 4B    	call	INSTR800HLP		; Install R800 data copy on workarea
0512   41B1             
0513   41B1 CD BC 4A    	call	INICHKSTOP		; Check if the STOP key was pressed
0514   41B4             
0515   41B4 11 34 50    	ld	de, strCrLf
0516   41B7              
0517   41B7 CD 55 48    	call	printString
0518   41BA             .drv_init_end: 
0519   41BA             	; ***Workaround for a bug in Nextor that causes it to freeze if
0520   41BA             	; CTRL+STOP was pressed on boot
0521   41BA 3A 9B FC    	ld	a,(INTFLG)
0522   41BD FE 03       	cp	3		; Is CTRL+STOP still signaled?
0523   41BF 20 04       	jr	nz,.restCPU	; no, skip
0524   41C1 AF          	xor	a
0525   41C2 32 9B FC    	ld	(INTFLG),a	; Clear CTRL+STOP otherwise Nextor will freeze
0526   41C5             
0527   41C5             .restCPU: 	; Restore the CPU if necessary
0528   41C5              IFDEF TURBOINIT
0529   41C5~            	ld	a,(CHGCPU)
0530   41C5~            	cp	#C3		; IS CHGCPU present?
0531   41C5~            	ret	nz
0532   41C5~            	pop	af
0533   41C5~            	or	#80
0534   41C5~            	jp	CHGCPU
0535   41C5              ELSE
0536   41C5 C9          	ret
0537   41C6              ENDIF ; TURBOINIT
0538   41C6             
0539   41C6             
0540   41C6             ;------- DRV_INIT aux routines ----------
0541   41C6             
0542   41C6             .detecta: 
0543   41C6 DD 77 02    	ld	(ix+WRKAREA.NUMSD), a	; Save the requested card slot
0544   41C9 11 36 50    	ld	de, strCartao
0545   41CC CD 55 48    	call	printString
0546   41CF DD 4E 02    	ld	c, (ix+WRKAREA.NUMSD)
0547   41D2 79          	ld	a,c
0548   41D3 C6 30       	add	'0'
0549   41D5 CD A2 00    	call	CHPUT
0550   41D8 3E 3A       	ld	a, ':'
0551   41DA CD A2 00    	call	CHPUT
0552   41DD 3E 20       	ld	a, ' '
0553   41DF CD A2 00    	call	CHPUT
0554   41E2 79          	ld	a,c			; Get card slot#
0555   41E3             ;	cpl				; invert bits
0556   41E3             ;	and	3
0557   41E3 32 F0 7F    	ld	(SPICTRL), a		; Select card slot
0558   41E6 3A F0 7F    	ld	a, (SPISTATUS)		; get card slot status
0559   41E9 CD 48 46    	call	disableSDs
0560   41EC E6 02       	and	SD_M_PRESENT		; Is there an card present?
0561   41EE 28 06       	jr	z,.naoVazio		; Yes, skip
0562   41F0 11 3D 50    	ld	de, strVazio		; Empty SD card slot message
0563   41F3 C3 55 48    	jp	printString
0564   41F6             ;	jp	.marcaErro
0565   41F6             .naoVazio: 
0566   41F6 CD 59 45    	call	detectaCartao		; tem cartao no slot, inicializar e detectar
0567   41F9 30 06       	jr	nc,.detectou
0568   41FB 11 44 50    	ld	de, strNaoDetectado
0569   41FE C3 55 48    	jp	printString
0570   4201             ;.marcaErro:
0571   4201             ;	jp	marcaErroCartao		; slot vazio ou erro de deteccao, marcar nas flags
0572   4201             .detectou: 
0573   4201 CD 54 46    	call	getCardVer
0574   4204 11 AB 50    	ld	de, strSDV1	; e imprimir
0575   4207             ;	or	a
0576   4207 28 03       	jr	z,.pula1
0577   4209 11 B2 50    	ld	de, strSDV2
0578   420C             .pula1: 
0579   420C CD 55 48    	call	printString
0580   420F             
0581   420F 11 00 4A    	ld	de,CMD10*256+CID.MID	; Point to the Manufacturer ID
0582   4212 CD 00 46    	call	setCxDrd
0583   4215 21 00 7B    	ld	hl,SPIDATA
0584   4218 4E          	ld	c,(hl)		; c=Manufacturer ID
0585   4219             
0586   4219 06 11       	ld	b,18-1		; 16 data bytes and 2 response bytes -1 
0587   421B CD 15 46    	call	flushCxD	; Flush the rest of the CID data
0588   421E             
0589   421E 79          	ld	a,c		; pegar byte do fabricante
0590   421F             
0591   421F 21 9D F6    	ld	hl,TEMP3
0592   4222 CD 61 48    	call	HexToAscii
0593   4225 3A 9D F6    	ld	a,(TEMP3)
0594   4228 CD A2 00    	call	CHPUT
0595   422B 3A 9E F6    	ld	a,(TEMP3+1)
0596   422E CD A2 00    	call	CHPUT
0597   4231 3E 68       	ld	a,'h'
0598   4233 CD A2 00    	call	CHPUT
0599   4236 3E 29       	ld	a,')'
0600   4238 CD A2 00    	call	CHPUT
0601   423B 3E 20       	ld	a,' '
0602   423D CD A2 00    	call	CHPUT
0603   4240 79          	ld	a,c		; pegar byte do fabricante
0604   4241 CD 75 48    	call	getMakerName	; de = Maker string 
0605   4244 CD 55 48    	call	printString	; e imprimir
0606   4247 11 34 50    	ld	de,strCrLf
0607   424A CD 55 48    	call	printString
0608   424D C3 48 46    	jp	disableSDs
0609   4250             
0610   4250             
0611   4250             .printmode: 		; Print the two switches configuration
0612   4250 AF          	xor	a			; 0=Interface status
0613   4251 32 F0 7F    	ld	(SPICTRL),a
0614   4254 3A F0 7F    	ld	a, (SPISTATUS)		; Check if the mapper/megaRAM is active
0615   4257 E6 01       	and	IF_M_RAM		; Is the RAM enabled?
0616   4259 11 4D 50    	ld	de,strMr_mp_desativada
0617   425C              IFDEF HASMEGARAM
0618   425C~            	jr	z,.print		; No, skip
0619   425C~            	ld	a, (SPISTATUS)		; ativa, testar se eh mapper ou megaram
0620   425C~            	and	IF_M_DRVER
0621   425C~            	ld	de,strMapper
0622   425C~            	jr	nz,.print
0623   425C~            	ld	de, strMegaram		; Megaram ativa
0624   425C~            .print: 
0625   425C~            	jp	printString
0626   425C              ELSE
0627   425C CC 55 48    	call	z,printString		; Yes, print
0628   425F 3A F0 7F    	ld	a, (SPISTATUS)		; Get the MainBIOS/DevBIOS switch status
0629   4262 E6 02       	and	IF_M_DRVER
0630   4264 11 74 50    	ld	de,strDrvMain
0631   4267 20 03       	jr	nz,.printdrv
0632   4269 11 8C 50    	ld	de, strDrvDev
0633   426C             .printdrv: 
0634   426C C3 55 48    	jp	printString
0635   426F              ENDIF
0636   426F             
0637   426F             
0638   426F             
0639   426F             
0640   426F             
0641   426F             ;-----------------------------------------------------------------------------
0642   426F             ;
0643   426F             ; Obtain driver version
0644   426F             ;
0645   426F             ; Input:  -
0646   426F             ; Output: A = Main version number
0647   426F             ;         B = Secondary version number
0648   426F             ;         C = Revision number
0649   426F             
0650   426F             DRV_VERSION: 
0651   426F 3E 01       	ld	a, VER_MAIN
0652   4271 06 00       	ld	b, VER_SEC
0653   4273 0E 0B       	ld	c, VER_REV
0654   4275 C9          	ret
0655   4276             
0656   4276             
0657   4276             ;-----------------------------------------------------------------------------
0658   4276             ;
0659   4276             ; BASIC expanded statement ("CALL") handler.
0660   4276             ; Works the expected way, except that if invoking CALBAS is needed,
0661   4276             ; it must be done via the CALLB0 routine in kernel page 0.
0662   4276             
0663   4276             DRV_BASSTAT: 
0664   4276 37          	scf
0665   4277 C9          	ret
0666   4278             
0667   4278             
0668   4278             ;-----------------------------------------------------------------------------
0669   4278             ;
0670   4278             ; BASIC expanded device handler.
0671   4278             ; Works the expected way, except that if invoking CALBAS is needed,
0672   4278             ; it must be done via the CALLB0 routine in kernel page 0.
0673   4278             
0674   4278             DRV_BASDEV: 
0675   4278 37          	scf
0676   4279 C9          	ret
0677   427A             
0678   427A             ;-----------------------------------------------------------------------------
0679   427A             ;
0680   427A             ; Extended BIOS hook.
0681   427A             ; Works the expected way, except that it must return
0682   427A             ; D'=1 if the old hook must be called, D'=0 otherwise.
0683   427A             ; It is entered with D'=1.
0684   427A             
0685   427A             DRV_EXTBIO: 
0686   427A C9          	ret
0687   427B             
0688   427B             ;-----------------------------------------------------------------------------
0689   427B             ;
0690   427B             ; Direct calls entry points.
0691   427B             ; Calls to addresses 7850h, 7853h, 7856h, 7859h and 785Ch
0692   427B             ; in kernel banks 0 and 3 will be redirected
0693   427B             ; to DIRECT0/1/2/3/4 respectively.
0694   427B             ; Receives all register data from the caller except IX and AF'.
0695   427B             
0696   427B             DRV_DIRECT0: 
0697   427B             DRV_DIRECT1: 
0698   427B             DRV_DIRECT2: 
0699   427B             DRV_DIRECT3: 
0700   427B             DRV_DIRECT4: 
0701   427B C9          	ret
0702   427C             
0703   427C             
0704   427C             ;-----------------------------------------------------------------------------
0705   427C             ;
0706   427C             ; Get driver configuration 
0707   427C             ; (bit 2 of driver flags must be set if this routine is implemented)
0708   427C             ;
0709   427C             ; Input:
0710   427C             ;   A = Configuration index
0711   427C             ;   BC, DE, HL = Depends on the configuration
0712   427C             ;
0713   427C             ; Output:
0714   427C             ;   A = 0: Ok
0715   427C             ;       1: Configuration not available for the supplied index
0716   427C             ;   BC, DE, HL = Depends on the configuration
0717   427C             ;
0718   427C             ; * Get number of drives at boot time (for device-based drivers only):
0719   427C             ;   Input:
0720   427C             ;     A = 1
0721   427C             ;     B = 0 for DOS 2 mode, 1 for DOS 1 mode
0722   427C             ;   Output:
0723   427C             ;     B = number of drives
0724   427C             ;
0725   427C             ; * Get default configuration for drive
0726   427C             ;   Input:
0727   427C             ;     A = 2
0728   427C             ;     B = 0 for DOS 2 mode, 1 for DOS 1 mode
0729   427C             ;     C = Relative drive number at boot time (0~n)
0730   427C             ;   Output:
0731   427C             ;     B = Device index (1~7)
0732   427C             ;     C = LUN index
0733   427C             
0734   427C             DRV_CONFIG: 
0735   427C B7          	or	a
0736   427D 28 1D       	jr	z,.notavail
0737   427F FE 01       	cp	1
0738   4281 20 0F       	jr	nz,.tryC2
0739   4283             
0740   4283             	; Config-1: Get number of drives at boot time
0741   4283             
0742   4283 3E 06       	ld	a,6
0743   4285 CD 41 01    	call	SNSMAT
0744   4288 E6 02       	and	2		; Is CTRL being pressed?
0745   428A 06 01       	ld	b,1
0746   428C 3E 00       	ld	a,0
0747   428E C8          	ret	z		; Yes, ask for only 1 drive
0748   428F 06 02       	ld	b,2
0749   4291 C9          	ret
0750   4292             
0751   4292 FE 02       .tryC2:  cp	2
0752   4294 20 06       	jr	nz,.notavail
0753   4296             
0754   4296             	; Config-2: Get default configuration for drive
0755   4296 41          	ld	b,c
0756   4297 04          	inc	b
0757   4298 0E 01       	ld	c,1
0758   429A AF          	xor	a
0759   429B C9          	ret
0760   429C             
0761   429C             
0762   429C             .notavail: 
0763   429C 3E 01       	ld	a,1
0764   429E C9          	ret
0765   429F             
0766   429F             
0767   429F             ;=====
0768   429F             ;=====  BEGIN of DEVICE-BASED specific routines
0769   429F             ;=====
0770   429F             
0771   429F             ;-----------------------------------------------------------------------------
0772   429F             ;
0773   429F             ; Read or write logical sectors from/to a logical unit
0774   429F             ;
0775   429F             ;Input:    Cy=0 to read, 1 to write
0776   429F             ;          A = Device number, 1 to 7
0777   429F             ;          B = Number of sectors to read or write
0778   429F             ;          C = Logical unit number, 1 to 7
0779   429F             ;          HL = Source or destination memory address for the transfer
0780   429F             ;          DE = Address where the 4 byte sector number is stored.
0781   429F             ;Output:   A = Error code (the same codes of MSX-DOS are used):
0782   429F             ;              0: Ok
0783   429F             ;              .IDEVL: Invalid device or LUN
0784   429F             ;              .NRDY: Not ready
0785   429F             ;              .DISK: General unknown disk error
0786   429F             ;              .DATA: CRC error when reading
0787   429F             ;              .RNF: Sector not found
0788   429F             ;              .UFORM: Unformatted disk
0789   429F             ;              .WPROT: Write protected media, or read-only logical unit
0790   429F             ;              .WRERR: Write error
0791   429F             ;              .NCOMP: Incompatible disk.
0792   429F             ;              .SEEK: Seek error.
0793   429F             ;          B = Number of sectors actually read (in case of error only)
0794   429F             
0795   429F             DEV_RW: 
0796   429F F5          	push	af
0797   42A0 FE 03       	cp	3		; somente 2 dispositivos
0798   42A2 30 1D       	jr	nc,.errorIDEVL
0799   42A4 0D          	dec	c		; somente 1 logical unit
0800   42A5 20 1A       	jr	nz,.errorIDEVL
0801   42A7 CD 35 45    	call	getWorkArea	; IX=Work area pointer
0802   42AA             
0803   42AA DD 70 04    	ld	(ix+WRKAREA.NUMBLOCKS),b	; save the number of blocks to transfer 
0804   42AD D5 E5       	push	de,hl
0805   42AF CD 12 48    	call	slctNchkCard	; Select and check the card
0806   42B2 4B          	ld	c,e		; c=error code
0807   42B3 E1 D1       	pop	hl,de
0808   42B5 38 0C       	jr	c,.popQuitIniError
0809   42B7 20 0F       	jr	nz,.cardOk
0810   42B9             
0811   42B9             .errorNRDY: 
0812   42B9 0E FC       	ld	c,ENRDY		; Not ready
0813   42BB 18 06       	jr	.popQuitIniError
0814   42BD             .errorDISK: 
0815   42BD 0E FD       	ld	c,EDISK		; Unknown disk error
0816   42BF 18 02       	jr	.popQuitIniError
0817   42C1             .errorIDEVL: 
0818   42C1 0E B5       	ld	c,EIDEVL	; error: Invalid device or LUN 
0819   42C3             .popQuitIniError: 		; Pop and quit on initialization error
0820   42C3 F1          	pop	af		; flush the stack
0821   42C4 79          	ld	a,c		; A=error code
0822   42C5 06 00       	ld	b,0		; 0 sectors r/w
0823   42C7 C9          	ret
0824   42C8             
0825   42C8             .cardOk: 
0826   42C8 CD 56 4F    	call	SETLDIRHLPR	; hl'=Pointer to LDIR helper in RAM
0827   42CB F1          	pop	af		; a=Device number, f=read/write flag 
0828   42CC 38 1E       	jr	c,DEV_W		; Skip if it's a write operation 
0829   42CE             
0830   42CE             DEV_R: 
0831   42CE              IFDEF DEBUG1
0832   42CE~            	PRTSTR	"R11"
0833   42CE              ENDIF
0834   42CE D5          	push	de
0835   42CF FD E1       	pop	iy
0836   42D1 FD 5E 00    	ld	e,(iy+0)	; BC:DE=sector number
0837   42D4 FD 56 01    	ld	d,(iy+1)
0838   42D7 FD 4E 02    	ld	c,(iy+2)
0839   42DA FD 46 03    	ld	b,(iy+3)
0840   42DD CD C7 47    	call	LerBloco	; Low-level sector read
0841   42E0              IFDEF DEBUG1
0842   42E0~            	jp	nc,PRTSEMIC
0843   42E0~            	ld	a,'e'
0844   42E0~            	call	PRTCHAR
0845   42E0              ELSE
0846   42E0 D0          	ret	nc		; Return with A=0 if no error occurred
0847   42E1              ENDIF
0848   42E1 CD 42 45    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0849   42E4 DD 7E 04    	ld	a,(ix+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0850   42E7 FD 94       	sub	iyh		; subtract the number of remaining blocks
0851   42E9 47          	ld	b,a		; b=number of blocks written
0852   42EA 7B          	ld	a,e		; Get the error code
0853   42EB C9          	ret
0854   42EC             
0855   42EC             DEV_W: 
0856   42EC              IFDEF DEBUG1
0857   42EC~            	ld	a,'W'
0858   42EC~            	call	PRTCHAR
0859   42EC              ENDIF
0860   42EC             	; Test if the card is write protected
0861   42EC 3A F0 7F    	ld	a,(SPISTATUS)	; Get this card slot status
0862   42EF E6 04       	and	SD_M_WRTPROT	; Is the card write protected?
0863   42F1 28 07       	jr	z,.ok
0864   42F3              IFDEF DEBUG1
0865   42F3~            	PRTSTR	"!p"
0866   42F3              ENDIF
0867   42F3 3E F8       	ld	a, EWPROT	; disco protegido
0868   42F5 06 00       	ld	b,0		; 0 blocks were written
0869   42F7 C3 48 46    	jp	disableSDs
0870   42FA             .ok: 
0871   42FA              IFDEF DEBUG1
0872   42FA~            	PRTSTR	"11"
0873   42FA              ENDIF
0874   42FA D5          	push	de
0875   42FB FD E1       	pop	iy
0876   42FD FD 5E 00    	ld	e,(iy+0)	; BC:DE=sector number
0877   4300 FD 56 01    	ld	d,(iy+1)
0878   4303 FD 4E 02    	ld	c,(iy+2)
0879   4306 FD 46 03    	ld	b,(iy+3)
0880   4309 CD 0F 47    	call	GravarBloco	; Low-level sector save
0881   430C              IFDEF DEBUG1
0882   430C~            	jp	nc,PRTSEMIC
0883   430C~            	ld	a,'e'
0884   430C~            	call	PRTCHAR
0885   430C              ELSE
0886   430C D0          	ret	nc		; Return with A=0 if no error occurred
0887   430D              ENDIF
0888   430D CD 42 45    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0889   4310 DD 7E 04    	ld	a,(ix+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0890   4313 FD 94       	sub	iyh		; subtract the number of remaining blocks
0891   4315 47          	ld	b,a		; b=number of blocks written
0892   4316 7B          	ld	a,e		; Get the error code
0893   4317 C9          	ret
0894   4318             
0895   4318             
0896   4318             ;-----------------------------------------------------------------------------
0897   4318             ;
0898   4318             ; Device information gathering
0899   4318             ;
0900   4318             ;Input:   A = Device index, 1 to 7
0901   4318             ;         B = Information to return:
0902   4318             ;             0: Basic information
0903   4318             ;             1: Manufacturer name string
0904   4318             ;             2: Device name string
0905   4318             ;             3: Serial number string
0906   4318             ;         HL = Pointer to a buffer in RAM
0907   4318             ;Output:  A = Error code:
0908   4318             ;             0: Ok
0909   4318             ;             1: Device not available or invalid device index
0910   4318             ;             2: Information not available, or invalid information index
0911   4318             ;         When basic information is requested,
0912   4318             ;         buffer filled with the following information:
0913   4318             ;
0914   4318             ;+0 (1): Numer of logical units, from 1 to 7. 1 if the device has no logical
0915   4318             ;        units (which is functionally equivalent to having only one).
0916   4318             ;+1 (1): Device flags, always zero in Beta 2.
0917   4318             ;
0918   4318             ; The strings must be printable ASCII string (ASCII codes 32 to 126),
0919   4318             ; left justified and padded with spaces. All the strings are optional,
0920   4318             ; if not available, an error must be returned.
0921   4318             ; If a string is provided by the device in binary format, it must be reported
0922   4318             ; as an hexadecimal, upper-cased string, preceded by the prefix "0x".
0923   4318             ; The maximum length for a string is 64 characters;
0924   4318             ; if the string is actually longer, the leftmost 64 characters
0925   4318             ; should be provided.
0926   4318             ;
0927   4318             ; In the case of the serial number string, the same rules for the strings
0928   4318             ; apply, except that it must be provided right-justified,
0929   4318             ; and if it is too long, the rightmost characters must be
0930   4318             ; provided, not the leftmost.
0931   4318             
0932   4318             DEV_INFO: 
0933   4318 B7          	or	a		; dev=0 isn't allowed
0934   4319 28 04       	jr	z,.nodev
0935   431B FE 03       	cp	3		; Max 2 devices 
0936   431D 38 03       	jr	c,.devOk
0937   431F             .nodev: 
0938   431F 3E 01       	ld	a,1		; invalid device index
0939   4321 C9          	ret
0940   4322             .devOk: 
0941   4322              IFDEF DEBUG1
0942   4322~            	push	af
0943   4322~            	ld	a,'D'		; DEV_INFO debug ID
0944   4322~            	call	PRTCHAR
0945   4322~            	pop	af
0946   4322~            	push	af
0947   4322~            	add	'0'		; Device number
0948   4322~            	call	PRTCHAR
0949   4322~            	ld	a,b		; Info number
0950   4322~            	add	'0'
0951   4322~            	call	PRTCHAR
0952   4322~            	pop	af
0953   4322              ENDIF
0954   4322 CD 35 45    	call	getWorkArea	; IX=Work area pointer
0955   4325 04          	inc	b
0956   4326 10 11       	djnz	.notBasicInfo
0957   4328             
0958   4328             ; Basic information:
0959   4328 E5          	push	hl
0960   4329 CD 12 48    	call	slctNchkCard	; Select and check the card
0961   432C E1          	pop	hl
0962   432D CD 48 46    	call	disableSDs
0963   4330              IFDEF DEBUG1
0964   4330~            	jr	nz,.hasCard
0965   4330~            	ld	a,'n'		; DEV_INFO return status: no card
0966   4330~            	call	PRTCHAR
0967   4330~            	ld	a,2
0968   4330~            	ret
0969   4330              ELSE
0970   4330 3E 02       	ld	a,2
0971   4332 C8          	ret	z		; No card: quit with "dev not available"
0972   4333              ENDIF
0973   4333              IFDEF DEBUG1
0974   4333~            .hasCard: 
0975   4333~            	ld	a,'0'		; DEV_INFO return status: no card
0976   4333~            	call	PRTCHAR
0977   4333              ENDIF
0978   4333 36 01       	ld	(hl),1		; 1 logical unit somente
0979   4335 23          	inc	hl
0980   4336 AF          	xor	a
0981   4337 77          	ld	(hl),a		; reservado, deve ser 0
0982   4338 C9          	ret			; retorna com A=0 (OK)
0983   4339             
0984   4339             .notBasicInfo: 
0985   4339 E5 C5       	push	hl,bc
0986   433B CD 12 48    	call	slctNchkCard	; Select and check the card
0987   433E C1 E1       	pop	bc,hl
0988   4340 38 02       	jr	c,.cardError	; Card error? No info
0989   4342 20 05       	jr	nz,.notBasicInfo2 ; Card present, get its info
0990   4344              IFDEF DEBUG1
0991   4344~            	ld	a,'n'		; DEV_INFO return status: no card
0992   4344~            	call	PRTCHAR
0993   4344              ELSE
0994   4344             .cardError: 
0995   4344             .noInfo: 
0996   4344              ENDIF
0997   4344 3E 02       	ld	a,2		; Quit with "Info not available" status
0998   4346 C3 48 46    	jp	disableSDs
0999   4349              IFDEF DEBUG1
1000   4349~            .cardError: 
1001   4349~            	ld	a,'e'		; DEV_INFO return status: error 
1002   4349~            	call	PRTCHAR
1003   4349~            	ld	a,2		; Quit with "Info not available" status
1004   4349~            	ret
1005   4349~            .noInfo: 
1006   4349~            	ld	a,'u'		; DEV_INFO return status: Uknown info 
1007   4349~            	call	PRTCHAR
1008   4349~            	ld	a,2		; Quit with "Info not available" status
1009   4349~            	jp	disableSDs
1010   4349              ENDIF
1011   4349             
1012   4349             .notBasicInfo2: 
1013   4349 10 45       	djnz	.tryDevInfo
1014   434B             ; Manufacturer Name:
1015   434B 11 00 4A    	ld	de,CMD10*256+CID.MID	; Point to the Manufacturer ID
1016   434E CD 00 46    	call	setCxDrd
1017   4351 38 F1       	jr	c,.noInfo
1018   4353 EB          	ex	de,hl		; de=Nextor buffer pointer
1019   4354 21 00 7B    	ld	hl,SPIDATA
1020   4357 4E          	ld	c,(hl)		; c=Manufacturer ID
1021   4358 06 11       	ld	b,18-1-CID.MID
1022   435A CD 15 46    	call	flushCxD	; Flush the rest of the CID data
1023   435D CD 48 46    	call	disableSDs
1024   4360             
1025   4360 62 6B       	ld	hl,de		; Save the Nextor buffer pointer 
1026   4362 06 40       	ld	b,64		; Fill the buffer with spaces 
1027   4364 3E 20       	ld	a,' '
1028   4366             .loop1: 
1029   4366 77          	ld	(hl),a
1030   4367 23          	inc	hl
1031   4368 10 FC       	djnz	.loop1
1032   436A EB          	ex	de,hl		; hl=pointer to Nextor buffer 
1033   436B             
1034   436B 36 28       	ld	(hl),'('	; Place "(0xNN) " on the buffer
1035   436D 23          	inc	hl
1036   436E 36 30       	ld	(hl),'0'
1037   4370 23          	inc	hl
1038   4371 36 78       	ld	(hl),'x'
1039   4373 23          	inc	hl
1040   4374 79          	ld	a,c		; Get the Manufacturer ID
1041   4375 C5          	push	bc
1042   4376 CD 61 48    	call	HexToAscii
1043   4379 C1          	pop	bc
1044   437A 36 29       	ld	(hl),')'
1045   437C 23          	inc	hl
1046   437D 36 20       	ld	(hl),' '
1047   437F 23          	inc	hl
1048   4380 79          	ld	a,c		; Get the Manufacturer ID
1049   4381 CD 75 48    	call	getMakerName	; de = Pointer to the Maker string 
1050   4384             
1051   4384             	; Copy the Maker name to the buffer
1052   4384             .loop2: 
1053   4384 1A          	ld	a,(de)
1054   4385 77          	ld	(hl),a
1055   4386 23          	inc	hl
1056   4387 13          	inc	de
1057   4388 87          	add	a,a
1058   4389 30 F9       	jr	nc,.loop2
1059   438B 2B          	dec	hl
1060   438C CB BE       	res	7,(hl)		; Clear the bit7 of the last char
1061   438E              IFDEF DEBUG1
1062   438E~            	PRTSTR	"=0"
1063   438E              ENDIF
1064   438E AF          	xor	a		; Return with A=0 (Ok)
1065   438F C9          	ret
1066   4390             
1067   4390             .tryDevInfo: 
1068   4390 10 27       	djnz	.trySerial
1069   4392             ; Device Name:
1070   4392 11 03 4A    	ld	de,CMD10*256+CID.PNM	; Point to the Product Name 
1071   4395 CD 00 46    	call	setCxDrd
1072   4398 38 AA       	jr	c,.noInfo
1073   439A E5          	push	hl
1074   439B EB          	ex	de,hl		; de=Nextor buffer pointer
1075   439C 21 00 7B    	ld	hl,SPIDATA
1076   439F 01 05 00    	ld	bc,5		; 5 chars 
1077   43A2 ED B0       	ldir			; copy the product name
1078   43A4             
1079   43A4 06 0A       	ld	b,18-5-CID.PNM
1080   43A6 CD 15 46    	call	flushCxD	; Flush the rest of the CID data
1081   43A9 CD 48 46    	call	disableSDs
1082   43AC             
1083   43AC E1          	pop	hl		; Restore the original Nextor pointer
1084   43AD 06 05       	ld	b,5		; b=string size
1085   43AF CD 0B 4B    	call	STR_SANITIZE	; Sanitize the string before sending it to Nextor
1086   43B2             
1087   43B2 EB          	ex	de,hl		; hl=current pointer to the Nextor Buffer 
1088   43B3 3E 40       	ld	a,64
1089   43B5 90          	sub	b		; Fills the rest with spaces
1090   43B6 47          	ld	b,a
1091   43B7 18 28       	jr	.fillspaces
1092   43B9             
1093   43B9             .trySerial: 
1094   43B9 05          	dec	b
1095   43BA C2 44 43    	jp	nz,.noInfo
1096   43BD             ; Serial Number:
1097   43BD 36 30       	ld	(hl),'0'	; Coloca prefixo "0x"
1098   43BF 23          	inc	hl
1099   43C0 36 78       	ld	(hl),'x'
1100   43C2 23          	inc	hl
1101   43C3             
1102   43C3 11 09 4A    	ld	de,CMD10*256+CID.PSN	; Point to the Product Serial # 
1103   43C6 CD 00 46    	call	setCxDrd
1104   43C9 DA 44 43    	jp	c,.noInfo
1105   43CC             
1106   43CC 06 04       	ld	b,4		; 4 bytes do serial
1107   43CE             .loop3: 
1108   43CE 3A 00 7B    	ld	a,(SPIDATA)
1109   43D1 CD 61 48    	call	HexToAscii	; converter HEXA para ASCII
1110   43D4 10 F8       	djnz	.loop3
1111   43D6             
1112   43D6 06 05       	ld	b,18-4-CID.PSN
1113   43D8 CD 15 46    	call	flushCxD	; Flush the rest of the CID data
1114   43DB CD 48 46    	call	disableSDs
1115   43DE             
1116   43DE EB          	ex	de,hl		; hl=Current Nextor buffer position
1117   43DF 06 36       	ld	b,54		; Fill the rest with spaces 
1118   43E1             .fillspaces: 
1119   43E1 3E 20       	ld	a,' '
1120   43E3             .loop4: 
1121   43E3 77          	ld	(hl), a
1122   43E4 23          	inc	hl
1123   43E5 10 FC       	djnz	.loop4
1124   43E7              IFDEF DEBUG1
1125   43E7~            	PRTSTR	"=0"
1126   43E7              ENDIF
1127   43E7 AF          	xor	a		; Return with A=0 (Ok)
1128   43E8 C9          	ret
1129   43E9             
1130   43E9             ;-----------------------------------------------------------------------------
1131   43E9             ;
1132   43E9             ; Obtain device status
1133   43E9             ;
1134   43E9             ;Input:   A = Device index, 1 to 7
1135   43E9             ;         B = Logical unit number, 1 to 7
1136   43E9             ;             0 to return the status of the device itself.
1137   43E9             ;Output:  A = Status for the specified logical unit,
1138   43E9             ;             or for the whole device if 0 was specified:
1139   43E9             ;                0: The device or logical unit is not available, or the
1140   43E9             ;                   device or logical unit number supplied is invalid.
1141   43E9             ;                1: The device or logical unit is available and has not
1142   43E9             ;                   changed since the last status request.
1143   43E9             ;                2: The device or logical unit is available and has changed
1144   43E9             ;                   since the last status request
1145   43E9             ;                   (for devices, the device has been unplugged and a
1146   43E9             ;                    different device has been plugged which has been
1147   43E9             ;                    assigned the same device index; for logical units,
1148   43E9             ;                    the media has been changed).
1149   43E9             ;                3: The device or logical unit is available, but it is not
1150   43E9             ;                   possible to determine whether it has been changed
1151   43E9             ;                   or not since the last status request.
1152   43E9             ;
1153   43E9             ; Devices not supporting hot-plugging must always return status value 1.
1154   43E9             ; Non removable logical units may return values 0 and 1.
1155   43E9             ;
1156   43E9             ; The returned status is always relative to the previous invokation of
1157   43E9             ; DEV_STATUS itself. Please read the Driver Developer Guide for more info.
1158   43E9             
1159   43E9             DEV_STATUS: 
1160   43E9 57          	ld	d,a		; d=Device number
1161   43EA FE 03       	cp	3		; 2 dispositivos somente
1162   43EC 30 3C       	jr	nc,.noDev
1163   43EE 78          	ld	a,b
1164   43EF B7          	or	a		; Device itself status?
1165   43F0 CA 33 44    	jp	z,.devStatus	; I'm fine, thanks
1166   43F3 3D          	dec	a		; Only LUN=1 are allowed
1167   43F4 20 34       	jr	nz,.noLun
1168   43F6             ;.getStatus:
1169   43F6              IFDEF DEBUG1
1170   43F6~            	ld	a,'S'		; DEV_STATUS debug ID
1171   43F6~            	call	PRTCHAR
1172   43F6~            	ld	a,d
1173   43F6~            	add	'0'		; Device number
1174   43F6~            	call	PRTCHAR
1175   43F6~            	ld	a,'1'		; LUN number
1176   43F6~            	call	PRTCHAR
1177   43F6              ENDIF
1178   43F6 CD 35 45    	call	getWorkArea	; IX=Work area pointer
1179   43F9 DD 5E 03    	ld	e,(ix+WRKAREA.CARDFLAGS) ; e=old LUN changed flags
1180   43FC 7A          	ld	a,d
1181   43FD CD 12 48    	call	slctNchkCard	; Select and check the card
1182   4400 CD 48 46    	call	disableSDs
1183   4403 38 25       	jr	c,.cardError
1184   4405 28 23       	jr	z,.noCard
1185   4407 FE 02       	cp	2		; Has the card just been changed?
1186   4409 28 10       	jr	z,.cardChanged	; Yes, report it
1187   440B             
1188   440B             	; A=1: Card hasn't changed this time. Need to check if another
1189   440B             	; routine has detected a change before	
1190   440B DD 7E 03    	ld	a,(ix+WRKAREA.CARDFLAGS)
1191   440E B3          	or	e		; Mix with the previous flags
1192   440F E6 0C       	and	$0C		; Crop the LUN changed flags
1193   4411 0F          	rrca			; Adjust the flags position
1194   4412 0F          	rrca
1195   4413 DD A6 02    	and	(ix+WRKAREA.NUMSD) ; Crop the LUN changed flag for this card
1196   4416 20 03       	jr	nz,.cardChanged	; The card had changed before, but Nextor was still unaware
1197   4418             .notChanged: 
1198   4418              IFDEF DEBUG1
1199   4418~            	PRTSTR	"=1"
1200   4418              ENDIF
1201   4418 3E 01       	ld	a,1		; Card is available and has not changed
1202   441A C9          	ret
1203   441B             
1204   441B             .cardChanged: 
1205   441B DD 7E 02    	ld	a,(ix+WRKAREA.NUMSD) 
1206   441E             .devChanged2: 
1207   441E 87          	add	a		; Adjust the flag position
1208   441F 87          	add	a
1209   4420 2F          	cpl
1210   4421 DD A6 03    	and	(ix+WRKAREA.CARDFLAGS)	; Clear the LUN changed flag
1211   4424 DD 77 03    	ld	(ix+WRKAREA.CARDFLAGS),a
1212   4427              IFDEF DEBUG1
1213   4427~            	PRTSTR	"=2"
1214   4427              ENDIF
1215   4427 3E 02       	ld	a,2		; Card LUN is present and has changed 
1216   4429 C9          	ret
1217   442A             .cardError: 
1218   442A              IFDEF DEBUG1
1219   442A~            	ld	a,'e'
1220   442A~            	call	PRTCHAR
1221   442A~            	xor	a
1222   442A~            	ret
1223   442A              ENDIF
1224   442A              IFDEF DEBUG3
1225   442A~            .noLun: 
1226   442A~            	inc	a
1227   442A~            .noDev: 
1228   442A~            	PRTSTR "S!"
1229   442A~            	ld	e,a		; e=LUN
1230   442A~            	ld	a,'0'
1231   442A~            	add	d
1232   442A~            	call	PRTCHAR
1233   442A~            	ld	a,'0'
1234   442A~            	add	e
1235   442A~            	call	PRTCHAR
1236   442A~            	xor	a
1237   442A~            	ret
1238   442A              ELSE
1239   442A             .noLun	equ	.devNotAvbl
1240   442A             .noDev	equ	.devNotAvbl
1241   442A              ENDIF
1242   442A             .noCard: 
1243   442A              IFDEF DEBUG1
1244   442A~            	ld	a,'n'
1245   442A~            	call	PRTCHAR
1246   442A              ENDIF
1247   442A             .devNotAvbl: 
1248   442A AF          	xor	a		; Device not available 
1249   442B C9          	ret
1250   442C             
1251   442C             .devChanged: 
1252   442C DD 7E 02    	ld	a,(ix+WRKAREA.NUMSD) 
1253   442F 87          	add	a		; Adjust the flag position
1254   4430 87          	add	a
1255   4431 18 EB       	jr	.devChanged2
1256   4433             
1257   4433             .devStatus: 	; Device status has to be checked separately, otherwise
1258   4433             		; FDISK won't notice card changes
1259   4433              IFDEF DEBUG1
1260   4433~            	ld	a,'S'		; DEV_STATUS debug ID
1261   4433~            	call	PRTCHAR
1262   4433~            	ld	a,d
1263   4433~            	add	'0'		; Device number
1264   4433~            	call	PRTCHAR
1265   4433~            	ld	a,'0'		; LUN number
1266   4433~            	call	PRTCHAR
1267   4433              ENDIF
1268   4433             
1269   4433 CD 35 45    	call	getWorkArea	; IX=Work area pointer
1270   4436 DD 5E 03    	ld	e,(ix+WRKAREA.CARDFLAGS) ; e=old LUN changed flags
1271   4439 7A          	ld	a,d
1272   443A CD 12 48    	call	slctNchkCard
1273   443D CD 48 46    	call	disableSDs
1274   4440 38 E8       	jr	c,.cardError
1275   4442 28 E6       	jr	z,.noCard
1276   4444 FE 02       	cp	2		; Has the card just been changed?
1277   4446 28 E4       	jr	z,.devChanged	; Yes, report it
1278   4448             	; A=1: Card hasn't changed this time. Need to check if another
1279   4448             	; routine has detected a change before	
1280   4448 DD 7E 03    	ld	a,(ix+WRKAREA.CARDFLAGS)
1281   444B B3          	or	e		; Mix with the previous flags
1282   444C E6 30       	and	$30		; Crop the LUN changed flags
1283   444E 0F          	rrca			; Adjust the flags position
1284   444F 0F          	rrca
1285   4450 0F          	rrca
1286   4451 0F          	rrca
1287   4452 DD A6 02    	and	(ix+WRKAREA.NUMSD) ; Crop the LUN changed flag for this card
1288   4455 20 D5       	jr	nz,.devChanged	; The card had changed before, but Nextor was still unaware
1289   4457 18 BF       	jr	.notChanged
1290   4459             
1291   4459             
1292   4459             ;-----------------------------------------------------------------------------
1293   4459             ;
1294   4459             ; Obtain logical unit information
1295   4459             ;
1296   4459             ;Input:   A  = Device index, 1 to 7
1297   4459             ;         B  = Logical unit number, 1 to 7
1298   4459             ;         HL = Pointer to buffer in RAM.
1299   4459             ;Output:  A = 0: Ok, buffer filled with information.
1300   4459             ;             1: Error, device or logical unit not available,
1301   4459             ;                or device index or logical unit number invalid.
1302   4459             ;         On success, buffer filled with the following information:
1303   4459             ;
1304   4459             ;+0 (1): Medium type:
1305   4459             ;        0: Block device
1306   4459             ;        1: CD or DVD reader or recorder
1307   4459             ;        2-254: Unused. Additional codes may be defined in the future.
1308   4459             ;        255: Other
1309   4459             ;+1 (2): Sector size, 0 if this information does not apply or is
1310   4459             ;        not available.
1311   4459             ;+3 (4): Total number of available sectors.
1312   4459             ;        0 if this information does not apply or is not available.
1313   4459             ;+7 (1): Flags:
1314   4459             ;        bit 0: 1 if the medium is removable.
1315   4459             ;        bit 1: 1 if the medium is read only. A medium that can dinamically
1316   4459             ;               be write protected or write enabled is not considered
1317   4459             ;               to be read-only.
1318   4459             ;        bit 2: 1 if the LUN is a floppy disk drive.
1319   4459             ;+8 (2): Number of cylinders
1320   4459             ;+10 (1): Number of heads
1321   4459             ;+11 (1): Number of sectors per track
1322   4459             ;
1323   4459             ; Number of cylinders, heads and sectors apply to hard disks only.
1324   4459             ; For other types of device, these fields must be zero.
1325   4459             
1326   4459             LUN_INFO: 
1327   4459 B7          	or	a		; DEV=0 is invalid
1328   445A 28 45       	jr	z,.noDev
1329   445C FE 03       	cp	3		; Max 2 devices
1330   445E 30 41       	jr	nc,.noDev
1331   4460 05          	dec	b		; Only LUN=1 
1332   4461 20 3E       	jr	nz,.noLun
1333   4463             
1334   4463              IFDEF DEBUG1
1335   4463~            	push	af
1336   4463~            	ld	a,'L'
1337   4463~            	call	PRTCHAR
1338   4463~            	pop	af
1339   4463~            	push	af
1340   4463~            	add	'0'		; Print the device number
1341   4463~            	call	PRTCHAR
1342   4463~            	ld	a,b
1343   4463~            	add	'1'
1344   4463~            	call	PRTCHAR
1345   4463~            	pop	af
1346   4463              ENDIF
1347   4463 E5          	push	hl
1348   4464 CD 35 45    	call	getWorkArea	; IX=Work area pointer
1349   4467 CD 12 48    	call	slctNchkCard	; Select and check the card
1350   446A E1          	pop	hl
1351   446B B7          	or	a
1352   446C 38 02       	jr	c,.cardError1	; Card error? Abort
1353   446E 20 09       	jr	nz,.devOk	; device is available
1354   4470             .noMedia: 
1355   4470              IFDEF DEBUG1
1356   4470~            	ld	a,'n'		; LIN_INFO status: no media
1357   4470~            	call	PRTCHAR
1358   4470              ENDIF
1359   4470 AF          	xor	a
1360   4471 06 07       	ld	b,7
1361   4473             .nmloop: 
1362   4473 77          	ld	(hl),a		; 0=block device
1363   4474 23          	inc	hl
1364   4475 10 FC       	djnz	.nmloop		; Fill the rest with "0=information not available"
1365   4477 18 36       	jr	.wflagsnCHS	; Fill the rest of the info about the device
1366   4479             
1367   4479              IFDEF DEBUG1
1368   4479~            .cardError1: 
1369   4479~            	ld	a,'e'		; LUN_INFO status: Card error
1370   4479~            	call	PRTCHAR
1371   4479~            	xor	a
1372   4479~            	ld	b,7
1373   4479~            	jr	.nmloop
1374   4479~            .cardError2: 
1375   4479~            	ld	a,'e'		; LUN_INFO status: Card error
1376   4479~            	call	PRTCHAR
1377   4479~            	jr	.quitError
1378   4479              ELSE
1379   4479             .cardError1	equ	.noMedia
1380   4479             .cardError2	equ	.quitError
1381   4479              ENDIF
1382   4479             
1383   4479              IFDEF DEBUG3
1384   4479~            .noLun: 	inc	b
1385   4479~            .noDev: 
1386   4479~            	PRTSTR	'L!'
1387   4479~            	add	'0'
1388   4479~            	call	PRTCHAR
1389   4479~            	ld	a,b
1390   4479~            	add	'0'
1391   4479~            	call	PRTCHAR
1392   4479~            	ld	a,1
1393   4479~            	ret
1394   4479              ELSE
1394   4479             .noLun	equ	.quitError
1395   4479             	
1395   4479             .noDev	equ	.quitError
1396   4479             	
1397   4479              ENDIF
1398   4479             
1399   4479             .devOk: 
1400   4479 AF          	xor	a
1401   447A 77          	ld	(hl),a		; 0 = block device 
1402   447B 23          	inc	hl
1403   447C 77          	ld	(hl),a		; Block size lsb 
1404   447D 23          	inc	hl
1405   447E 36 02       	ld	(hl),2		; Block size msb = 512
1406   4480 23          	inc	hl
1407   4481             
1408   4481 11 00 49    	ld	de,CMD9*256+0	; Read the CSD
1409   4484 CD 00 46    	call	setCxDrd
1410   4487 38 18       	jr	c,.cardError2
1411   4489             
1412   4489 EB          	ex	de,hl		; de=LUN_INFO buffer+3
1413   448A 21 00 7B    	ld	hl,SPIDATA
1414   448D             
1415   448D 4E          	ld	c,(hl)		; c=CSD byte 0
1416   448E             
1417   448E 06 04       	ld	b,4
1418   4490             .skipCSDheader: 
1419   4490 7E          	ld	a,(hl)
1420   4491 10 FD       	djnz	.skipCSDheader	
1421   4493             
1422   4493 79          	ld	a,c
1423   4494 E6 C0       	and	$C0		; Crop the CSD version ID
1424   4496 28 23       	jr	z,.calculaCSD1
1425   4498 FE 40       	cp	$40
1426   449A 28 69       	jr	z,.calculaCSD2
1427   449C             
1428   449C 06 0D       	ld	b,18-5
1429   449E CD 15 46    	call	flushCxD	; Flush the rest of the CID data
1430   44A1             ;	jr	.quitError	; Unknown CSD version 
1431   44A1             
1432   44A1             .quitError: 
1433   44A1 3E 01       	ld	a,1		; Return with A=1: Error
1434   44A3 C3 48 46    	jp	disableSDs
1435   44A6             
1436   44A6             
1437   44A6             .savenblocks: 
1438   44A6 E1          	pop	hl
1439   44A7 73          	ld	(hl),e
1440   44A8 23          	inc	hl
1441   44A9 72          	ld	(hl),d
1442   44AA 23          	inc	hl
1443   44AB 71          	ld	(hl),c
1444   44AC 23          	inc	hl
1445   44AD 70          	ld	(hl),b
1446   44AE 23          	inc	hl
1447   44AF             
1448   44AF             .wflagsnCHS: 
1449   44AF 36 01       	ld	(hl),1		; flags: dispositivo R/W removivel
1450   44B1 23          	inc	hl
1451   44B2 AF          	xor	a		; CHS = 0
1452   44B3 77          	ld	(hl), a
1453   44B4 23          	inc	hl
1454   44B5 77          	ld	(hl), a
1455   44B6 23          	inc	hl
1456   44B7 77          	ld	(hl), a
1457   44B8              IFDEF DEBUG1
1458   44B8~            	PRTSTR	"=0"
1459   44B8~            	xor	a
1460   44B8              ENDIF
1461   44B8 C3 48 46    	jp	disableSDs	; Return with A-0: Ok, filled the buffer
1462   44BB             
1463   44BB             ; -----------------------------------
1464   44BB             ; Calculate the number of blocks from
1465   44BB             ; a CSD version 1
1466   44BB             ; Input   : none
1467   44BB             ; Output  : c:de = Number of blocks
1468   44BB             ; Modifies: af, b
1469   44BB             ; -----------------------------------
1470   44BB             .calculaCSD1: 
1471   44BB D5          	push	de		; save the current Nextor buffer pointer
1472   44BC 7E          	ld	a,(hl)
1473   44BD E6 0F       	and	$0F		; isola READ_BL_LEN
1474   44BF F5          	push	af
1475   44C0             ;	inc	hl
1476   44C0 7E          	ld	a,(hl)		; 2 primeiros bits de C_SIZE
1477   44C1 E6 03       	and	3
1478   44C3 57          	ld	d,a
1479   44C4             ;	inc	hl
1480   44C4 5E          	ld	e,(hl)		; 8 bits de C_SIZE (DE contem os primeiros 10 bits de C_SIZE)
1481   44C5             ;	inc	hl
1482   44C5 7E          	ld	a,(hl)
1483   44C6 E6 C0       	and	$C0		; 2 ultimos bits de C_SIZE
1484   44C8 87          	add	a		; rotaciona a esquerda
1485   44C9 CB 13       	rl	e		; rotaciona para DE
1486   44CB CB 12       	rl	d
1487   44CD 87          	add	a		; mais uma rotacao
1488   44CE CB 13       	rl	e		; rotaciona para DE
1489   44D0 CB 12       	rl	d
1490   44D2 13          	inc	de		; agora DE contem todos os 12 bits de C_SIZE, incrementa 1
1491   44D3             ;	inc	hl
1492   44D3 7E          	ld	a,(hl)		; proximo byte
1493   44D4 E6 03       	and	3		; 2 bits de C_SIZE_MUL
1494   44D6 47          	ld	b, a		; B contem os 2 bits de C_SIZE_MUL
1495   44D7             ;	inc	hl						
1496   44D7 7E          	ld	a,(hl)		; proximo byte
1497   44D8 E6 80       	and	$80		; 1 bit de C_SIZE_MUL
1498   44DA 87          	add	a		; rotaciona para esquerda jogando no carry
1499   44DB CB 10       	rl	b		; rotaciona para B
1500   44DD 04          	inc	b		; agora B contem os 3 bits de C_SIZE_MUL
1501   44DE 04          	inc	b		; faz B = C_SIZE_MUL + 2
1502   44DF F1          	pop	af		; volta em A o READ_BL_LEN
1503   44E0 80          	add	b		; A = READ_BL_LEN + (C_SIZE_MUL+2)
1504   44E1 01 00 00    	ld	bc, 0
1505   44E4 CD F9 44    	call	.eleva2
1506   44E7 5A          	ld	e,d		; aqui temos 32 bits (BC DE) com o tamanho do cartao
1507   44E8 51          	ld	d,c		; ignoramos os 8 ultimos bits em E, fazemos BC DE => 0B CD (divide por 256)
1508   44E9 48          	ld	c,b
1509   44EA             ;	ld	b,0
1510   44EA CB 39       	srl	c		; rotacionamos a direita o C, carry = LSB (divide por 2)
1511   44EC CB 1A       	rr	d		; rotacionamos D e E
1512   44EE CB 1B       	rr	e		; no final BC DE contem tamanho do cartao / 512 = numero de blocos
1513   44F0             
1514   44F0 06 07       	ld	b,18-5-6
1515   44F2 CD 15 46    	call	flushCxD	; Flush the rest of the CSD data
1516   44F5             
1517   44F5 06 00       	ld	b,0 		; SD cards return a 24bit number for 
1518   44F7              				; the number of blocks so we have to clear the
1519   44F7             				; Nextor upper byte
1520   44F7 18 AD       	jr	.savenblocks
1521   44F9             
1522   44F9             .eleva2: 			; aqui temos: A = (READ_BL_LEN + (C_SIZE_MUL+2))
1523   44F9             				; BC = 0
1524   44F9             				; DE = C_SIZE
1525   44F9 CB 23       	sla	e		; rotacionamos C_SIZE por 'A' vezes
1526   44FB CB 12       	rl	d
1527   44FD CB 11       	rl	c
1528   44FF CB 10       	rl	b
1529   4501 3D          	dec	a		; subtraimos 1
1530   4502 20 F5       	jr	nz,.eleva2
1531   4504 C9          	ret			; em BC DE temos o tamanho do cartao (bytes) em 32 bits
1532   4505             
1533   4505             
1534   4505             ; -----------------------------------
1535   4505             ; Calculate the number of blocks from
1536   4505             ; a CSD version 2
1537   4505             ; Input   : none
1538   4505             ; Output  : c:de = Number of blocks
1539   4505             ; Modifies: af, b
1540   4505             ; -----------------------------------
1541   4505             .calculaCSD2: 
1542   4505 D5          	push	de		; save the current Nextor buffer pointer
1543   4506             ;	inc	hl		; HL ja aponta para BCSD+5, fazer HL apontar para BCSD+7
1544   4506             ;	inc	hl
1545   4506 7E          	ld	a,(hl)		; Discard 2 bytes
1546   4507 7E          	ld	a,(hl)
1547   4508             
1548   4508 7E          	ld	a,(hl)
1549   4509 E6 3F       	and	$3F
1550   450B 4F          	ld	c,a
1551   450C             ;	inc	hl
1552   450C 56          	ld	d,(hl)
1553   450D             ;	inc	hl
1554   450D 5E          	ld	e,(hl)
1555   450E CD 21 45    	call	.inc32		; soma 1
1556   4511 CD 29 45    	call	.desloca32	; multiplica por 512
1557   4514 CD 2E 45    	call	.rotaciona24	; multiplica por 2
1558   4517             
1559   4517 C5          	push	bc
1560   4518 06 08       	ld	b,18-5-5
1561   451A CD 15 46    	call	flushCxD	; Flush the rest of the CSD data
1562   451D C1          	pop	bc		; SDHC/SDXC cards have a 32bit size
1563   451E C3 A6 44    	jp	.savenblocks
1564   4521             
1565   4521             .inc32: 
1566   4521 1C          	inc	e
1567   4522 C0          	ret	nz
1568   4523 14          	inc	d
1569   4524 C0          	ret	nz
1570   4525 0C          	inc	c
1571   4526 C0          	ret	nz
1572   4527 04          	inc	b
1573   4528 C9          	ret
1574   4529             
1575   4529             .desloca32: 
1576   4529 41          	ld	b, c
1577   452A 4A          	ld	c, d
1578   452B 53          	ld	d, e
1579   452C 1E 00       	ld	e, 0
1580   452E             .rotaciona24: 
1581   452E CB 22       	sla	d
1582   4530 CB 11       	rl	c
1583   4532 CB 10       	rl	b
1584   4534 C9          	ret
1585   4535             
1586   4535             
1587   4535             
1588   4535             
1589   4535             ;=====
1590   4535             ;=====  END of DEVICE-BASED specific routines
1591   4535             ;=====
1592   4535             
1593   4535             ;------------------------------------------------
1594   4535             ; Rotinas auxiliares
1595   4535             ;------------------------------------------------
1596   4535             
1597   4535             ;------------------------------------------------
1598   4535             ; Get the SLTWRK pointer 
1599   4535             ; Output: 
1600   4535             ;           IX = SLTWRK pointer
1601   4535             ; Modifies: AF'
1602   4535             ;------------------------------------------------
1603   4535             getWorkArea: 
1604   4535 F5          	push	af
1605   4536 AF          	xor	a		; A=0: GWORK current slot
1606   4537 08          	ex	af,af'
1607   4538 AF          	xor	a		; A=0: BANK0 
1608   4539 DD 21 45 40 	ld	ix,GWORK
1609   453D CD 42 40    	call	CALBNK
1610   4540 F1          	pop	af
1611   4541 C9          	ret
1612   4542             
1613   4542             ;------------------------------------------------
1614   4542             ; Marcar bit de erro nas flags
1615   4542             ; Destroi AF, C
1616   4542             ;------------------------------------------------
1617   4542             marcaErroCartao: 
1618   4542 DD 4E 02    	ld	c, (ix+WRKAREA.NUMSD)		; cartao atual (1 ou 2)
1619   4545 DD 7E 03    	ld	a, (ix+WRKAREA.CARDFLAGS)	; marcar erro
1620   4548 B1          	or	c
1621   4549 DD 77 03    	ld	(ix+WRKAREA.CARDFLAGS), a
1622   454C C9          	ret
1623   454D             
1624   454D             ;------------------------------------------------
1625   454D             ; Testar se cartao atual esta protegido contra
1626   454D             ; gravacao, A=0 se protegido
1627   454D             ; Destroi AF, C
1628   454D             ;------------------------------------------------
1629   454D             testaWP: 
1630   454D DD 7E 02    	ld	a, (ix+WRKAREA.NUMSD)	; cartao atual (1 ou 2)
1631   4550 32 F0 7F    	ld	(SPICTRL), a
1632   4553 3A F0 7F    	ld	a, (SPISTATUS)	; testar se cartao esta protegido
1633   4556             ;	call	disableSDs
1634   4556 E6 04       	and	$04
1635   4558 C9          	ret			; se A for 0 cartao esta protegido
1636   4559             
1637   4559             
1638   4559             
1639   4559             ;------------------------------------------------
1640   4559             ; Minhas funcoes para cartao SD
1641   4559             ;------------------------------------------------
1642   4559             
1643   4559             ;------------------------------------------------
1644   4559             ; Processo de inicializacao e deteccao do cartao.
1645   4559             ; Detecta se cartao responde, qual versao (SDV1
1646   4559             ; ou SDV2), faz a leitura do CSD e CID e calcula
1647   4559             ; o numero de blocos do cartao, colocando o CID
1648   4559             ; e total de blocos no buffer correto dependendo
1649   4559             ; do cartao 1 ou 2.
1650   4559             ; Retorna erro no carry. Se for 0 indica deteccao
1651   4559             ; com sucesso.
1652   4559             ; Destroi todos os registradores
1653   4559             ; Input   : (ix+WRKAREA.NUMSD)
1654   4559             ; Output  : (ix+WRKAREA.CARDFLAGS)
1655   4559             ;           Cy set in case of error
1656   4559             ;           E=DEV_RW error code in case of error
1657   4559             ; Modifies: AF, BC, DE, HL
1658   4559             ;------------------------------------------------
1659   4559             detectaCartao: 
1660   4559              IFDEF DEBUG1
1661   4559~            	PRTSTR	"<detect card "
1662   4559~            	ld	a,(ix+WRKAREA.NUMSD)
1663   4559~            	add	'0'
1664   4559~            	call	PRTCHAR
1665   4559~            	PRTSTR	" v"
1666   4559              ENDIF
1667   4559 CD 1D 46    	call	iniciaSD		; Initialize this SD card
1668   455C 1E FC       	ld	e,ENRDY
1669   455E DA A9 45    	jp	c,.quitError		; This card has an error: quit
1670   4561 CD BF 45    	call	detSDversion		; Check if this is a V2 card
1671   4564              IFDEF DEBUG1
1672   4564~            	push	af
1673   4564~            	add	'0'
1674   4564~            	call	PRTCHAR
1675   4564~            	pop	af
1676   4564              ENDIF
1677   4564 38 41       	jr	c,.incompCardV2		; Incompatible card
1678   4566 3E 7A       	ld	a,CMD58			; Read OCR
1679   4568 11 00 00    	ld	de,0
1680   456B CD 87 46    	call	SD_SEND_CMD_2_ARGS_GET_R3
1681   456E 38 37       	jr	c,.incompCardCMD58	; Incompatible card
1682   4570             
1683   4570             	; Set the card version on WRKAREA.CARDFLAGS
1684   4570 DD 7E 02    	ld	a,(ix+WRKAREA.NUMSD)
1685   4573 0F          	rrca				; Adjust the bits position
1686   4574 0F          	rrca
1687   4575 5F          	ld	e,a			; e=b7,b6: Card number normal mask
1688   4576 2F          	cpl
1689   4577 4F          	ld	c,a			; c=b7,b6: Card number reverse mask
1690   4578 78          	ld	a,b			; Get the part of the OCR we need 
1691   4579 E6 40       	and	$40			; Crop the card version bit
1692   457B CB 7B       	bit	7,e			; Is the card-2 slot selected?
1693   457D 28 01       	jr	z,.saveSDver		; No, skip
1694   457F 87          	add	a			; Adjust the version bit position
1695   4580             .saveSDver: 
1696   4580 47          	ld	b,a			; b=card version flag for this card slot
1697   4581 DD 7E 03    	ld	a,(ix+WRKAREA.CARDFLAGS)
1698   4584 A1          	and	c			; Clear the previous version flag
1699   4585 B0          	or	b
1700   4586 DD 77 03    	ld	(ix+WRKAREA.CARDFLAGS),a
1701   4589 A3          	and	e			; Is this card V1?
1702   458A CC B4 45    	call	z,mudarTamanhoBlocoPara512	; Yes, set the block size to 512
1703   458D 38 18       	jr	c,.incompCardBlk512		; Incompatible card
1704   458F             
1705   458F             	; Set the rest of the WRKAREA.CARDFLAGS
1706   458F DD 7E 02    	ld	a,(ix+WRKAREA.NUMSD)
1707   4592 4F          	ld	c,a			; c=Card OR mask
1708   4593 2F          	cpl
1709   4594 47          	ld	b,a			; b=Card AND mask
1710   4595 DD 7E 03    	ld	a,(ix+WRKAREA.CARDFLAGS)
1711   4598 A0          	and	b			; Clear the error flag
1712   4599 CB 21       	sla	c			; Adjust to the flag position
1713   459B CB 21       	sla	c
1714   459D B1          	or	c			; Flag that LUN has changed
1715   459E CB 21       	sla	c			; Adjust to the flag position
1716   45A0 CB 21       	sla	c
1717   45A2 B1          	or	c			; Flag that DEV has changed
1718   45A3 DD 77 03    	ld	(ix+WRKAREA.CARDFLAGS),a
1719   45A6              IFDEF DEBUG1
1720   45A6~            	PRTSTR	" ok>"
1721   45A6              ENDIF
1722   45A6 C9          	ret
1723   45A7             
1724   45A7              IFNDEF DEBUG1
1725   45A7             .incompCardV2: 			; Incompatible card v2 error
1726   45A7             .incompCardCMD58: 		; Incompatible card CMD58 error
1727   45A7             .incompCardBlk512: 		; Incompatible card setBlk512 error
1728   45A7 1E FF       	ld	e,ENCOMP
1729   45A9              ELSE
1730   45A9~            .incompCardV2: 			; Incompatible card v2 error
1731   45A9~            	PRTSTR	" iv2>"
1732   45A9~            	ld	e,ENCOMP
1733   45A9~            	jr	.quitError2
1734   45A9~            .incompCardCMD58: 		; Incompatible card CMD58 error
1735   45A9~            	PRTSTR	" icmd58>"
1736   45A9~            	ld	e,ENCOMP
1737   45A9~            	jr	.quitError2
1738   45A9~            .incompCardBlk512: 		; Incompatible card setBlk512 error
1739   45A9~            	PRTSTR	" iblk512>"
1740   45A9~            	ld	e,ENCOMP
1741   45A9~            	jr	.quitError2
1742   45A9              ENDIF
1743   45A9             
1744   45A9             .quitError: 
1745   45A9              IFDEF DEBUG1
1746   45A9~            	PRTSTR	" e>"
1747   45A9~            .quitError2: 
1748   45A9              ENDIF
1749   45A9 CD 48 46    	call	disableSDs
1750   45AC DD 7E 03    	ld	a,(ix+WRKAREA.CARDFLAGS)
1751   45AF DD B6 02    	or	(ix+WRKAREA.NUMSD)	; Flag that this card has an error
1752   45B2 37          	scf
1753   45B3 C9          	ret
1754   45B4             
1755   45B4             
1756   45B4             
1757   45B4             
1758   45B4             ; ------------------------------------------------
1759   45B4             ; Setar o tamanho do bloco para 512 se o cartao
1760   45B4             ; for SDV1
1761   45B4             ; ------------------------------------------------
1762   45B4             mudarTamanhoBlocoPara512: 
1763   45B4              IFDEF DEBUG2
1764   45B4~            	PRTSTR	"<setBlk512>"
1765   45B4              ENDIF
1766   45B4 3E 50       	ld	a, CMD16
1767   45B6 01 00 00    	ld	bc, 0
1768   45B9 11 00 02    	ld	de, 512
1769   45BC C3 72 46    	jp	SD_SEND_CMD_GET_ERROR
1770   45BF             
1771   45BF             ; ------------------------------------------------
1772   45BF             ; Detects the SD card version 
1773   45BF             ; Output: A=Card version
1774   45BF             ;           0: Unknown
1775   45BF             ;           1: SD V1
1776   45BF             ;           2: SD V2
1777   45BF             ;           3: MMC V3
1778   45BF             ;         Cy set on error
1779   45BF             ; ------------------------------------------------
1780   45BF             detSDversion: 
1781   45BF              IFDEF DEBUG2
1782   45BF~            	PRTSTR	"<detSDversion"
1783   45BF              ENDIF
1784   45BF 3E 48       	ld	a, CMD8
1785   45C1 11 AA 01    	ld	de, $1AA
1786   45C4 CD 87 46    	call	SD_SEND_CMD_2_ARGS_GET_R3
1787   45C7 38 14       	jr	c,.v1Card
1788   45C9 7A          	ld	a,d
1789   45CA E6 01       	and	1
1790   45CC 57          	ld	d,a
1791   45CD 21 AA 01    	ld	hl,$1AA
1792   45D0 ED 52       	sbc	hl,de			; Lower 12-bit were 1AAh?
1793   45D2              IFDEF DEBUG2
1794   45D2~            	ld	a,0
1795   45D2~            	jr	nz,.incompat
1796   45D2              ELSE
1797   45D2 37          	scf
1798   45D3 C0          	ret	nz			; No, quit with error
1799   45D4              ENDIF
1800   45D4             ;.v2Card:
1801   45D4 21 5D 46    	ld	hl,SD_SEND_ACMD41
1802   45D7 CD EF 45    	call	.init
1803   45DA 3E 02       	ld	a,2
1804   45DC              IFDEF DEBUG2
1805   45DC~            	jr	c,.incompat
1806   45DC~            	PRTSTR	" 2>"
1807   45DC              ENDIF
1808   45DC C9          	ret				; SD V2, if nc
1809   45DD             
1810   45DD             
1811   45DD             .v1Card: 
1812   45DD 21 5D 46    	ld	hl,SD_SEND_ACMD41
1813   45E0 CD EF 45    	call	.init
1814   45E3 3E 01       	ld	a,1
1815   45E5              IFDEF DEBUG2
1816   45E5~            	jr	c,.v3MMC
1817   45E5~            	PRTSTR	" 1>"
1818   45E5~            	ret
1819   45E5              ELSE
1820   45E5 D0          	ret	nc			; SD V1, if ACMD41 was accepted
1821   45E6              ENDIF
1822   45E6             
1823   45E6             .v3MMC: 
1824   45E6 21 6B 46    	ld	hl,SD_SEND_CMD1
1825   45E9 CD EF 45    	call	.init
1826   45EC 3E 03       	ld	a,3
1827   45EE              IFDEF DEBUG2
1828   45EE~            	jr	c,.incompat
1829   45EE~            	PRTSTR	" 3>"
1830   45EE              ELSE
1831   45EE C9          	ret				; MMC V3, if nc
1832   45EF              ENDIF
1833   45EF             
1834   45EF             
1835   45EF             .init: 
1836   45EF 01 14 00    	ld	bc,#0014		; 5120 tentativas
1837   45F2             .loop: 
1838   45F2 C5          	push	bc
1839   45F3 CD FF 45    	call	.jumpHL		; chamar rotina correta em HL
1840   45F6 C1          	pop	bc
1841   45F7 C8          	ret	z
1842   45F8 10 F8       	djnz	.loop
1843   45FA 0D          	dec	c
1844   45FB 20 F5       	jr	nz,.loop
1845   45FD 37          	scf
1846   45FE C9          	ret
1847   45FF             .jumpHL: 
1848   45FF E9          	jp	(hl)		; chamar rotina correta em HL
1849   4600             
1850   4600             
1851   4600             
1852   4600              IFDEF DEBUG2
1853   4600~            .incompat: 
1854   4600~            	push	af
1855   4600~            	push	af
1856   4600~            	ld	a,' '
1857   4600~            	call	PRTCHAR
1858   4600~            	pop	af
1859   4600~            	add	'0'
1860   4600~            	call	PRTCHAR
1861   4600~            	pop	af
1862   4600~            	PRTSTR	"e>"
1863   4600~            	scf
1864   4600~            	ret
1865   4600              ENDIF
1866   4600             
1867   4600             
1868   4600             ; ------------------------------------------------
1869   4600             ; Reads the CxD (CID, CSD) and skips data until it points
1870   4600             ; to the requested field
1871   4600             ; Input   : D=SD command
1872   4600             ;           E=requested CID field
1873   4600             ; Modifies: AF, BC, DE
1874   4600             ; ------------------------------------------------
1875   4600             setCxDrd: 
1876   4600             ;	call	setaSDAtual
1877   4600 D5          	push	de
1878   4601 7A          	ld	a,d	; get SD command
1879   4602 CD 6D 46    	call	SD_SEND_CMD_NO_ARGS
1880   4605 D1          	pop	de
1881   4606 D8          	ret	c
1882   4607 CD CC 46    	call	WAIT_RESP_FE
1883   460A D8          	ret	c
1884   460B             
1885   460B 7B          	ld	a,e
1886   460C B7          	or	a
1887   460D C8          	ret	z
1888   460E 43          	ld	b,e
1889   460F             .skipfields: 
1890   460F 3A 00 7B    	ld	a,(SPIDATA)
1891   4612 10 FB       	djnz	.skipfields
1892   4614 C9          	ret
1893   4615             
1894   4615             
1895   4615             ; ------------------------------------------------
1896   4615             ; Flush the rest of the CxD (CID, CSD) data
1897   4615             ; and disable the SD card slots
1898   4615             ; Input   : B=Number of bytes to flush 
1899   4615             ; Modifies: A
1900   4615             ; ------------------------------------------------
1901   4615             flushCxD: 
1902   4615 3A 00 7B    	ld	a,(SPIDATA)
1903   4618 10 FB       	djnz	flushCxD
1904   461A C3 48 46    	jp	disableSDs
1905   461D             
1906   461D             
1907   461D             
1908   461D             
1909   461D             
1910   461D             ; ------------------------------------------------
1911   461D             ; Algoritmo para inicializar um cartao SD
1912   461D             ; Destroi AF, B, DE
1913   461D             ; ------------------------------------------------
1914   461D             iniciaSD: 
1915   461D DD 7E 02    	ld	a, (ix+WRKAREA.NUMSD)
1916   4620 32 F0 7F    	ld	(SPICTRL), a
1917   4623 CD 48 46    	call	disableSDs
1918   4626             
1919   4626 06 0A       	ld	b,10		; enviar 80 pulsos de clock com cartao desabilitado
1920   4628 3E FF       	ld	a,$FF		; manter MOSI em 1
1921   462A             enviaClocksInicio: 
1922   462A 32 00 7B    	ld	(SPIDATA), a
1923   462D 10 FB       	djnz	enviaClocksInicio
1924   462F             ;	call	setaSDAtual	; ativar cartao atual
1925   462F             ;	jp	c,disableSDs	; Quit on error
1926   462F             
1927   462F 3A 00 7B    	ld	a, (SPIDATA)		; Dummy read
1928   4632 DD 7E 02    	ld	a, (ix+WRKAREA.NUMSD)
1929   4635 32 F0 7F    	ld	(SPICTRL), a
1930   4638             
1931   4638             ;	call	disableSDs
1932   4638             
1933   4638 06 08       	ld	b,8		; 8 tentativas para CMD0
1934   463A             SD_SEND_CMD0: 
1935   463A 3E 40       	ld	a, CMD0		; primeiro comando: CMD0
1936   463C 11 00 00    	ld	de, 0
1937   463F C5          	push	bc
1938   4640 CD 7A 46    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
1939   4643 C1          	pop	bc
1940   4644 D0          	ret	nc			; retorna se cartao respondeu ao CMD0
1941   4645 10 F3       	djnz	SD_SEND_CMD0
1942   4647 37          	scf			; cartao nao respondeu ao CMD0, informar erro
1943   4648             	; fall through
1944   4648             
1945   4648             ; ------------------------------------------------
1946   4648             ; Desabilitar (de-selecionar) todos os cartoes
1947   4648             ; Nao destroi registradores
1948   4648             ; ------------------------------------------------
1949   4648             disableSDs: 
1950   4648 F5          	push	af
1951   4649 AF          	xor	a
1952   464A 32 F0 7F    	ld	(SPICTRL), a
1953   464D 3E FF       	ld	a,$FF
1954   464F 32 00 7B    	ld	(SPIDATA), a		; Dummy write to release DO
1955   4652 F1          	pop	af
1956   4653 C9          	ret
1957   4654             
1958   4654             
1959   4654             ; ------------------------------------------------
1960   4654             ; Get the selected card version
1961   4654             ; Input   : (WRKAREA.NUMSD)
1962   4654             ; Output  : A=Card version (0=V1, NZ=V2)
1963   4654             ;         : Flag Z will be updated accordingly
1964   4654             ; Modifies: none
1965   4654             ; ------------------------------------------------
1966   4654             getCardVer: 
1967   4654 DD 7E 03    	ld	a,(ix+WRKAREA.CARDFLAGS)
1968   4657 07          	rlca				; Adjust the flag position
1969   4658 07          	rlca
1970   4659 DD A6 02    	and	(ix+WRKAREA.NUMSD)	; Crop this card version
1971   465C C9          	ret
1972   465D             
1973   465D             ; ------------------------------------------------
1974   465D             ; Enviar comando ACMD41
1975   465D             ; ------------------------------------------------
1976   465D             SD_SEND_ACMD41: 
1977   465D 3E 77       	ld	a,CMD55
1978   465F CD 6D 46    	call	SD_SEND_CMD_NO_ARGS
1979   4662 3E 69       	ld	a,ACMD41
1980   4664 01 00 40    	ld	bc,$4000
1981   4667 51          	ld	d,c
1982   4668 59          	ld	e,c
1983   4669 18 07       	jr	SD_SEND_CMD_GET_ERROR
1984   466B             
1985   466B             ; ------------------------------------------------
1986   466B             ; Enviar CMD1 para cartao. Carry indica erro
1987   466B             ; Destroi AF, BC, DE
1988   466B             ; ------------------------------------------------
1989   466B             SD_SEND_CMD1: 
1990   466B 3E 41       	ld	a,CMD1
1991   466D             SD_SEND_CMD_NO_ARGS: 
1992   466D 01 00 00    	ld	bc,0
1993   4670 50          	ld	d,b
1994   4671 59          	ld	e,c
1995   4672             SD_SEND_CMD_GET_ERROR: 		; Send command with BC:DE as its parameter
1996   4672 CD 9F 46    	call	SD_SEND_CMD
1997   4675 B7          	or	a
1998   4676 C8          	ret	z			; se A=0 nao houve erro, retornar
1999   4677             setaErro: 
2000   4677 37          	scf
2001   4678 18 CE       	jr	disableSDs
2002   467A             
2003   467A             ; ------------------------------------------------
2004   467A             ; Enviar comando em A com 2 bytes de parametros
2005   467A             ; em DE e testar retorno BUSY
2006   467A             ; Retorna em A a resposta do cartao
2007   467A             ; Destroi AF, BC
2008   467A             ; ------------------------------------------------
2009   467A             SD_SEND_CMD_2_ARGS_TEST_BUSY: 
2010   467A 01 00 00    	ld	bc,0
2011   467D CD 9F 46    	call	SD_SEND_CMD
2012   4680 47          	ld	b, a
2013   4681 E6 FE       	and	$FE		; Test all error flags except on bit0 
2014   4683 78          	ld	a, b
2015   4684 20 F1       	jr	nz,setaErro	; Abort if there are any errors 
2016   4686 C9          	ret
2017   4687             
2018   4687             ; ------------------------------------------------
2019   4687             ; Enviar comando em A com 2 bytes de parametros
2020   4687             ; em DE e ler resposta do tipo R3 em BC DE
2021   4687             ; Retorna em A a resposta do cartao
2022   4687             ; Destroi AF, BC, DE, HL
2023   4687             ; Output: BC:DE return code
2024   4687             ; ------------------------------------------------
2025   4687             SD_SEND_CMD_2_ARGS_GET_R3: 
2026   4687 CD 7A 46    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
2027   468A F5          	push	af
2028   468B CD DD 46    	call	WAIT_RESP_NO_FF
2029   468E 67          	ld	h, a
2030   468F CD DD 46    	call	WAIT_RESP_NO_FF
2031   4692 6F          	ld	l, a
2032   4693 CD DD 46    	call	WAIT_RESP_NO_FF
2033   4696 57          	ld	d, a
2034   4697 CD DD 46    	call	WAIT_RESP_NO_FF
2035   469A 5F          	ld	e, a
2036   469B 44          	ld	b, h
2037   469C 4D          	ld	c, l
2038   469D F1          	pop	af
2039   469E C9          	ret
2040   469F             
2041   469F             
2042   469F             ; ------------------------------------------------
2043   469F             ; Enviar comando em A com 4 bytes de parametros
2044   469F             ; em BC:DE e enviar CRC correto se for CMD0 ou 
2045   469F             ; CMD8 e aguardar processamento do cartao
2046   469F             ; Output  : A=0 if there was no error
2047   469F             ; Modifies:  AF, B, AF'
2048   469F             ; ------------------------------------------------
2049   469F             SD_SEND_CMD: 
2050   469F CD FA 46    	call	setaSDAtual	; Setlect the card and wait for ready 
2051   46A2 D8          	ret	c		; Abort on error
2052   46A3 32 00 7B    	ld	(SPIDATA), a
2053   46A6 F5          	push	af
2054   46A7 78          	ld	a, b
2055   46A8 32 00 7B    	ld	(SPIDATA), a
2056   46AB 79          	ld	a, c
2057   46AC 32 00 7B    	ld	(SPIDATA), a
2058   46AF 7A          	ld	a, d
2059   46B0 32 00 7B    	ld	(SPIDATA), a
2060   46B3 7B          	ld	a, e
2061   46B4 32 00 7B    	ld	(SPIDATA), a
2062   46B7 F1          	pop	af
2063   46B8 FE 40       	cp	CMD0
2064   46BA 06 95       	ld	b,$95		; CMD0 CRC
2065   46BC 28 08       	jr	z,.enviaCRC
2066   46BE FE 48       	cp	CMD8
2067   46C0 06 87       	ld	b,$87		; CMD8 CRC
2068   46C2 28 02       	jr	z,.enviaCRC
2069   46C4             
2070   46C4             	; Disabled these checksums because they caused problems
2071   46C4             	; with some SDV1 cards. It's said that some Toshiba cards
2072   46C4             	; need them, but I don't have any to test.
2073   46C4             	; In case this need to be enabled someday, probably the best
2074   46C4             	; approach will be to send the appropriate ACMD41 checksum to
2075   46C4             	; the respective card version
2076   46C4             ;	cp	CMD55
2077   46C4             ;	ld	b,$65		; CMD55 CRC
2078   46C4             ;	jr	z,.enviaCRC
2079   46C4             ;	cp	ACMD41
2080   46C4             ;	ld	b,$77		; ACMD41 CRC  (E5h for non-SDHC/SDXC cards)
2081   46C4             ;	jr	z,.enviaCRC
2082   46C4 06 FF       	ld	b, $FF		; dummy CRC
2083   46C6             .enviaCRC: 
2084   46C6 78          	ld	a,b
2085   46C7 32 00 7B    	ld	(SPIDATA),a
2086   46CA 18 11       	jr	WAIT_RESP_NO_FF
2087   46CC             
2088   46CC             
2089   46CC             ; ------------------------------------------------
2090   46CC             ; Esperar que resposta do cartao seja $FE
2091   46CC             ; Destroi AF, B
2092   46CC             ; ------------------------------------------------
2093   46CC             WAIT_RESP_FE: 
2094   46CC 06 00       	ld	b,0		; 256 tentativas
2095   46CE             .loop: 
2096   46CE 3A 00 7B    	ld	a,(SPIDATA)
2097   46D1 FE FE       	cp	$FE		; resposta  $FE ?
2098   46D3 C8          	ret	z		; sim, retornamos com carry=0
2099   46D4 E3          	ex	(sp),hl
2100   46D5 E3          	ex	(sp),hl
2101   46D6 E3          	ex	(sp),hl
2102   46D7 E3          	ex	(sp),hl
2103   46D8 10 F4       	djnz	.loop
2104   46DA             .timeout: 
2105   46DA AF          	xor	a		; No error flags and Cy set = timeout
2106   46DB 37          	scf
2107   46DC C9          	ret
2108   46DD             
2109   46DD             ; ------------------------------------------------
2110   46DD             ; Esperar que resposta do cartao seja diferente
2111   46DD             ; de $FF
2112   46DD             ; Destroi AF, BC
2113   46DD             ; ------------------------------------------------
2114   46DD             WAIT_RESP_NO_FF: 
2115   46DD 06 00       	ld	b,0		; 256 retries
2116   46DF             .loop: 
2117   46DF 3A 00 7B    	ld	a,(SPIDATA)
2118   46E2 FE FF       	cp	$FF		; A=$FF?	
2119   46E4 3F          	ccf
2120   46E5 D0          	ret	nc		; No, quit
2121   46E6 10 F7       	djnz	.loop
2122   46E8 37          	scf			; Error: timeout
2123   46E9 C9          	ret
2124   46EA             
2125   46EA             ; ------------------------------------------------
2126   46EA             ; Esperar que resposta do cartao seja diferente
2127   46EA             ; de $00
2128   46EA             ; Destroi A, BC
2129   46EA             ; ------------------------------------------------
2130   46EA             WAIT_RESP_NO_00: 
2131   46EA 01 80 00    	ld	bc, 128		; 32768 tentativas
2132   46ED             .loop: 
2133   46ED 3A 00 7B    	ld	a, (SPIDATA)
2134   46F0 B7          	or	a
2135   46F1 C0          	ret	nz		; se resposta for <> $00, sai
2136   46F2 10 F9       	djnz	.loop
2137   46F4 0D          	dec	c
2138   46F5 20 F6       	jr	nz,.loop
2139   46F7 AF          	xor	a		; No error flags and Cy set = timeout
2140   46F8 37          	scf
2141   46F9 C9          	ret
2142   46FA             
2143   46FA             ; ------------------------------------------------
2144   46FA             ; Sets the requested card slot
2145   46FA             ; Input: Target card slot
2146   46FA             ; Output: Cy = No SD card is present
2147   46FA             ;         A: 0=The same card is still present
2148   46FA             ;            1=The card was changed since the last check
2149   46FA             ; ------------------------------------------------
2150   46FA             setaSDAtual: 
2151   46FA F5 C5       	push	af,bc
2152   46FC             ;	ld	a, (SPIDATA)		; Dummy read
2153   46FC DD 7E 02    	ld	a, (ix+WRKAREA.NUMSD)
2154   46FF 32 F0 7F    	ld	(SPICTRL), a
2155   4702             
2156   4702 CD EA 46    	call	WAIT_RESP_NO_00
2157   4705 C1          	pop	bc
2158   4706 38 03       	jr	c,.error
2159   4708 F1          	pop	af
2160   4709 B7          	or	a		; Clear Cy
2161   470A C9          	ret
2162   470B             
2163   470B F1          .error:  pop	af		; Flush the stack
2164   470C AF          	xor	a		; No error flags and Cy set = timeout
2165   470D 37          	scf
2166   470E C9          	ret
2167   470F             
2168   470F             
2169   470F             
2170   470F             ; ------------------------------------------------
2171   470F             ; Grava um bloco de 512 bytes no cartao
2172   470F             ; HL = aponta para o inicio dos dados
2173   470F             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
2174   470F             ; Modifies:  AF, BC, DE, HL, IXL
2175   470F             ; ------------------------------------------------
2176   470F             GravarBloco: 
2177   470F CD 54 46    	call	getCardVer
2178   4712 CC 49 48    	call	z,blocoParaByte		; se for SDV1 coverter blocos para bytes
2179   4715             ;	call	setaSDAtual	; selecionar cartao atual
2180   4715 DD 7E 04    	ld	a, (ix+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
2181   4718 FD 67       	ld	iyh,a		; iyh=Number of blocks
2182   471A 3D          	dec	a
2183   471B CA 74 47    	jp	z,.umBloco	; somente um bloco, gravar usando CMD24
2184   471E             
2185   471E             ; multiplos blocos
2186   471E              IFDEF DEBUG1
2187   471E~            	push	af
2188   471E~            	ld	a,'m'
2189   471E~            	call	PRTCHAR
2190   471E~            	pop	af
2191   471E              ENDIF
2192   471E C5          	push	bc
2193   471F D5          	push	de
2194   4720 3E 77       	ld	a, CMD55	; Multiplos blocos, mandar ACMD23 com total de blocos
2195   4722 CD 6D 46    	call	SD_SEND_CMD_NO_ARGS
2196   4725 3E 57       	ld	a, ACMD23
2197   4727 01 00 00    	ld	bc, 0
2198   472A 51          	ld	d, c
2199   472B DD 5E 04    	ld	e, (ix+WRKAREA.NUMBLOCKS)	; parametro = total de blocos a gravar
2200   472E CD 72 46    	call	SD_SEND_CMD_GET_ERROR
2201   4731 D1          	pop	de
2202   4732 C1          	pop	bc
2203   4733 DA 9E 47    	jp	c,BLKRWERROR	; erro no ACMD23
2204   4736              IFDEF DEBUG1
2205   4736~            	call	PRTDOT
2206   4736              ENDIF
2207   4736 3E 59       	ld	a, CMD25	; comando CMD25 = write multiple blocks
2208   4738 CD 72 46    	call	SD_SEND_CMD_GET_ERROR
2209   473B DA 9E 47    	jp	c,BLKRWERROR	; erro
2210   473E              IFDEF DEBUG1
2211   473E~            	call	PRTDOT
2212   473E              ENDIF
2213   473E             .loop: 
2214   473E 3E FC       	ld	a, $FC		; mandar $FC para indicar que os proximos dados sao
2215   4740 32 00 7B    	ld	(SPIDATA),a	; dados para gravacao
2216   4743             
2217   4743 11 00 7B    	ld	de,SPIDATA
2218   4746 CD 54 4F    	call	RUN_HLPR
2219   4749             
2220   4749 3E FF       	ld	a,$FF		; envia dummy CRC
2221   474B 32 00 7B    	ld	(SPIDATA),a	; Can't be done with ld (SPIDATA),de. It's too fast
2222   474E 32 00 7B    	ld	(SPIDATA),a
2223   4751 CD DD 46    	call	WAIT_RESP_NO_FF	; esperar cartao
2224   4754              IFDEF DEBUG1
2225   4754~            	jp	c,BLKRWERROR.timeout
2226   4754              ELSE
2227   4754 38 6B       	jr	c,BLKRWERROR.timeout
2228   4756              ENDIF
2229   4756 E6 1F       	and	$1F		; testa bits erro
2230   4758 FE 05       	cp	5
2231   475A 37          	scf
2232   475B 20 41       	jr	nz,BLKRWERROR	; resposta errada, informar erro
2233   475D CD EA 46    	call	WAIT_RESP_NO_00	; esperar cartao
2234   4760 38 3C       	jr	c,BLKRWERROR
2235   4762              IFDEF DEBUG1
2236   4762~            	call	PRTDASH
2237   4762              ENDIF
2238   4762 FD 25       	dec	iyh		; Next block
2239   4764 C2 3E 47    	jp	nz,.loop
2240   4767             
2241   4767 2A 00 7B    	ld	hl, (SPIDATA)	; acabou os blocos, fazer 2 dummy reads
2242   476A 3E FD       	ld	a, $FD		; enviar $FD para informar ao cartao que acabou os dados
2243   476C 32 00 7B    	ld	(SPIDATA),a
2244   476F 2A 00 7B    	ld	hl,(SPIDATA)	; 2 dummy reads
2245   4772             ;	call	WAIT_RESP_NO_00	; esperar cartao
2246   4772 18 26       	jr	.end		; CMD25 finished without error 
2247   4774             
2248   4774             .umBloco: 
2249   4774              IFDEF DEBUG1
2250   4774~            	push	af
2251   4774~            	ld	a,'s'
2252   4774~            	call	PRTCHAR
2253   4774~            	pop	af
2254   4774              ENDIF
2255   4774 3E 58       	ld	a, CMD24	; gravar somente um bloco com comando CMD24 = Write Single Block
2256   4776 CD 72 46    	call	SD_SEND_CMD_GET_ERROR
2257   4779 38 23       	jr	c,BLKRWERROR	; erro
2258   477B             
2259   477B              IFDEF DEBUG1
2260   477B~            	call	PRTDOT
2261   477B              ENDIF
2262   477B 3E FE       	ld	a, $FE		; mandar $FE para indicar que vamos mandar dados para gravacao
2263   477D 32 00 7B    	ld	(SPIDATA),a
2264   4780             
2265   4780 11 00 7B    	ld	de,SPIDATA
2266   4783 CD 54 4F    	call	RUN_HLPR
2267   4786             
2268   4786 3E FF       	ld	a,$FF		; envia dummy CRC
2269   4788 32 00 7B    	ld	(SPIDATA),a	; Can't be done with ld (SPIDATA),de. It's too fast
2270   478B 32 00 7B    	ld	(SPIDATA),a
2271   478E             
2272   478E CD DD 46    	call	WAIT_RESP_NO_FF	; esperar cartao
2273   4791 38 2E       	jr	c,BLKRWERROR.timeout
2274   4793 E6 1F       	and	$1F		; testa bits erro
2275   4795 FE 05       	cp	5
2276   4797 37          	scf
2277   4798 20 04       	jr	nz,BLKRWERROR	; resposta errada, informar erro
2278   479A             ;	call	WAIT_RESP_NO_00	; esperar cartao
2279   479A             .end
2280   479A              
2281   479A AF          	xor	a		; No errors to report
2282   479B C3 48 46    	jp	disableSDs
2283   479E             
2284   479E             
2285   479E             
2286   479E             BLKRWERROR: 	; Block R/W error
2287   479E F5          	push	af
2288   479F 3E 4C       	ld	a,CMD12		; Abort the current command 
2289   47A1 CD 6D 46    	call	SD_SEND_CMD_NO_ARGS
2290   47A4 F1          	pop	af
2291   47A5 0F          	rrca			; In idle state?
2292   47A6 1E FC       	ld	e,ENRDY
2293   47A8 D8          	ret	c
2294   47A9 0F          	rrca			; Erase reset?
2295   47AA 1E FE       	ld	e,EWRERR
2296   47AC D8          	ret	c
2297   47AD 0F          	rrca			; Illegal command?
2298   47AE 1E FF       	ld	e,ENCOMP
2299   47B0 D8          	ret	c
2300   47B1 0F          	rrca			; Communication CRC error?
2301   47B2 1E FA       	ld	e,EDATA
2302   47B4 D8          	ret	c
2303   47B5 0F          	rrca			; Erase sequence error?
2304   47B6 1E FE       	ld	e,EWRERR
2305   47B8 D8          	ret	c
2306   47B9 0F          	rrca			; Address error?
2307   47BA 1E F3       	ld	e,ESEEK
2308   47BC D8          	ret	c
2309   47BD 0F          	rrca			; Parameter error?
2310   47BE 1E F9       	ld	e,ERNF
2311   47C0 D8          	ret	c
2312   47C1             .timeout: 
2313   47C1              IFDEF DEBUG1
2314   47C1~            	ld	a,'t'
2315   47C1~            	call	PRTCHAR
2316   47C1              ENDIF
2317   47C1 1E FC       	ld	e,ENRDY		; Timeout error
2318   47C3 37          	scf
2319   47C4 C3 48 46    	jp	disableSDs
2320   47C7             
2321   47C7             
2322   47C7             ; ------------------------------------------------
2323   47C7             ; Ler um bloco de 512 bytes do cartao
2324   47C7             ; HL =  aponta para o inicio dos dados
2325   47C7             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
2326   47C7             ; Destroi AF, BC, DE, HL, IXL
2327   47C7             ; ------------------------------------------------
2328   47C7             LerBloco: 
2329   47C7 CD 54 46    	call	getCardVer
2330   47CA CC 49 48    	call	z,blocoParaByte	; se for SDV1 coverter blocos para bytes
2331   47CD             ;	call	setaSDAtual
2332   47CD             
2333   47CD DD 7E 04    	ld	a, (ix+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
2334   47D0 FD 67       	ld	iyh,a		; iyh=Number of blocks
2335   47D2 3D          	dec	a
2336   47D3 CA F8 47    	jp	z,.umBloco	; only one block
2337   47D6             
2338   47D6             ; multiplos blocos
2339   47D6              IFDEF DEBUG2
2340   47D6~            	ld	a,'m'
2341   47D6~            	call	PRTCHAR
2342   47D6              ENDIF
2343   47D6 3E 52       	ld	a, CMD18	; ler multiplos blocos com CMD18 = Read Multiple Blocks
2344   47D8 CD 72 46    	call	SD_SEND_CMD_GET_ERROR
2345   47DB 38 C1       	jr	c,BLKRWERROR
2346   47DD EB          	ex	de,hl		; de=Destination address
2347   47DE             .loop: 
2348   47DE CD CC 46    	call	WAIT_RESP_FE
2349   47E1 38 BB       	jr	c,BLKRWERROR
2350   47E3             
2351   47E3 21 00 7B    	ld	hl,SPIDATA
2352   47E6 CD 54 4F    	call	RUN_HLPR
2353   47E9 2A 00 7B    	ld	hl,(SPIDATA)	; descarta CRC
2354   47EC              IFDEF DEBUG2
2355   47EC~            	call	PRTDOT
2356   47EC              ENDIF
2357   47EC FD 25       	dec	iyh
2358   47EE C2 DE 47    	jp	nz,.loop
2359   47F1 3E 4C       	ld	a, CMD12	; acabou os blocos, mandar CMD12 para cancelar leitura
2360   47F3 CD 6D 46    	call	SD_SEND_CMD_NO_ARGS
2361   47F6 18 16       	jr	.end
2362   47F8             
2363   47F8             .umBloco: 
2364   47F8              IFDEF DEBUG2
2365   47F8~            	ld	a,'s'
2366   47F8~            	call	PRTCHAR
2367   47F8              ENDIF
2368   47F8 3E 51       	ld	a, CMD17	; ler somente um bloco com CMD17 = Read Single Block
2369   47FA CD 72 46    	call	SD_SEND_CMD_GET_ERROR
2370   47FD 38 9F       	jr	c,BLKRWERROR
2371   47FF             
2372   47FF CD CC 46    	call	WAIT_RESP_FE
2373   4802 38 9A       	jr	c,BLKRWERROR
2374   4804 EB          	ex	de,hl
2375   4805             
2376   4805 21 00 7B    	ld	hl,SPIDATA
2377   4808 CD 54 4F    	call	RUN_HLPR
2378   480B 2A 00 7B    	ld	hl, (SPIDATA)	; descarta CRC
2379   480E              IFDEF DEBUG2
2380   480E~            	call	PRTDOT
2381   480E              ENDIF
2382   480E             
2383   480E             .end
2384   480E AF           	xor	a		; No errors to report
2385   480F C3 48 46    	jp	disableSDs
2386   4812             
2387   4812             
2388   4812             
2389   4812             
2390   4812             ; ------------------------------------------------
2391   4812             ; Selects a card slot, check for the hardware card change flag
2392   4812             ; and, if it changed, calls the detection of the new card
2393   4812             ;
2394   4812             ; Obs: It was done this way for software robustness.
2395   4812             ; This way we don't have to rely that Nextor will
2396   4812             ; behave in any expected way, like calling DEV_STATUS
2397   4812             ; before any disk operation.
2398   4812             ; 
2399   4812             ; Input   : A = Card slot (1 or 2)
2400   4812             ; Output  : Cy set in case of a defective card
2401   4812             ;           A = 0: No card is present (Z is also set)
2402   4812             ;               1: A card is present and has not changed since the last check 
2403   4812             ;               2: A card is present and has changed since the last check 
2404   4812             ;           E = DEV_RW error code in case of error
2405   4812             ; Modifies:  BC, DE, HL
2406   4812             
2407   4812             
2408   4812             ; ------------------------------------------------
2409   4812             slctNchkCard: 
2410   4812             	; Sanity check
2411   4812 FE 03       	cp	3
2412   4814 30 2F       	jr	nc,.nocard
2413   4816 A7          	and	a
2414   4817 28 2C       	jr	z,.nocard
2415   4819             	;
2416   4819 DD 77 02    	ld	(ix+WRKAREA.NUMSD),a
2417   481C CD FA 46    	call	setaSDAtual
2418   481F D8          	ret	c
2419   4820             
2420   4820 3A F0 7F    	ld	a,(SPISTATUS)		; Get this card-slot status
2421   4823 CB 4F       	bit	SD_PRESENT,a		; Any card here?
2422   4825 20 1E       	jr	nz,.nocard		; Report that there's no card here
2423   4827 E6 01       	and	SD_M_DSKCHG		; Has the card changed since last time?
2424   4829 20 10       	jr	nz,.cardChanged		; Card has changed, detect it
2425   482B             .tsterror: 
2426   482B DD 7E 03    	ld	a,(ix+WRKAREA.CARDFLAGS) ; check if this card had an error
2427   482E DD A6 02    	and	(ix+WRKAREA.NUMSD)
2428   4831 C4 59 45    	call	nz,detectaCartao	; Card had error, force re-detection
2429   4834 3E 01       	ld	a,1			; A=1: same card
2430   4836 DA 48 46    	jp	c,disableSDs		; Quit on error
2431   4839             ;.sameCard:
2432   4839 B7          	or	a			; Set NZ
2433   483A C9          	ret
2434   483B             
2435   483B             .cardChanged: 
2436   483B CD 59 45    	call	detectaCartao		; Detect the new card 
2437   483E 3E 02       	ld	a,2			; A=2: card changed
2438   4840 DA 48 46    	jp	c,disableSDs		; Quit on error
2439   4843 B7          	or	a			; Set NZ
2440   4844 C9          	ret
2441   4845             
2442   4845             .nocard: 
2443   4845 AF          	xor	a
2444   4846 C3 48 46    	jp	disableSDs
2445   4849             
2446   4849             ; ------------------------------------------------
2447   4849             ; Converte blocos para bytes. Na pratica faz
2448   4849             ; BC DE = (BC DE) * 512
2449   4849             ; ------------------------------------------------
2450   4849             blocoParaByte: 
2451   4849              IFDEF DEBUG2
2452   4849~            	PRTSTR "<Blk2Byte>"
2453   4849              ENDIF
2454   4849 41          	ld	b, c
2455   484A 4A          	ld	c, d
2456   484B 53          	ld	d, e
2457   484C 1E 00       	ld	e, 0
2458   484E CB 22       	sla	d
2459   4850 CB 11       	rl	c
2460   4852 CB 10       	rl	b
2461   4854 C9          	ret
2462   4855             
2463   4855             ; ------------------------------------------------
2464   4855             ; Funcoes utilitarias
2465   4855             ; ------------------------------------------------
2466   4855             
2467   4855             
2468   4855             ; ------------------------------------------------
2469   4855             printString: 
2470   4855             ; Prints an ASCII string that has the last bit7 set
2471   4855             ; Input   : DE = Pointer to the string
2472   4855             ; Modifies: AF, DE, EI 
2473   4855             ; ------------------------------------------------
2474   4855 1A          	ld	a,(de)
2475   4856 07          	rlca
2476   4857 0F          	rrca
2477   4858 CB BF       	res	7,a
2478   485A CD A2 00    	call	CHPUT
2479   485D D8          	ret	c
2480   485E 13          	inc	de
2481   485F 18 F4       	jr	printString
2482   4861             
2483   4861             
2484   4861             ; ------------------------------------------------
2485   4861             HexToAscii: 
2486   4861             ; Converts the byte in A to a text string in hexa
2487   4861             ; on the buffer pointed by HL
2488   4861             ; Modifies: AF, C, HL
2489   4861             ; ------------------------------------------------
2490   4861 4F          	ld	c, a
2491   4862 1F          	rra
2492   4863 1F          	rra
2493   4864 1F          	rra
2494   4865 1F          	rra
2495   4866 CD 6A 48    	call	.conv
2496   4869 79          	ld  	a, c
2497   486A             .conv: 
2498   486A E6 0F       	and	$0F
2499   486C C6 90       	add	$90
2500   486E 27          	daa
2501   486F CE 40       	adc	$40
2502   4871 27          	daa
2503   4872 77          	ld	(hl),a
2504   4873 23          	inc	hl
2505   4874 C9          	ret
2506   4875             
2507   4875             ; ------------------------------------------------
2508   4875             ; Get the Maker Name from the Maker ID
2509   4875             ; Output: DE = Pointer to Manufacturer name
2510   4875             ; ------------------------------------------------
2511   4875             getMakerName: 
2512   4875             ; IF (tblMakerIndex-tblMakerIndex.end < 512)
2513   4875 FE 9F       	cp	(tblMakerIndex.end-tblMakerIndex)/2+1	; > last ID?
2514   4877 30 0E       	jr	nc,.Unknown		; Yes->Unknown maker
2515   4879             ; ENDIF
2516   4879 E5          	push	hl
2517   487A 6F          	ld	l,a
2518   487B 26 00       	ld	h,0
2519   487D 11 8B 48    	ld	de,tblMakerIndex
2520   4880 29          	add	hl,hl
2521   4881 19          	add	hl,de
2522   4882 5E          	ld	e,(hl)
2523   4883 23          	inc	hl
2524   4884 56          	ld	d,(hl)
2525   4885 E1          	pop	hl
2526   4886 C9          	ret
2527   4887             
2528   4887             ; IF (tblMakerIndex-tblMakerIndex.end < 512)
2529   4887             .Unknown: 
2530   4887 11 C7 49    	ld	de,tblMakerNames.idUkn
2531   488A C9          	ret
2532   488B             ; ENDIF
2533   488B             
2534   488B             
2535   488B             tblMakerIndex: 
2536   488B C7 49       	dw	tblMakerNames.idUkn
2537   488D CE 49       	dw	tblMakerNames.idx01
2538   488F D7 49       	dw	tblMakerNames.idx02
2539   4891 DE 49       	dw	tblMakerNames.idx03
2540   4893 E5 49       	dw	tblMakerNames.idx04
2541   4895 C7 49       	dw	tblMakerNames.idUkn
2542   4897 EA 49       	dw	tblMakerNames.idx06
2543   4899              REPT $10-$06
2544   4899 C7 49       >	dw	tblMakerNames.idUkn
2544   489B C7 49       >	dw	tblMakerNames.idUkn
2544   489D C7 49       >	dw	tblMakerNames.idUkn
2544   489F C7 49       >	dw	tblMakerNames.idUkn
2544   48A1 C7 49       >	dw	tblMakerNames.idUkn
2544   48A3 C7 49       >	dw	tblMakerNames.idUkn
2544   48A5 C7 49       >	dw	tblMakerNames.idUkn
2544   48A7 C7 49       >	dw	tblMakerNames.idUkn
2544   48A9 C7 49       >	dw	tblMakerNames.idUkn
2544   48AB C7 49       >	dw	tblMakerNames.idUkn
2546   48AD F1 49       	dw	tblMakerNames.idx11
2547   48AF C7 49       	dw	tblMakerNames.idUkn
2548   48B1 FA 49       	dw	tblMakerNames.idx13
2549   48B3 C7 49       	dw	tblMakerNames.idUkn
2550   48B5 C7 49       	dw	tblMakerNames.idUkn
2551   48B7 C7 49       	dw	tblMakerNames.idUkn
2552   48B9 C7 49       	dw	tblMakerNames.idUkn
2553   48BB 01 4A       	dw	tblMakerNames.idx18
2554   48BD C7 49       	dw	tblMakerNames.idUkn
2555   48BF 09 4A       	dw	tblMakerNames.idx1A
2556   48C1 0C 4A       	dw	tblMakerNames.idx1B
2557   48C3 13 4A       	dw	tblMakerNames.idx1C
2558   48C5 1C 4A       	dw	tblMakerNames.idx1D
2559   48C7 C7 49       	dw	tblMakerNames.idUkn
2560   48C9 21 4A       	dw	tblMakerNames.idx1F
2561   48CB              REPT $26-$1F
2562   48CB C7 49       >	dw	tblMakerNames.idUkn
2562   48CD C7 49       >	dw	tblMakerNames.idUkn
2562   48CF C7 49       >	dw	tblMakerNames.idUkn
2562   48D1 C7 49       >	dw	tblMakerNames.idUkn
2562   48D3 C7 49       >	dw	tblMakerNames.idUkn
2562   48D5 C7 49       >	dw	tblMakerNames.idUkn
2562   48D7 C7 49       >	dw	tblMakerNames.idUkn
2564   48D9 2D 4A       	dw	tblMakerNames.idx27
2565   48DB 33 4A       	dw	tblMakerNames.idx28
2566   48DD              REPT $30-$28
2567   48DD C7 49       >	dw	tblMakerNames.idUkn
2567   48DF C7 49       >	dw	tblMakerNames.idUkn
2567   48E1 C7 49       >	dw	tblMakerNames.idUkn
2567   48E3 C7 49       >	dw	tblMakerNames.idUkn
2567   48E5 C7 49       >	dw	tblMakerNames.idUkn
2567   48E7 C7 49       >	dw	tblMakerNames.idUkn
2567   48E9 C7 49       >	dw	tblMakerNames.idUkn
2567   48EB C7 49       >	dw	tblMakerNames.idUkn
2569   48ED 38 4A       	dw	tblMakerNames.idx31
2570   48EF              REPT $40-$31
2571   48EF C7 49       >	dw	tblMakerNames.idUkn
2571   48F1 C7 49       >	dw	tblMakerNames.idUkn
2571   48F3 C7 49       >	dw	tblMakerNames.idUkn
2571   48F5 C7 49       >	dw	tblMakerNames.idUkn
2571   48F7 C7 49       >	dw	tblMakerNames.idUkn
2571   48F9 C7 49       >	dw	tblMakerNames.idUkn
2571   48FB C7 49       >	dw	tblMakerNames.idUkn
2571   48FD C7 49       >	dw	tblMakerNames.idUkn
2571   48FF C7 49       >	dw	tblMakerNames.idUkn
2571   4901 C7 49       >	dw	tblMakerNames.idUkn
2571   4903 C7 49       >	dw	tblMakerNames.idUkn
2571   4905 C7 49       >	dw	tblMakerNames.idUkn
2571   4907 C7 49       >	dw	tblMakerNames.idUkn
2571   4909 C7 49       >	dw	tblMakerNames.idUkn
2571   490B C7 49       >	dw	tblMakerNames.idUkn
2573   490D 45 4A       	dw	tblMakerNames.idx41
2574   490F              REPT $72-$41
2575   490F C7 49       >	dw	tblMakerNames.idUkn
2575   4911 C7 49       >	dw	tblMakerNames.idUkn
2575   4913 C7 49       >	dw	tblMakerNames.idUkn
2575   4915 C7 49       >	dw	tblMakerNames.idUkn
2575   4917 C7 49       >	dw	tblMakerNames.idUkn
2575   4919 C7 49       >	dw	tblMakerNames.idUkn
2575   491B C7 49       >	dw	tblMakerNames.idUkn
2575   491D C7 49       >	dw	tblMakerNames.idUkn
2575   491F C7 49       >	dw	tblMakerNames.idUkn
2575   4921 C7 49       >	dw	tblMakerNames.idUkn
2575   4923 C7 49       >	dw	tblMakerNames.idUkn
2575   4925 C7 49       >	dw	tblMakerNames.idUkn
2575   4927 C7 49       >	dw	tblMakerNames.idUkn
2575   4929 C7 49       >	dw	tblMakerNames.idUkn
2575   492B C7 49       >	dw	tblMakerNames.idUkn
2575   492D C7 49       >	dw	tblMakerNames.idUkn
2575   492F C7 49       >	dw	tblMakerNames.idUkn
2575   4931 C7 49       >	dw	tblMakerNames.idUkn
2575   4933 C7 49       >	dw	tblMakerNames.idUkn
2575   4935 C7 49       >	dw	tblMakerNames.idUkn
2575   4937 C7 49       >	dw	tblMakerNames.idUkn
2575   4939 C7 49       >	dw	tblMakerNames.idUkn
2575   493B C7 49       >	dw	tblMakerNames.idUkn
2575   493D C7 49       >	dw	tblMakerNames.idUkn
2575   493F C7 49       >	dw	tblMakerNames.idUkn
2575   4941 C7 49       >	dw	tblMakerNames.idUkn
2575   4943 C7 49       >	dw	tblMakerNames.idUkn
2575   4945 C7 49       >	dw	tblMakerNames.idUkn
2575   4947 C7 49       >	dw	tblMakerNames.idUkn
2575   4949 C7 49       >	dw	tblMakerNames.idUkn
2575   494B C7 49       >	dw	tblMakerNames.idUkn
2575   494D C7 49       >	dw	tblMakerNames.idUkn
2575   494F C7 49       >	dw	tblMakerNames.idUkn
2575   4951 C7 49       >	dw	tblMakerNames.idUkn
2575   4953 C7 49       >	dw	tblMakerNames.idUkn
2575   4955 C7 49       >	dw	tblMakerNames.idUkn
2575   4957 C7 49       >	dw	tblMakerNames.idUkn
2575   4959 C7 49       >	dw	tblMakerNames.idUkn
2575   495B C7 49       >	dw	tblMakerNames.idUkn
2575   495D C7 49       >	dw	tblMakerNames.idUkn
2575   495F C7 49       >	dw	tblMakerNames.idUkn
2575   4961 C7 49       >	dw	tblMakerNames.idUkn
2575   4963 C7 49       >	dw	tblMakerNames.idUkn
2575   4965 C7 49       >	dw	tblMakerNames.idUkn
2575   4967 C7 49       >	dw	tblMakerNames.idUkn
2575   4969 C7 49       >	dw	tblMakerNames.idUkn
2575   496B C7 49       >	dw	tblMakerNames.idUkn
2575   496D C7 49       >	dw	tblMakerNames.idUkn
2575   496F C7 49       >	dw	tblMakerNames.idUkn
2577   4971 4D 4A       	dw	tblMakerNames.idx73
2578   4973 55 4A       	dw	tblMakerNames.idx74
2579   4975 C7 49       	dw	tblMakerNames.idUkn
2580   4977 5E 4A       	dw	tblMakerNames.idx76
2581   4979              REPT $81-$76
2582   4979 C7 49       >	dw	tblMakerNames.idUkn
2582   497B C7 49       >	dw	tblMakerNames.idUkn
2582   497D C7 49       >	dw	tblMakerNames.idUkn
2582   497F C7 49       >	dw	tblMakerNames.idUkn
2582   4981 C7 49       >	dw	tblMakerNames.idUkn
2582   4983 C7 49       >	dw	tblMakerNames.idUkn
2582   4985 C7 49       >	dw	tblMakerNames.idUkn
2582   4987 C7 49       >	dw	tblMakerNames.idUkn
2582   4989 C7 49       >	dw	tblMakerNames.idUkn
2582   498B C7 49       >	dw	tblMakerNames.idUkn
2582   498D C7 49       >	dw	tblMakerNames.idUkn
2584   498F 65 4A       	dw	tblMakerNames.idx82
2585   4991              REPT $88-$82
2586   4991 C7 49       >	dw	tblMakerNames.idUkn
2586   4993 C7 49       >	dw	tblMakerNames.idUkn
2586   4995 C7 49       >	dw	tblMakerNames.idUkn
2586   4997 C7 49       >	dw	tblMakerNames.idUkn
2586   4999 C7 49       >	dw	tblMakerNames.idUkn
2586   499B C7 49       >	dw	tblMakerNames.idUkn
2588   499D 69 4A       	dw	tblMakerNames.idx89
2589   499F              REPT $9B-$89
2590   499F C7 49       >	dw	tblMakerNames.idUkn
2590   49A1 C7 49       >	dw	tblMakerNames.idUkn
2590   49A3 C7 49       >	dw	tblMakerNames.idUkn
2590   49A5 C7 49       >	dw	tblMakerNames.idUkn
2590   49A7 C7 49       >	dw	tblMakerNames.idUkn
2590   49A9 C7 49       >	dw	tblMakerNames.idUkn
2590   49AB C7 49       >	dw	tblMakerNames.idUkn
2590   49AD C7 49       >	dw	tblMakerNames.idUkn
2590   49AF C7 49       >	dw	tblMakerNames.idUkn
2590   49B1 C7 49       >	dw	tblMakerNames.idUkn
2590   49B3 C7 49       >	dw	tblMakerNames.idUkn
2590   49B5 C7 49       >	dw	tblMakerNames.idUkn
2590   49B7 C7 49       >	dw	tblMakerNames.idUkn
2590   49B9 C7 49       >	dw	tblMakerNames.idUkn
2590   49BB C7 49       >	dw	tblMakerNames.idUkn
2590   49BD C7 49       >	dw	tblMakerNames.idUkn
2590   49BF C7 49       >	dw	tblMakerNames.idUkn
2590   49C1 C7 49       >	dw	tblMakerNames.idUkn
2592   49C3 6F 4A       	dw	tblMakerNames.idx9C
2593   49C5 78 4A       	dw	tblMakerNames.end
2594   49C7             .end
2595   49C7              
2596   49C7             
2597   49C7             
2598   49C7             
2599   49C7             tblMakerNames: 
2600   49C7             .idUkn: 	ABYTEC 0 	"Unknown"
2600   49C7 556E6B6E6F77EE
2601   49CE             .idx01: 	ABYTEC 0 	"Panasonic"
2601   49CE 50616E61736F6E69E3
2602   49D7             .idx02: 	ABYTEC 0 	"Toshiba"
2602   49D7 546F73686962E1
2603   49DE             .idx03:  ABYTEC 0 	"SanDisk"
2603   49DE 53616E446973EB
2604   49E5 534D492DD3  .idx04:  ABYTEC 0 	"SMI-S"
2605   49EA             .idx06:  ABYTEC 0 	"Renesas"
2605   49EA 52656E657361F3
2606   49F1             .idx11:  ABYTEC 0 	"Dane-Elec"
2606   49F1 44616E652D456C65E3
2607   49FA             .idx13:  ABYTEC 0 	"KingMax"
2607   49FA 4B696E674D61F8
2608   4A01             .idx18:  ABYTEC 0 	"Infineon"
2608   4A01 496E66696E656FEE
2609   4A09 50 51 C9    .idx1A:  ABYTEC 0 	"PQI"
2610   4A0C             .idx1B:  ABYTEC 0 	"Samsung"
2610   4A0C 53616D73756EE7
2611   4A13             .idx1C:  ABYTEC 0 	"Transcend"
2611   4A13 5472616E7363656EE4
2612   4A1C 41444154C1  .idx1D:  ABYTEC 0 	"ADATA"
2613   4A21             .idx1F:  ABYTEC 0 	"SiliconPower"
2613   4A21 53696C69636F6E506F7765F2
2614   4A2D             .idx27:  ABYTEC 0 	"Phison"
2614   4A2D 506869736FEE
2615   4A33 4C657861F2  .idx28:  ABYTEC 0 	"Lexar"
2616   4A38             .idx31:  ABYTEC 0 	"Silicon Power"
2616   4A38 53696C69636F6E20506F7765F2
2617   4A45             .idx41:  ABYTEC 0 	"Kingston"
2617   4A45 4B696E6773746FEE
2618   4A4D             .idx73:  ABYTEC 0 	"SilverHT"
2618   4A4D 53696C76657248D4
2619   4A55             .idx74:  ABYTEC 0 	"Transcend"
2619   4A55 5472616E7363656EE4
2620   4A5E             .idx76:  ABYTEC 0 	"Patriot"
2620   4A5E 50617472696FF4
2621   4A65 53 6F 6E F9 .idx82:  ABYTEC 0 	"Sony"
2622   4A69             .idx89:  ABYTEC 0 	"L.Data"
2622   4A69 4C2E446174E1
2623   4A6F             .idx9C:  ABYTEC 0 	"Angelbird"
2623   4A6F 416E67656C626972E4
2624   4A78             .end
2625   4A78              
2626   4A78             
2627   4A78             
2628   4A78             
2629   4A78             ; ------------------------------------------------
2630   4A78             ; Restore screen parameters on MSX>=2 if they're
2631   4A78             ; not set yet
2632   4A78             ; ------------------------------------------------
2633   4A78             MYSETSCR: 
2634   4A78 3A 2D 00    	ld	a,(MSXVER)
2635   4A7B B7          	or	a			; MSX1?
2636   4A7C 20 08       	jr	nz,.notMSX1		; No, skip
2637   4A7E             .MSX1: 
2638   4A7E 3A AF FC    	ld	a,(SCRMOD)
2639   4A81 B7          	or	a			; SCREEN0 already?
2640   4A82 C8          	ret	z			; Yes, quit
2641   4A83 C3 6C 00    	jp	INITXT			; set screen0
2642   4A86             
2643   4A86             .notMSX1: 
2644   4A86 0E 23       	ld	c,$23			; Block-2, R#3
2645   4A88 DD 21 F5 01 	ld 	ix,REDCLK
2646   4A8C CD 5F 01    	call	EXTROM
2647   4A8F E6 01       	and	1
2648   4A91 47          	ld	b,a
2649   4A92 3A AF FC    	ld	a,(SCRMOD)
2650   4A95 B8          	cp	b
2651   4A96 20 1C       	jr	nz,.restore
2652   4A98 0C          	inc	c
2653   4A99 DD 21 F5 01 	ld 	ix,REDCLK
2654   4A9D CD 5F 01    	call	EXTROM
2655   4AA0 47          	ld	b,a
2656   4AA1 0C          	inc	c
2657   4AA2 DD 21 F5 01 	ld 	ix,REDCLK
2658   4AA6 CD 5F 01    	call	EXTROM
2659   4AA9 87          	add	a
2660   4AAA 87          	add	a
2661   4AAB 87          	add	a
2662   4AAC 87          	add	a
2663   4AAD B0          	or	b
2664   4AAE 47          	ld	b,a
2665   4AAF 3A B0 F3    	ld	a,(LINLEN)
2666   4AB2 B8          	cp	b
2667   4AB3 C8          	ret	z
2668   4AB4             .restore: 
2669   4AB4 AF          	xor	a		; Don't displat the function keys
2670   4AB5 DD 21 85 01 	ld	ix,SDFSCR
2671   4AB9 C3 5F 01    	jp	EXTROM
2672   4ABC             
2673   4ABC             ; ------------------------------------------------
2674   4ABC             ; Check if the STOP key was signaled on DRV_INIT
2675   4ABC             ; ------------------------------------------------
2676   4ABC             INICHKSTOP: 
2677   4ABC 3A 9B FC    	ld	a,(INTFLG)
2678   4ABF FE 04       	cp	4			; Was STOP pressed?
2679   4AC1 C0          	ret	nz			; No, quit as fast as possible 
2680   4AC2             
2681   4AC2             	; Handle STOP to pause and read messages, and ask for the copyright info
2682   4AC2 11 89 4F    	ld	de,strBootpaused
2683   4AC5 CD 55 48    	call	printString
2684   4AC8 3E 07       .wait1: 	ld	a,7
2685   4ACA CD 41 01    	call	SNSMAT
2686   4ACD E6 10       	and	$10			; Is STOP still pressed?
2687   4ACF 28 F7       	jr	z,.wait1		; Wait for STOP to be released
2688   4AD1 AF          	xor	a
2689   4AD2 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2690   4AD5 06 00       	ld	b,0			; b=inhibit 'i' key flag
2691   4AD7 CD 9C 00    .wait2:  call	CHSNS
2692   4ADA C4 F7 4A    	call	nz,.chkikey		; Wait until a key is pressed
2693   4ADD 3A 9B FC    	ld	a,(INTFLG)
2694   4AE0 FE 04       	cp	4			; Was STOP pressed?
2695   4AE2 20 F3       	jr	nz,.wait2		; No, return
2696   4AE4 AF          	xor	a
2697   4AE5 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2698   4AE8 CD 56 01    	call	KILBUF
2699   4AEB 06 1E       	ld	b,30			; Since the user is trying pause the
2700   4AED 76          .wait3: 	halt				; boot messages, this gives him enough
2701   4AEE             					; time to react and pause the next
2702   4AEE             					; driver
2703   4AEE 3A 9B FC    	ld	a,(INTFLG)
2704   4AF1 FE 04       	cp	4			; Was STOP pressed?
2705   4AF3 C8          	ret	z			; quit so the next driver can process it
2706   4AF4 10 F7       	djnz	.wait3			; The user will have the impression
2707   4AF6             					; that he has a perfect timing.   ;)
2708   4AF6 C9          	ret
2709   4AF7             
2710   4AF7             .chkikey: 
2711   4AF7 CB 40       	bit	0,b			; Was the copyright message shown?
2712   4AF9 C0          	ret	nz			; Yes, return
2713   4AFA CD 9F 00    	call	CHGET
2714   4AFD FE 69       	cp	'i'
2715   4AFF 28 03       	jr	z,.showcopyright
2716   4B01 FE 49       	cp	'I'
2717   4B03 C0          	ret	nz
2718   4B04             .showcopyright: 
2719   4B04 04          	inc	b			; Inhibit further presses of the i key 
2720   4B05 11 B3 4F    	ld	de,strCopyright
2721   4B08 C3 55 48    	jp	printString
2722   4B0B             
2723   4B0B             
2724   4B0B             ; ------------------------------------------------
2725   4B0B             STR_SANITIZE: 
2726   4B0B             ; Sanitize a string before it is sent to Nextor
2727   4B0B             ; Input   : HL = Pointer to the string
2728   4B0B             ;            B = string size
2729   4B0B             ; Output  :  B = string size
2730   4B0B             ;         : DE = Pointer to the end of the buffer
2731   4B0B             ; Modifies:  A, C
2732   4B0B             ; ------------------------------------------------
2733   4B0B 0E 00       	ld	c,0			; Flag to test if the string only has spaces
2734   4B0D C5 E5       	push	bc,hl
2735   4B0F             .loop1: 
2736   4B0F 7E          	ld	a,(hl)
2737   4B10 FE 20       	cp	32
2738   4B12 28 0A       	jr	z,.next
2739   4B14 0E 01       	ld	c,1
2740   4B16 DC 34 4B    	call	c,.invChar
2741   4B19 FE 7F       	cp	127
2742   4B1B D4 34 4B    	call	nc,.invChar
2743   4B1E 23          .next: 	inc	hl
2744   4B1F 10 EE       	djnz	.loop1
2745   4B21 E1          	pop	hl
2746   4B22 79          	ld	a,c
2747   4B23 C1          	pop	bc
2748   4B24 B7          	or	a			; Has chars other than only spaces?
2749   4B25 C0          	ret	nz			; Yes, quit
2750   4B26             	; Copy <null> to the buffer
2751   4B26 D5          	push	de
2752   4B27 EB          	ex	de,hl			; de=Pointer to the string
2753   4B28 21 B9 50    	ld	hl,nullTxt
2754   4B2B 01 06 00    	ld	bc,nullTxt.end-nullTxt
2755   4B2E ED B0       	ldir
2756   4B30 C1          	pop	bc			; Discard the old pointe position
2757   4B31 06 06       	ld	b,nullTxt.end-nullTxt
2758   4B33 C9          	ret
2759   4B34             
2760   4B34             .invChar: 				; Replace an invalid char
2761   4B34 36 5F       	ld	(hl),'_'
2762   4B36 C9          	ret
2763   4B37             
2764   4B37             
2765   4B37             ; ------------------------------------------------
2766   4B37             INSTR800HLP: 
2767   4B37             ; Install the R800 data transfer helper routine on extra WorkArea 
2768   4B37             ; ------------------------------------------------
2769   4B37 3A 2D 00    	ld	a,(MSXVER)
2770   4B3A FE 03       	cp	3		; MSX Turbo-R?
2771   4B3C D8          	ret	c		; No, return
2772   4B3D CD 62 4F    	call	GTR800LDIR
2773   4B40 D9          	exx
2774   4B41 EB          	ex	de,hl
2775   4B42 21 4B 4B    	ld	hl,R800DATHLP
2776   4B45 01 07 00    	ld	bc,R800DATHLP.end-R800DATHLP
2777   4B48 ED B0       	ldir
2778   4B4A C9          	ret
2779   4B4B             
2780   4B4B             ; ------------------------------------------------
2781   4B4B             ; R800 optimized data transfer routine, copied to the extra WorkArea
2782   4B4B             ; ------------------------------------------------
2783   4B4B             R800DATHLP: 
2784   4B4B D9          	exx
2785   4B4C 01 00 02    	ld	bc,512
2786   4B4F ED B0       	ldir
2787   4B51 C9          	ret
2788   4B52             .end
2789   4B52              
2790   4B52             
2791   4B52             ; ------------------------------------------------
2792   4B52             ; Z80 optimized data transfer routine, kept in ROM 
2793   4B52             ; ------------------------------------------------
2794   4B52             LDI512: 	; Z80 optimized 512 byte transfer
2795   4B52 D9          	exx
2796   4B53 ED A0       > ldi
2796   4B55 ED A0       > ldi
2796   4B57 ED A0       > ldi
2796   4B59 ED A0       > ldi
2796   4B5B ED A0       > ldi
2796   4B5D ED A0       > ldi
2796   4B5F ED A0       > ldi
2796   4B61 ED A0       > ldi
2796   4B63 ED A0       > ldi
2796   4B65 ED A0       > ldi
2796   4B67 ED A0       > ldi
2796   4B69 ED A0       > ldi
2796   4B6B ED A0       > ldi
2796   4B6D ED A0       > ldi
2796   4B6F ED A0       > ldi
2796   4B71 ED A0       > ldi
2796   4B73 ED A0       > ldi
2796   4B75 ED A0       > ldi
2796   4B77 ED A0       > ldi
2796   4B79 ED A0       > ldi
2796   4B7B ED A0       > ldi
2796   4B7D ED A0       > ldi
2796   4B7F ED A0       > ldi
2796   4B81 ED A0       > ldi
2796   4B83 ED A0       > ldi
2796   4B85 ED A0       > ldi
2796   4B87 ED A0       > ldi
2796   4B89 ED A0       > ldi
2796   4B8B ED A0       > ldi
2796   4B8D ED A0       > ldi
2796   4B8F ED A0       > ldi
2796   4B91 ED A0       > ldi
2796   4B93 ED A0       > ldi
2796   4B95 ED A0       > ldi
2796   4B97 ED A0       > ldi
2796   4B99 ED A0       > ldi
2796   4B9B ED A0       > ldi
2796   4B9D ED A0       > ldi
2796   4B9F ED A0       > ldi
2796   4BA1 ED A0       > ldi
2796   4BA3 ED A0       > ldi
2796   4BA5 ED A0       > ldi
2796   4BA7 ED A0       > ldi
2796   4BA9 ED A0       > ldi
2796   4BAB ED A0       > ldi
2796   4BAD ED A0       > ldi
2796   4BAF ED A0       > ldi
2796   4BB1 ED A0       > ldi
2796   4BB3 ED A0       > ldi
2796   4BB5 ED A0       > ldi
2796   4BB7 ED A0       > ldi
2796   4BB9 ED A0       > ldi
2796   4BBB ED A0       > ldi
2796   4BBD ED A0       > ldi
2796   4BBF ED A0       > ldi
2796   4BC1 ED A0       > ldi
2796   4BC3 ED A0       > ldi
2796   4BC5 ED A0       > ldi
2796   4BC7 ED A0       > ldi
2796   4BC9 ED A0       > ldi
2796   4BCB ED A0       > ldi
2796   4BCD ED A0       > ldi
2796   4BCF ED A0       > ldi
2796   4BD1 ED A0       > ldi
2796   4BD3 ED A0       > ldi
2796   4BD5 ED A0       > ldi
2796   4BD7 ED A0       > ldi
2796   4BD9 ED A0       > ldi
2796   4BDB ED A0       > ldi
2796   4BDD ED A0       > ldi
2796   4BDF ED A0       > ldi
2796   4BE1 ED A0       > ldi
2796   4BE3 ED A0       > ldi
2796   4BE5 ED A0       > ldi
2796   4BE7 ED A0       > ldi
2796   4BE9 ED A0       > ldi
2796   4BEB ED A0       > ldi
2796   4BED ED A0       > ldi
2796   4BEF ED A0       > ldi
2796   4BF1 ED A0       > ldi
2796   4BF3 ED A0       > ldi
2796   4BF5 ED A0       > ldi
2796   4BF7 ED A0       > ldi
2796   4BF9 ED A0       > ldi
2796   4BFB ED A0       > ldi
2796   4BFD ED A0       > ldi
2796   4BFF ED A0       > ldi
2796   4C01 ED A0       > ldi
2796   4C03 ED A0       > ldi
2796   4C05 ED A0       > ldi
2796   4C07 ED A0       > ldi
2796   4C09 ED A0       > ldi
2796   4C0B ED A0       > ldi
2796   4C0D ED A0       > ldi
2796   4C0F ED A0       > ldi
2796   4C11 ED A0       > ldi
2796   4C13 ED A0       > ldi
2796   4C15 ED A0       > ldi
2796   4C17 ED A0       > ldi
2796   4C19 ED A0       > ldi
2796   4C1B ED A0       > ldi
2796   4C1D ED A0       > ldi
2796   4C1F ED A0       > ldi
2796   4C21 ED A0       > ldi
2796   4C23 ED A0       > ldi
2796   4C25 ED A0       > ldi
2796   4C27 ED A0       > ldi
2796   4C29 ED A0       > ldi
2796   4C2B ED A0       > ldi
2796   4C2D ED A0       > ldi
2796   4C2F ED A0       > ldi
2796   4C31 ED A0       > ldi
2796   4C33 ED A0       > ldi
2796   4C35 ED A0       > ldi
2796   4C37 ED A0       > ldi
2796   4C39 ED A0       > ldi
2796   4C3B ED A0       > ldi
2796   4C3D ED A0       > ldi
2796   4C3F ED A0       > ldi
2796   4C41 ED A0       > ldi
2796   4C43 ED A0       > ldi
2796   4C45 ED A0       > ldi
2796   4C47 ED A0       > ldi
2796   4C49 ED A0       > ldi
2796   4C4B ED A0       > ldi
2796   4C4D ED A0       > ldi
2796   4C4F ED A0       > ldi
2796   4C51 ED A0       > ldi
2796   4C53 ED A0       > ldi
2796   4C55 ED A0       > ldi
2796   4C57 ED A0       > ldi
2796   4C59 ED A0       > ldi
2796   4C5B ED A0       > ldi
2796   4C5D ED A0       > ldi
2796   4C5F ED A0       > ldi
2796   4C61 ED A0       > ldi
2796   4C63 ED A0       > ldi
2796   4C65 ED A0       > ldi
2796   4C67 ED A0       > ldi
2796   4C69 ED A0       > ldi
2796   4C6B ED A0       > ldi
2796   4C6D ED A0       > ldi
2796   4C6F ED A0       > ldi
2796   4C71 ED A0       > ldi
2796   4C73 ED A0       > ldi
2796   4C75 ED A0       > ldi
2796   4C77 ED A0       > ldi
2796   4C79 ED A0       > ldi
2796   4C7B ED A0       > ldi
2796   4C7D ED A0       > ldi
2796   4C7F ED A0       > ldi
2796   4C81 ED A0       > ldi
2796   4C83 ED A0       > ldi
2796   4C85 ED A0       > ldi
2796   4C87 ED A0       > ldi
2796   4C89 ED A0       > ldi
2796   4C8B ED A0       > ldi
2796   4C8D ED A0       > ldi
2796   4C8F ED A0       > ldi
2796   4C91 ED A0       > ldi
2796   4C93 ED A0       > ldi
2796   4C95 ED A0       > ldi
2796   4C97 ED A0       > ldi
2796   4C99 ED A0       > ldi
2796   4C9B ED A0       > ldi
2796   4C9D ED A0       > ldi
2796   4C9F ED A0       > ldi
2796   4CA1 ED A0       > ldi
2796   4CA3 ED A0       > ldi
2796   4CA5 ED A0       > ldi
2796   4CA7 ED A0       > ldi
2796   4CA9 ED A0       > ldi
2796   4CAB ED A0       > ldi
2796   4CAD ED A0       > ldi
2796   4CAF ED A0       > ldi
2796   4CB1 ED A0       > ldi
2796   4CB3 ED A0       > ldi
2796   4CB5 ED A0       > ldi
2796   4CB7 ED A0       > ldi
2796   4CB9 ED A0       > ldi
2796   4CBB ED A0       > ldi
2796   4CBD ED A0       > ldi
2796   4CBF ED A0       > ldi
2796   4CC1 ED A0       > ldi
2796   4CC3 ED A0       > ldi
2796   4CC5 ED A0       > ldi
2796   4CC7 ED A0       > ldi
2796   4CC9 ED A0       > ldi
2796   4CCB ED A0       > ldi
2796   4CCD ED A0       > ldi
2796   4CCF ED A0       > ldi
2796   4CD1 ED A0       > ldi
2796   4CD3 ED A0       > ldi
2796   4CD5 ED A0       > ldi
2796   4CD7 ED A0       > ldi
2796   4CD9 ED A0       > ldi
2796   4CDB ED A0       > ldi
2796   4CDD ED A0       > ldi
2796   4CDF ED A0       > ldi
2796   4CE1 ED A0       > ldi
2796   4CE3 ED A0       > ldi
2796   4CE5 ED A0       > ldi
2796   4CE7 ED A0       > ldi
2796   4CE9 ED A0       > ldi
2796   4CEB ED A0       > ldi
2796   4CED ED A0       > ldi
2796   4CEF ED A0       > ldi
2796   4CF1 ED A0       > ldi
2796   4CF3 ED A0       > ldi
2796   4CF5 ED A0       > ldi
2796   4CF7 ED A0       > ldi
2796   4CF9 ED A0       > ldi
2796   4CFB ED A0       > ldi
2796   4CFD ED A0       > ldi
2796   4CFF ED A0       > ldi
2796   4D01 ED A0       > ldi
2796   4D03 ED A0       > ldi
2796   4D05 ED A0       > ldi
2796   4D07 ED A0       > ldi
2796   4D09 ED A0       > ldi
2796   4D0B ED A0       > ldi
2796   4D0D ED A0       > ldi
2796   4D0F ED A0       > ldi
2796   4D11 ED A0       > ldi
2796   4D13 ED A0       > ldi
2796   4D15 ED A0       > ldi
2796   4D17 ED A0       > ldi
2796   4D19 ED A0       > ldi
2796   4D1B ED A0       > ldi
2796   4D1D ED A0       > ldi
2796   4D1F ED A0       > ldi
2796   4D21 ED A0       > ldi
2796   4D23 ED A0       > ldi
2796   4D25 ED A0       > ldi
2796   4D27 ED A0       > ldi
2796   4D29 ED A0       > ldi
2796   4D2B ED A0       > ldi
2796   4D2D ED A0       > ldi
2796   4D2F ED A0       > ldi
2796   4D31 ED A0       > ldi
2796   4D33 ED A0       > ldi
2796   4D35 ED A0       > ldi
2796   4D37 ED A0       > ldi
2796   4D39 ED A0       > ldi
2796   4D3B ED A0       > ldi
2796   4D3D ED A0       > ldi
2796   4D3F ED A0       > ldi
2796   4D41 ED A0       > ldi
2796   4D43 ED A0       > ldi
2796   4D45 ED A0       > ldi
2796   4D47 ED A0       > ldi
2796   4D49 ED A0       > ldi
2796   4D4B ED A0       > ldi
2796   4D4D ED A0       > ldi
2796   4D4F ED A0       > ldi
2796   4D51 ED A0       > ldi
2796   4D53 ED A0       > ldi
2796   4D55 ED A0       > ldi
2796   4D57 ED A0       > ldi
2796   4D59 ED A0       > ldi
2796   4D5B ED A0       > ldi
2796   4D5D ED A0       > ldi
2796   4D5F ED A0       > ldi
2796   4D61 ED A0       > ldi
2796   4D63 ED A0       > ldi
2796   4D65 ED A0       > ldi
2796   4D67 ED A0       > ldi
2796   4D69 ED A0       > ldi
2796   4D6B ED A0       > ldi
2796   4D6D ED A0       > ldi
2796   4D6F ED A0       > ldi
2796   4D71 ED A0       > ldi
2796   4D73 ED A0       > ldi
2796   4D75 ED A0       > ldi
2796   4D77 ED A0       > ldi
2796   4D79 ED A0       > ldi
2796   4D7B ED A0       > ldi
2796   4D7D ED A0       > ldi
2796   4D7F ED A0       > ldi
2796   4D81 ED A0       > ldi
2796   4D83 ED A0       > ldi
2796   4D85 ED A0       > ldi
2796   4D87 ED A0       > ldi
2796   4D89 ED A0       > ldi
2796   4D8B ED A0       > ldi
2796   4D8D ED A0       > ldi
2796   4D8F ED A0       > ldi
2796   4D91 ED A0       > ldi
2796   4D93 ED A0       > ldi
2796   4D95 ED A0       > ldi
2796   4D97 ED A0       > ldi
2796   4D99 ED A0       > ldi
2796   4D9B ED A0       > ldi
2796   4D9D ED A0       > ldi
2796   4D9F ED A0       > ldi
2796   4DA1 ED A0       > ldi
2796   4DA3 ED A0       > ldi
2796   4DA5 ED A0       > ldi
2796   4DA7 ED A0       > ldi
2796   4DA9 ED A0       > ldi
2796   4DAB ED A0       > ldi
2796   4DAD ED A0       > ldi
2796   4DAF ED A0       > ldi
2796   4DB1 ED A0       > ldi
2796   4DB3 ED A0       > ldi
2796   4DB5 ED A0       > ldi
2796   4DB7 ED A0       > ldi
2796   4DB9 ED A0       > ldi
2796   4DBB ED A0       > ldi
2796   4DBD ED A0       > ldi
2796   4DBF ED A0       > ldi
2796   4DC1 ED A0       > ldi
2796   4DC3 ED A0       > ldi
2796   4DC5 ED A0       > ldi
2796   4DC7 ED A0       > ldi
2796   4DC9 ED A0       > ldi
2796   4DCB ED A0       > ldi
2796   4DCD ED A0       > ldi
2796   4DCF ED A0       > ldi
2796   4DD1 ED A0       > ldi
2796   4DD3 ED A0       > ldi
2796   4DD5 ED A0       > ldi
2796   4DD7 ED A0       > ldi
2796   4DD9 ED A0       > ldi
2796   4DDB ED A0       > ldi
2796   4DDD ED A0       > ldi
2796   4DDF ED A0       > ldi
2796   4DE1 ED A0       > ldi
2796   4DE3 ED A0       > ldi
2796   4DE5 ED A0       > ldi
2796   4DE7 ED A0       > ldi
2796   4DE9 ED A0       > ldi
2796   4DEB ED A0       > ldi
2796   4DED ED A0       > ldi
2796   4DEF ED A0       > ldi
2796   4DF1 ED A0       > ldi
2796   4DF3 ED A0       > ldi
2796   4DF5 ED A0       > ldi
2796   4DF7 ED A0       > ldi
2796   4DF9 ED A0       > ldi
2796   4DFB ED A0       > ldi
2796   4DFD ED A0       > ldi
2796   4DFF ED A0       > ldi
2796   4E01 ED A0       > ldi
2796   4E03 ED A0       > ldi
2796   4E05 ED A0       > ldi
2796   4E07 ED A0       > ldi
2796   4E09 ED A0       > ldi
2796   4E0B ED A0       > ldi
2796   4E0D ED A0       > ldi
2796   4E0F ED A0       > ldi
2796   4E11 ED A0       > ldi
2796   4E13 ED A0       > ldi
2796   4E15 ED A0       > ldi
2796   4E17 ED A0       > ldi
2796   4E19 ED A0       > ldi
2796   4E1B ED A0       > ldi
2796   4E1D ED A0       > ldi
2796   4E1F ED A0       > ldi
2796   4E21 ED A0       > ldi
2796   4E23 ED A0       > ldi
2796   4E25 ED A0       > ldi
2796   4E27 ED A0       > ldi
2796   4E29 ED A0       > ldi
2796   4E2B ED A0       > ldi
2796   4E2D ED A0       > ldi
2796   4E2F ED A0       > ldi
2796   4E31 ED A0       > ldi
2796   4E33 ED A0       > ldi
2796   4E35 ED A0       > ldi
2796   4E37 ED A0       > ldi
2796   4E39 ED A0       > ldi
2796   4E3B ED A0       > ldi
2796   4E3D ED A0       > ldi
2796   4E3F ED A0       > ldi
2796   4E41 ED A0       > ldi
2796   4E43 ED A0       > ldi
2796   4E45 ED A0       > ldi
2796   4E47 ED A0       > ldi
2796   4E49 ED A0       > ldi
2796   4E4B ED A0       > ldi
2796   4E4D ED A0       > ldi
2796   4E4F ED A0       > ldi
2796   4E51 ED A0       > ldi
2796   4E53 ED A0       > ldi
2796   4E55 ED A0       > ldi
2796   4E57 ED A0       > ldi
2796   4E59 ED A0       > ldi
2796   4E5B ED A0       > ldi
2796   4E5D ED A0       > ldi
2796   4E5F ED A0       > ldi
2796   4E61 ED A0       > ldi
2796   4E63 ED A0       > ldi
2796   4E65 ED A0       > ldi
2796   4E67 ED A0       > ldi
2796   4E69 ED A0       > ldi
2796   4E6B ED A0       > ldi
2796   4E6D ED A0       > ldi
2796   4E6F ED A0       > ldi
2796   4E71 ED A0       > ldi
2796   4E73 ED A0       > ldi
2796   4E75 ED A0       > ldi
2796   4E77 ED A0       > ldi
2796   4E79 ED A0       > ldi
2796   4E7B ED A0       > ldi
2796   4E7D ED A0       > ldi
2796   4E7F ED A0       > ldi
2796   4E81 ED A0       > ldi
2796   4E83 ED A0       > ldi
2796   4E85 ED A0       > ldi
2796   4E87 ED A0       > ldi
2796   4E89 ED A0       > ldi
2796   4E8B ED A0       > ldi
2796   4E8D ED A0       > ldi
2796   4E8F ED A0       > ldi
2796   4E91 ED A0       > ldi
2796   4E93 ED A0       > ldi
2796   4E95 ED A0       > ldi
2796   4E97 ED A0       > ldi
2796   4E99 ED A0       > ldi
2796   4E9B ED A0       > ldi
2796   4E9D ED A0       > ldi
2796   4E9F ED A0       > ldi
2796   4EA1 ED A0       > ldi
2796   4EA3 ED A0       > ldi
2796   4EA5 ED A0       > ldi
2796   4EA7 ED A0       > ldi
2796   4EA9 ED A0       > ldi
2796   4EAB ED A0       > ldi
2796   4EAD ED A0       > ldi
2796   4EAF ED A0       > ldi
2796   4EB1 ED A0       > ldi
2796   4EB3 ED A0       > ldi
2796   4EB5 ED A0       > ldi
2796   4EB7 ED A0       > ldi
2796   4EB9 ED A0       > ldi
2796   4EBB ED A0       > ldi
2796   4EBD ED A0       > ldi
2796   4EBF ED A0       > ldi
2796   4EC1 ED A0       > ldi
2796   4EC3 ED A0       > ldi
2796   4EC5 ED A0       > ldi
2796   4EC7 ED A0       > ldi
2796   4EC9 ED A0       > ldi
2796   4ECB ED A0       > ldi
2796   4ECD ED A0       > ldi
2796   4ECF ED A0       > ldi
2796   4ED1 ED A0       > ldi
2796   4ED3 ED A0       > ldi
2796   4ED5 ED A0       > ldi
2796   4ED7 ED A0       > ldi
2796   4ED9 ED A0       > ldi
2796   4EDB ED A0       > ldi
2796   4EDD ED A0       > ldi
2796   4EDF ED A0       > ldi
2796   4EE1 ED A0       > ldi
2796   4EE3 ED A0       > ldi
2796   4EE5 ED A0       > ldi
2796   4EE7 ED A0       > ldi
2796   4EE9 ED A0       > ldi
2796   4EEB ED A0       > ldi
2796   4EED ED A0       > ldi
2796   4EEF ED A0       > ldi
2796   4EF1 ED A0       > ldi
2796   4EF3 ED A0       > ldi
2796   4EF5 ED A0       > ldi
2796   4EF7 ED A0       > ldi
2796   4EF9 ED A0       > ldi
2796   4EFB ED A0       > ldi
2796   4EFD ED A0       > ldi
2796   4EFF ED A0       > ldi
2796   4F01 ED A0       > ldi
2796   4F03 ED A0       > ldi
2796   4F05 ED A0       > ldi
2796   4F07 ED A0       > ldi
2796   4F09 ED A0       > ldi
2796   4F0B ED A0       > ldi
2796   4F0D ED A0       > ldi
2796   4F0F ED A0       > ldi
2796   4F11 ED A0       > ldi
2796   4F13 ED A0       > ldi
2796   4F15 ED A0       > ldi
2796   4F17 ED A0       > ldi
2796   4F19 ED A0       > ldi
2796   4F1B ED A0       > ldi
2796   4F1D ED A0       > ldi
2796   4F1F ED A0       > ldi
2796   4F21 ED A0       > ldi
2796   4F23 ED A0       > ldi
2796   4F25 ED A0       > ldi
2796   4F27 ED A0       > ldi
2796   4F29 ED A0       > ldi
2796   4F2B ED A0       > ldi
2796   4F2D ED A0       > ldi
2796   4F2F ED A0       > ldi
2796   4F31 ED A0       > ldi
2796   4F33 ED A0       > ldi
2796   4F35 ED A0       > ldi
2796   4F37 ED A0       > ldi
2796   4F39 ED A0       > ldi
2796   4F3B ED A0       > ldi
2796   4F3D ED A0       > ldi
2796   4F3F ED A0       > ldi
2796   4F41 ED A0       > ldi
2796   4F43 ED A0       > ldi
2796   4F45 ED A0       > ldi
2796   4F47 ED A0       > ldi
2796   4F49 ED A0       > ldi
2796   4F4B ED A0       > ldi
2796   4F4D ED A0       > ldi
2796   4F4F ED A0       > ldi
2796   4F51 ED A0       > ldi
2797   4F53 C9          	ret
2798   4F54             
2799   4F54             ; ------------------------------------------------
2800   4F54             ; Jumps to a helper routine, usually in RAM
2801   4F54             ; Input: HL': Address of the target routine
2802   4F54             ; ------------------------------------------------
2803   4F54             RUN_HLPR: 
2804   4F54 D9          	exx
2805   4F55 E9          	jp	(hl)
2806   4F56             
2807   4F56             ; ------------------------------------------------
2808   4F56             ; Setup the arbitrary block size LDIR helper to be used
2809   4F56             ; Input   : none
2810   4F56             ; Output  : HL': Address of the block transfer routine to be used 
2811   4F56             ; Modifies: AF, DE', HL'
2812   4F56             ; ------------------------------------------------
2813   4F56             SETLDIRHLPR: 
2814   4F56 D9          	exx
2815   4F57             	; Check for a Z80 or R800
2816   4F57 AF          	xor	a		; Clear Cy
2817   4F58 3D          	dec	a		; A=#FF
2818   4F59 ED F9       	db	#ED,#F9		; mulub a,a
2819   4F5B 38 05       	jr	c,GTR800LDIR	; Always use LDIR in RAM for the R800
2820   4F5D             
2821   4F5D 21 52 4B    	ld	hl,LDI512
2822   4F60 D9          	exx
2823   4F61 C9          	ret
2824   4F62             
2825   4F62             ; ------------------------------------------------
2826   4F62             ; Obtain the pointer to the R800 data transfer helper routine
2827   4F62             ; Input   : IX=Pointer to the WorkArea on SLTWRK
2828   4F62             ; Output  : HL'=pointer to R800 data transfer helper routine 
2829   4F62             ; Modifies: Does an exx at the end
2830   4F62             ; ------------------------------------------------
2831   4F62             GTR800LDIR: 
2832   4F62 DD 6E 00    	ld	l,(ix+WRKAREA.TRLDIR)
2833   4F65 DD 66 01    	ld	h,(ix+WRKAREA.TRLDIR+1)
2834   4F68 D9          	exx
2835   4F69 C9          	ret
2836   4F6A             
2837   4F6A             
2838   4F6A             
2839   4F6A             ; ------------------------------------------------
2840   4F6A             ; Debugging routines
2841   4F6A             ; ------------------------------------------------
2842   4F6A              IFDEF DEBUG1
2843   4F6A~            PRTCHAR: 
2844   4F6A~            	ex	af,af'
2845   4F6A~            	exx
2846   4F6A~            	push	ix,iy,af,bc,de,hl
2847   4F6A~            	exx
2848   4F6A~            	ex	af,af'
2849   4F6A~            	ld	ix,CHPUT
2850   4F6A~            	ld	iy,(EXPTBL-1)
2851   4F6A~            	call	CALSLT
2852   4F6A~            	ex	af,af'
2853   4F6A~            	exx
2854   4F6A~            	pop	hl,de,bc,af,iy,ix
2855   4F6A~            	exx
2856   4F6A~            	ex	af,af'
2857   4F6A~            	ret
2858   4F6A~            PRTDOT: 
2859   4F6A~            	push	af
2860   4F6A~            	ld	a,'.'
2861   4F6A~            	call	PRTCHAR
2862   4F6A~            	pop	af
2863   4F6A~            	ret
2864   4F6A~            PRTSEMIC: 
2865   4F6A~            	push	af
2866   4F6A~            	ld	a,';'
2867   4F6A~            	call	PRTCHAR
2868   4F6A~            	pop	af
2869   4F6A~            	ret
2870   4F6A~            PRTDASH: 
2871   4F6A~            	push	af
2872   4F6A~            	ld	a,'-'
2873   4F6A~            	call	PRTCHAR
2874   4F6A~            	pop	af
2875   4F6A~            	ret
2876   4F6A~            
2877   4F6A~            PRTHEX: 
2878   4F6A~            	push	af,bc,hl
2879   4F6A~            	ld	hl,TEMP3
2880   4F6A~            	call	HexToAscii
2881   4F6A~            	ld	a,'#'
2882   4F6A~            	call	PRTCHAR
2883   4F6A~            	ld	a,(TEMP3)
2884   4F6A~            	call	PRTCHAR
2885   4F6A~            	ld	a,(TEMP3+1)
2886   4F6A~            	call	PRTCHAR
2887   4F6A~            	pop	hl,bc,af
2888   4F6A~            	ret
2889   4F6A~            
2890   4F6A~            
2891   4F6A~            PRTSTRCALL: 	; Prints an inline ASCIIZ string
2892   4F6A~            	ex	(sp),hl		; hl=Pointer to inline string
2893   4F6A~            	push	af,ix,iy
2894   4F6A~            	ex	af,af'
2895   4F6A~            	exx
2896   4F6A~            	push	af,bc,de,hl
2897   4F6A~            	exx
2898   4F6A~            	ex	af,af'
2899   4F6A~            	ld	ix,CHPUT
2900   4F6A~            	ld	iy,(EXPTBL-1)
2901   4F6A~            .loop: 
2902   4F6A~            	ld	a,(hl)
2903   4F6A~            	inc	hl
2904   4F6A~            	or	a
2905   4F6A~            	jr	z,.end
2906   4F6A~            	call	CALSLT
2907   4F6A~            	jr	.loop
2908   4F6A~            
2909   4F6A~            .end
2910   4F6A~            		ex	af,af'
2911   4F6A~            	exx
2912   4F6A~            	pop	hl,de,bc,af
2913   4F6A~            	exx
2914   4F6A~            	ex	af,af'
2915   4F6A~            	pop	iy,ix,af
2916   4F6A~            	ex	(sp),hl
2917   4F6A~            	ret
2918   4F6A              ENDIF
2919   4F6A             
2920   4F6A             
2921   4F6A             
2922   4F6A             ; ==========================================================================
2923   4F6A             strTitle: 
2924   4F6A             	db	13,"FBLabs SDXC driver v",27,'J'
2924   4F6A 0D46424C61627320534458432064726976657220761B4A
2925   4F81             	BYTE2STR VER_MAIN
2925   4F81 31          >	db	(value % 10)+$30
2926   4F82 2E          	db	'.'
2927   4F83             	BYTE2STR VER_SEC
2927   4F83 30          >	db	(value % 10)+$30
2928   4F84 2E          	db	'.'
2929   4F85             	BYTE2STR VER_REV
2929   4F85 31          >	db	((value / 10) % 10)+$30
2929   4F86 31          >	db	(value % 10)+$30
2930   4F87 0D 8A       	db  	13,10|$80
2931   4F89             
2932   4F89             ;		 |-------------39 chars----------------|
2933   4F89             strBootpaused: 
2934   4F89             	db  	"Paused. Press <i> for the copyright info",13,10|$80
2934   4F89 5061757365642E205072657373203C693E20666F722074686520636F70797269
2934   4FA9 67687420696E666F0D8A
2935   4FB3             
2936   4FB3             strCopyright: 
2937   4FB3             	db	"(c) 2014 Fabio Belavenuto",13,10|$80
2937   4FB3 286329203230313420466162696F2042656C6176656E75746F0D8A
2938   4FCE             	db	"(c) 2017 FRS",13,10|$80
2938   4FCE 2863292032303137204652530D8A
2939   4FDC             	db	"Licenced under CERN OHL v1.1",13,10|$80
2939   4FDC 4C6963656E63656420756E646572204345524E204F484C2076312E310D8A
2940   4FFA             	db	"http://ohwr.org/cernohl",13,10|$80
2940   4FFA 687474703A2F2F6F6877722E6F72672F6365726E6F686C0D8A
2941   5013             	db	"PCB designed by Luciano Sturaro",13,10|$80
2941   5013 5043422064657369676E6564206279204C756369616E6F205374757261726F0D
2941   5033 8A
2942   5034             		; will use the CR+LF+EOS bellow 
2943   5034             strCrLf: 
2944   5034 0D 8A       	db	13,10|$80
2945   5036             strCartao: 
2946   5036             	ABYTEC 0	"- Slot "
2946   5036 2D20536C6F74A0
2947   503D             strVazio: 
2948   503D             	db	"Empty",13,10|$80
2948   503D 456D7074790D8A
2949   5044             strNaoDetectado: 
2950   5044             	db	"Failed!",13,10|$80
2950   5044 4661696C6564210D8A
2951   504D             ;			 |-------------39 chars----------------|
2952   504D             strMr_mp_desativada: 
2953   504D             	db	"- Slot expander & Mem Mapper disabled",13,10|$80
2953   504D 2D20536C6F7420657870616E6465722026204D656D204D617070657220646973
2953   506D 61626C65640D8A
2954   5074              IFDEF HASMEGARAM
2955   5074~            strMapper: 
2956   5074~            	db	"- Slot expander & Mem Mapper enabled",13,10|$80
2957   5074~            strMegaram: 
2958   5074~            	db	"- Slot expander & MegaRAM enabled",13,10|$80
2959   5074              ELSE
2960   5074             strDrvMain: 
2961   5074             	db	"- Main driver selected",13,10|$80
2961   5074 2D204D61696E206472697665722073656C65637465640D8A
2962   508C             strDrvDev: 
2963   508C             	db	"- Development driver selected",13,10|$80
2963   508C 2D20446576656C6F706D656E74206472697665722073656C65637465640D8A
2964   50AB              ENDIF
2965   50AB             strSDV1: 
2966   50AB             	ABYTEC 0 	"SDV1, ("
2966   50AB 534456312C20A8
2967   50B2             strSDV2: 
2968   50B2             	ABYTEC 0 	"SDV2, ("
2968   50B2 534456322C20A8
2969   50B9             
2970   50B9             nullTxt: 
2971   50B9             	db	"<null>"
2971   50B9 3C6E756C6C3E
2972   50BF             .end
2973   50BF              
2974   50BF             
2975   50BF             ;-----------------------------------------------------------------------------
2976   50BF             ;
2977   50BF             ; End of the driver code
2978   50BF             
2979   50BF             DRV_END: 
2980   50BF             
2981   50BF             ;	ds	3ED0h-(DRV_END-DRV_START), $FF
2982   50BF FF          	ds	$7B00-$, #FF
2983   7B00             
2984   7B00             
