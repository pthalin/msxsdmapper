0001   0000             ; Projeto MSX SD Mapper
0002   0000             
0003   0000             ; Copyright (c) 2014 Fabio Belavenuto
0004   0000             ; Enhanced by FRS
0005   0000             
0006   0000             ; This documentation describes Open Hardware and is licensed under the CERN OHL v. 1.1.
0007   0000             ; You may redistribute and modify this documentation under the terms of the
0008   0000             ; CERN OHL v.1.1. (http://ohwr.org/cernohl). This documentation is distributed
0009   0000             ; WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING OF MERCHANTABILITY,
0010   0000             ; SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.
0011   0000             ; Please see the CERN OHL v.1.1 for applicable conditions
0012   0000             
0013   0000             ; Technical info:
0014   0000             ; 7B00h~7EFFh	: SPI data transfer window (read/write)
0015   0000             ; 7F00h		: Interface status and card select register (read/write)
0016   0000             ;	<read>
0017   0000             ;	If no SD card is selected:
0018   0000             ;	    b7-b2 : always 0
0019   0000             ;	    b1 : SW1 status (Driver selection)
0020   0000             ;	    b0 : SW0 status. 0=RAM disabled, 1=RAM enabled
0021   0000             ;	If any SD card is selected:
0022   0000             ;	    b7-b3 : always 0
0023   0000             ;	    b2 : 1=Write protecton enabled for SD card-slot selected
0024   0000             ;	    b1 : 0=SD card present in the selected card-slot
0025   0000             ;	    b0 : 1=SD Card on slot selected changed since last read
0026   0000             ;	<write>
0027   0000             ;	    b0 : SD card slot-0 chip-select (1=selected)
0028   0000             ;	    b1 : SD card slot-1 chip-select (1=selected)
0029   0000             
0030   0000             ; 7F02h		: 8-bit timer (97.65625 KHz frequency, 10.24uS resolution) (read/write)
0031   0000             ; When a value is written, the timer will decrease it until it reaches zero
0032   0000             
0033   0000             	output	"driver.bin"
0034   0000             
0035   0000             ;-----------------------------------------------------------------------------
0036   0000             ;
0037   0000             ; Driver configuration constants
0038   0000             ;
0039   0000             
0040   0000             ; DEFINE HASMEGARAM	; Driver for an SD-Mapper with MegaRAM
0041   0000             ; DEFINE TURBOINIT	; Disable for the interfaces with the CPLD firmware turbo bug 
0042   0000             ; DEFINE DEBUG		; Set for debugging output
0043   0000             
0044   0000             ;Driver type:
0045   0000             ;   0 for drive-based
0046   0000             ;   1 for device-based
0047   0000             
0048   0000             DRV_TYPE	equ	1
0049   0000             
0050   0000             ;Hot-plug devices support (device-based drivers only):
0051   0000             ;   0 for no hot-plug support
0052   0000             ;   1 for hot-plug support
0053   0000             
0054   0000             DRV_HOTPLUG	equ	1
0055   0000             
0056   0000             
0057   0000             ;Driver version
0058   0000             
0059   0000             VER_MAIN	equ	1
0060   0000             VER_SEC		equ	0
0061   0000             VER_REV		equ	10
0062   0000             
0063   0000             ;-----------------------------------------------------------------------------
0064   0000             ; SPI addresses. Check the Technical info above for the bit contents
0065   0000             
0066   0000             SPIDATA		= $7B00
0067   0000             SPICTRL		= $7FF0
0068   0000             SPISTATUS	= $7FF0
0069   0000             TIMERREG	= $7FF1
0070   0000             
0071   0000             ; Interface status flags
0072   0000             IF_RAM		= 0		; 1=Interface RAM is enabled
0073   0000             IF_DRVER	= 1		; RAM mode: 0=MegaRAM, 1=MemoryMapper
0074   0000             IF_M_RAM	= (1 shl IF_RAM)		; bitmask for IF_RAM
0075   0000             IF_M_DRVER	= (1 shl IF_DRVER)		; bitmask for IF_DRVER
0076   0000             
0077   0000             ; card slot status flags
0078   0000             SD_DSKCHG	= 0		; SD card changed since last status check
0079   0000             SD_PRESENT	= 1		; SD card present
0080   0000             SD_WRTPROT	= 2		; SD card is write protected
0081   0000             SD_M_DSKCHG	= (1 shl SD_DSKCHG)		; bitmask for SD_DSKCHG
0082   0000             SD_M_PRESENT	= (1 shl SD_PRESENT)		; bitmask for SD_PRESENT
0083   0000             SD_M_WRTPROT	= (1 shl SD_WRTPROT)		; bitmask for SD_WRTPROT
0084   0000             
0085   0000             ; SPI commands: 
0086   0000             CMD0	= 0  | $40
0087   0000             CMD1	= 1  | $40
0088   0000             CMD8	= 8  | $40
0089   0000             CMD9	= 9  | $40
0090   0000             CMD10	= 10 | $40
0091   0000             CMD12	= 12 | $40
0092   0000             CMD16	= 16 | $40
0093   0000             CMD17	= 17 | $40
0094   0000             CMD18	= 18 | $40
0095   0000             CMD24	= 24 | $40
0096   0000             CMD25	= 25 | $40
0097   0000             CMD55	= 55 | $40
0098   0000             CMD58	= 58 | $40
0099   0000             ACMD23	= 23 | $40
0100   0000             ACMD41	= 41 | $40
0101   0000             
0102   0000             ; Work area variables 
0103   0000              STRUCT WRKAREA
0104   0000~            BCSD 		ds 16	; Card Specific Data
0105   0000~            BCID1		ds 16	; Card-ID of card1
0106   0000~            BCID2		ds 16	; Card-ID of card2
0107   0000~            NUMSD		db 	; Currently selected card: 1 or 2 
0108   0000~            CARDFLAGS	db 	; Flags that indicate card-change or card error 
0109   0000~            NUMBLOCKS	db 	; Number of blocks in multi-block operations 
0110   0000~            BLOCKS1		ds 3	; 3 bytes. Size of card1, in blocks.
0111   0000~            BLOCKS2		ds 3	; 3 bytes. Size of card2, in blocks.
0112   0000~            TEMP		db	; Temporary data
0113   0000~            TRLDIR		ds 8	; R800 data transfer helper 
0114   0000              ENDS
0115   0000             
0116   0000             
0117   0000             ;-----------------------------------------------------------------------------
0118   0000             ;
0119   0000             ; Standard BIOS and work area entries
0120   0000             CALSLT	= $001C		; Call routine in any slot
0121   0000             CALLF	= $0030		; Call routine in any slot
0122   0000             INITXT	= $006C		; Inicializa SCREEN0
0123   0000             CHSNS	= $009C		; Sense keyboard buffer for character
0124   0000             CHGET	= $009F		; Get character from keyboard buffer
0125   0000             CHPUT	= $00A2		; A=char
0126   0000             CLS	= $00C3		; Chamar com A=0
0127   0000             ERAFNK	= $00CC		; Erase function key display
0128   0000             SNSMAT	= $0141		; Read row of keyboard matrix
0129   0000             KILBUF	= $0156		; Clear keyboard buffer
0130   0000             EXTROM	= $015F
0131   0000             CHGCPU	= $0180		; Change the turbo mode
0132   0000             GETCPU	= $0183		; Get the turbo mode
0133   0000             
0134   0000             ; subROM functions
0135   0000             SDFSCR	= $0185
0136   0000             REDCLK	= $01F5
0137   0000             
0138   0000             
0139   0000             ; System variables
0140   0000             MSXVER	= $002D
0141   0000             LINL40	= $F3AE		; Width
0142   0000             LINLEN	= $F3B0
0143   0000             INTFLG	= $FC9B
0144   0000             SCRMOD	= $FCAF
0145   0000             EXPTBL	 =$FCC1
0146   0000             
0147   0000             
0148   0000             ;-----------------------------------------------------------------------------
0149   0000             
0150   0000             
0151   0000             	org		$4000
0152   4000             
0153   4000 FF          	ds		256, $FF		; 256 dummy bytes
0154   4100             
0155   4100             DRV_START: 
0156   4100             
0157   4100             ;-----------------------------------------------------------------------------
0158   4100             ;
0159   4100             ; Miscellaneous constants
0160   4100             ;
0161   4100             
0162   4100             ;This is a 2 byte buffer to store the address of code to be executed.
0163   4100             ;It is used by some of the kernel page 0 routines.
0164   4100             
0165   4100             CODE_ADD: 	equ	0F84Ch
0166   4100             
0167   4100             
0168   4100             ;-----------------------------------------------------------------------------
0169   4100             ;
0170   4100             ; Error codes for DEV_RW
0171   4100             ;
0172   4100             
0173   4100             ENCOMP	equ	0FFh
0174   4100             EWRERR	equ	0FEh
0175   4100             EDISK	equ	0FDh
0176   4100             ENRDY	equ	0FCh
0177   4100             EDATA	equ	0FAh
0178   4100             ERNF	equ	0F9h
0179   4100             EWPROT	equ	0F8h
0180   4100             EUFORM	equ	0F7h
0181   4100             ESEEK	equ	0F3h
0182   4100             EIFORM	equ	0F0h
0183   4100             EIDEVL	equ	0B5h
0184   4100             EIPARM	equ	08Bh
0185   4100             
0186   4100             ;-----------------------------------------------------------------------------
0187   4100             ;
0188   4100             ; Macros
0189   4100             ;
0190   4100             
0191   4100              MACRO BYTE2STR value
0192   4100~            0193   4100~             IF value > 99
0194   4100~            	db	((value / 100) % 10)+$30
0195   4100~             ENDIF
0196   4100~             IF value > 9
0197   4100~            	db	((value / 10) % 10)+$30
0198   4100~             ENDIF
0199   4100~            	db	(value % 10)+$30
0200   4100~            0201   4100              ENDM
0202   4100             
0203   4100             
0204   4100             ;-----------------------------------------------------------------------------
0205   4100             ;
0206   4100             ; Routines and information available on kernel page 0
0207   4100             ;
0208   4100             
0209   4100             ;* Get in A the current slot for page 1. Corrupts F.
0210   4100             ;  Must be called by using CALBNK to bank 0:
0211   4100             ;    xor a
0212   4100             ;    ld ix,GSLOT1
0213   4100             ;    call CALBNK
0214   4100             
0215   4100             GSLOT1	equ	402Dh
0216   4100             
0217   4100             
0218   4100             ;* This routine reads a byte from another bank.
0219   4100             ;  Must be called by using CALBNK to the desired bank,
0220   4100             ;  passing the address to be read in HL:
0221   4100             ;    ld a,<bank number>
0222   4100             ;    ld hl,<byte address>
0223   4100             ;    ld ix,RDBANK
0224   4100             ;    call CALBNK
0225   4100             
0226   4100             RDBANK	equ	403Ch
0227   4100             
0228   4100             
0229   4100             ;* This routine temporarily switches kernel main bank
0230   4100             ;  (usually bank 0, but will be 3 when running in MSX-DOS 1 mode),
0231   4100             ;  then invokes the routine whose address is at (CODE_ADD).
0232   4100             ;  It is necessary to use this routine to invoke CALBAS
0233   4100             ;  (so that kernel bank is correct in case of BASIC error)
0234   4100             ;  and to invoke DOS functions via F37Dh hook.
0235   4100             ;
0236   4100             ;  Input:  Address of code to invoke in (CODE_ADD).
0237   4100             ;          AF, BC, DE, HL, IX, IY passed to the called routine.
0238   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0239   4100             
0240   4100             CALLB0	equ	403Fh
0241   4100             
0242   4100             
0243   4100             ;* Call a routine in another bank.
0244   4100             ;  Must be used if the driver spawns across more than one bank.
0245   4100             ;
0246   4100             ;  Input:  A = bank number
0247   4100             ;          IX = routine address
0248   4100             ;          AF' = AF for the routine
0249   4100             ;          HL' = Ix for the routine
0250   4100             ;          BC, DE, HL, IY = input for the routine
0251   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0252   4100             
0253   4100             CALBNK	equ	4042h
0254   4100             
0255   4100             
0256   4100             ;* Get in IX the address of the SLTWRK entry for the slot passed in A,
0257   4100             ;  which will in turn contain a pointer to the allocated page 3
0258   4100             ;  work area for that slot (0 if no work area was allocated).
0259   4100             ;  If A=0, then it uses the slot currently switched in page 1.
0260   4100             ;  Returns A=current slot for page 1, if A=0 was passed.
0261   4100             ;  Corrupts F.
0262   4100             ;  Must be called by using CALBNK to bank 0:
0263   4100             ;    ld a,<slot number> (xor a for current page 1 slot)
0264   4100             ;    ex af,af'
0265   4100             ;    xor a
0266   4100             ;    ld ix,GWORK
0267   4100             ;    call CALBNK
0268   4100             
0269   4100             GWORK	equ	4045h
0270   4100             
0271   4100             
0272   4100             ;* This address contains one byte that tells how many banks
0273   4100             ;  form the Nextor kernel (or alternatively, the first bank
0274   4100             ;  number of the driver).
0275   4100             
0276   4100             K_SIZE	equ	40FEh
0277   4100             
0278   4100             
0279   4100             ;* This address contains one byte with the current bank number.
0280   4100             
0281   4100             CUR_BANK	equ	40FFh
0282   4100             
0283   4100             
0284   4100             ;-----------------------------------------------------------------------------
0285   4100             ;
0286   4100             ; Built-in format choice strings
0287   4100             ;
0288   4100             
0289   4100             NULL_MSG  equ     781Fh	;Null string (disk can't be formatted)
0290   4100             SING_DBL  equ     7820h ;"1-Single side / 2-Double side"
0291   4100             
0292   4100             
0293   4100             ;-----------------------------------------------------------------------------
0294   4100             ;
0295   4100             ; Driver signature
0296   4100             ;
0297   4100             	db	"NEXTOR_DRIVER",0
0297   4100 4E4558544F525F44524956455200
0298   410E             
0299   410E             
0300   410E             ;-----------------------------------------------------------------------------
0301   410E             ;
0302   410E             ; Driver flags:
0303   410E             ;    bit 0: 0 for drive-based, 1 for device-based
0304   410E             ;    bit 1: 1 for hot-plug devices supported (device-based drivers only)
0305   410E             
0306   410E 03          	db 1+(2*DRV_HOTPLUG)
0307   410F             
0308   410F             ;-----------------------------------------------------------------------------
0309   410F             ;
0310   410F             ; Reserved byte
0311   410F             ;
0312   410F 00          	db	0
0313   4110             
0314   4110             ;-----------------------------------------------------------------------------
0315   4110             ;
0316   4110             ; Driver name
0317   4110             ;
0318   4110             ; It will be shown in the FDISK interface selection menu
0319   4110             
0320   4110             DRV_NAME: 
0321   4110             	db	"FBLabs SDHC"
0321   4110 46424C6162732053444843
0322   411B 20          	ds	32-($-DRV_NAME)," "
0323   4130             
0324   4130             
0325   4130             ;-----------------------------------------------------------------------------
0326   4130             ;
0327   4130             ; Jump table for the driver public routines
0328   4130             ;
0329   4130             
0330   4130             	; These routines are mandatory for all drivers
0331   4130                     ; (but probably you need to implement only DRV_INIT)
0332   4130             
0333   4130 C3 6C 41    	jp	DRV_TIMI
0334   4133 C3 42 42    	jp	DRV_VERSION
0335   4136 C3 6D 41    	jp	DRV_INIT
0336   4139 C3 49 42    	jp	DRV_BASSTAT
0337   413C C3 4B 42    	jp	DRV_BASDEV
0338   413F C3 4D 42    	jp	DRV_EXTBIO
0339   4142 C3 4E 42    	jp	DRV_DIRECT0
0340   4145 C3 4E 42    	jp	DRV_DIRECT1
0341   4148 C3 4E 42    	jp	DRV_DIRECT2
0342   414B C3 4E 42    	jp	DRV_DIRECT3
0343   414E C3 4E 42    	jp	DRV_DIRECT4
0344   4151             
0345   4151 00          	ds	15
0346   4160             
0347   4160             	; These routines are mandatory for device-based drivers
0348   4160             
0349   4160 C3 4F 42    	jp	DEV_RW
0350   4163 C3 D5 42    	jp	DEV_INFO
0351   4166 C3 5D 43    	jp	DEV_STATUS
0352   4169 C3 A9 43    	jp	LUN_INFO
0353   416C             
0354   416C             
0355   416C             ;=====
0356   416C             ;=====  END of data that must be at fixed addresses
0357   416C             ;=====
0358   416C             
0359   416C             
0360   416C             ;-----------------------------------------------------------------------------
0361   416C             ;
0362   416C             ; Timer interrupt routine, it will be called on each timer interrupt
0363   416C             ; (at 50 or 60Hz), but only if DRV_INIT returns Cy=1 on its first execution.
0364   416C             
0365   416C             DRV_TIMI: 
0366   416C C9          	ret
0367   416D             
0368   416D             ;-----------------------------------------------------------------------------
0369   416D             ;
0370   416D             ; Driver initialization routine, it is called twice:
0371   416D             ;
0372   416D             ; 1) First execution, for information gathering.
0373   416D             ;    Input:
0374   416D             ;      A = 0
0375   416D             ;      B = number of available drives
0376   416D             ;      HL = maximum size of allocatable work area in page 3
0377   416D             ;    Output:
0378   416D             ;      A = number of required drives (for drive-based driver only)
0379   416D             ;      HL = size of required work area in page 3
0380   416D             ;      Cy = 1 if DRV_TIMI must be hooked to the timer interrupt, 0 otherwise
0381   416D             ;
0382   416D             ; 2) Second execution, for work area and hardware initialization.
0383   416D             ;    Input:
0384   416D             ;      A = 1
0385   416D             ;      B = number of allocated drives for this controller
0386   416D             ;
0387   416D             ;    The work area address can be obtained by using GWORK.
0388   416D             ;
0389   416D             ;    If first execution requests more work area than available,
0390   416D             ;    second execution will not be done and DRV_TIMI will not be hooked
0391   416D             ;    to the timer interrupt.
0392   416D             ;
0393   416D             ;    If first execution requests more drives than available,
0394   416D             ;    as many drives as possible will be allocated, and the initialization
0395   416D             ;    procedure will continue the normal way
0396   416D             ;    (for drive-based drivers only. Device-based drivers always
0397   416D             ;     get two allocated drives.)
0398   416D             
0399   416D             DRV_INIT: 
0400   416D B7          	or	a		; Is this the 1st call? 
0401   416E 20 0F       	jr	nz,.call2
0402   4170             ; 1st call:
0403   4170 21 3A 00    	ld	hl,WRKAREA.TRLDIR ; size of work area needed for the Z80
0404   4173 3A 2D 00    	ld	a,(MSXVER)
0405   4176 FE 03       	cp	3		; MSX Turbo-R?
0406   4178 3F          	ccf
0407   4179 D0          	ret	nc		; No, return with Cy off
0408   417A 21 42 00    	ld	hl,WRKAREA	; size of work area needed for the TR
0409   417D B7          	or	a		; Clear Cy
0410   417E C9          	ret
0411   417F             
0412   417F             
0413   417F             .call2: 
0414   417F             ; 2nd call: 
0415   417F              IFDEF TURBOINIT
0416   417F~            	ld	a,(CHGCPU)
0417   417F~            	cp	#C3		; IS CHGCPU present?
0418   417F~            	jr	nz,.call2ini
0419   417F~            	call	GETCPU
0420   417F~            	push	af		; Save the current CPU
0421   417F~            	ld	a,#82
0422   417F~            	call	CHGCPU		; Enable the turbo
0423   417F~            .call2ini: 
0424   417F              ENDIF ; TURBOINIT
0425   417F CD A7 48    	call	MYSETSCR		; Set the screen mode
0426   4182 CD E8 43    	call	pegaWorkArea		; HL=IY=Work area pointer
0427   4185             
0428   4185 11 6F 4D    	ld	de,strTitle		; prints the title 
0429   4188 CD 61 47    	call	printString
0430   418B             
0431   418B             
0432   418B             .sdhcinit: 	; FBLabs SDHC Interface initialization
0433   418B CD 23 42    	call	.printmode		; Print the switches configuration
0434   418E AF          	xor	a			; zera flags do cartao
0435   418F FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
0436   4192             
0437   4192 3E 01       	ld	a, 1			; detectar cartao 1
0438   4194 CD AE 41    	call	.detecta
0439   4197 3E 02       	ld	a, 2			; detectar cartao 2
0440   4199 CD AE 41    	call	.detecta
0441   419C 01 00 00    	ld	bc, 0
0442   419F 1E 05       	ld	e, 5
0443   41A1             
0444   41A1 CD 3A 49    	call	INSTR800HLP		; Install R800 data copy on workarea
0445   41A4             
0446   41A4 CD EB 48    	call	INICHKSTOP		; Check if the STOP key was pressed
0447   41A7             
0448   41A7 11 3B 4E    	ld	de, strCrLf
0449   41AA              
0450   41AA CD 61 47    	call	printString
0451   41AD              IFDEF TURBOINIT
0452   41AD~            .drv_init_end: 
0453   41AD~            	; ***Workaround for a bug in Nextor that causes it to freeze if
0454   41AD~            	; CTRL+STOP was pressed on boot
0455   41AD~            	ld	a,(INTFLG)
0456   41AD~            	cp	3		; Is CTRL+STOP still signaled?
0457   41AD~            	jr	nz,.restCPU	; no, skip
0458   41AD~            	xor	a
0459   41AD~            	ld	(INTFLG),a	; Clear CTRL+STOP otherwise Nextor will freeze
0460   41AD~            0461   41AD~            .restCPU: 	; Restore the CPU if necessary
0462   41AD~            	ld	a,(CHGCPU)
0463   41AD~            	cp	#C3		; IS CHGCPU present?
0464   41AD~            	ret	nz
0465   41AD~            	pop	af
0466   41AD~            	or	#80
0467   41AD~            	jp	CHGCPU
0468   41AD              ELSE
0469   41AD C9          	ret
0470   41AE              ENDIF ; TURBOINIT
0471   41AE             
0472   41AE             
0473   41AE             ;------- DRV_INIT aux routines ----------
0474   41AE             
0475   41AE             .detecta: 
0476   41AE FD 77 30    	ld	(iy+WRKAREA.NUMSD), a	; Save the requested card slot
0477   41B1 11 3E 4E    	ld	de, strCartao
0478   41B4 CD 61 47    	call	printString
0479   41B7 FD 4E 30    	ld	c, (iy+WRKAREA.NUMSD)
0480   41BA 79          	ld	a,c
0481   41BB C6 30       	add	'0'
0482   41BD CD A2 00    	call	CHPUT
0483   41C0 3E 3A       	ld	a, ':'
0484   41C2 CD A2 00    	call	CHPUT
0485   41C5 3E 20       	ld	a, ' '
0486   41C7 CD A2 00    	call	CHPUT
0487   41CA 79          	ld	a,c			; Get card slot#
0488   41CB             ;	cpl				; invert bits
0489   41CB             ;	and	3
0490   41CB 32 F0 7F    	ld	(SPICTRL), a		; Select card slot
0491   41CE 3A F0 7F    	ld	a, (SPISTATUS)		; get card slot status
0492   41D1 CD B5 45    	call	disableSDs
0493   41D4 E6 02       	and	SD_M_PRESENT		; Is there an card present?
0494   41D6 28 06       	jr	z,.naoVazio		; Yes, skip
0495   41D8 11 46 4E    	ld	de, strVazio		; Empty SD card slot message
0496   41DB C3 61 47    	jp	printString
0497   41DE             ;	jp	.marcaErro
0498   41DE             .naoVazio: 
0499   41DE CD 68 44    	call	detectaCartao		; tem cartao no slot, inicializar e detectar
0500   41E1 30 09       	jr	nc,.detectou
0501   41E3 CD B5 45    	call	disableSDs
0502   41E6 11 4E 4E    	ld	de, strNaoIdentificado
0503   41E9 C3 61 47    	jp	printString
0504   41EC             ;.marcaErro:
0505   41EC             ;	jp	marcaErroCartao		; slot vazio ou erro de deteccao, marcar nas flags
0506   41EC             .detectou: 
0507   41EC CD 40 44    	call	calculaCIDoffset	; calculamos em IX a posicao correta do offset CID dependendo do cartao atual
0508   41EF DD 7E 0F    	ld	a,(ix+15)	; pegar byte SDV1 ou SDV2
0509   41F2 11 BA 4E    	ld	de, strSDV1	; e imprimir
0510   41F5 B7          	or	a
0511   41F6 28 03       	jr	z,.pula1
0512   41F8 11 C1 4E    	ld	de, strSDV2
0513   41FB             .pula1: 
0514   41FB CD 61 47    	call	printString
0515   41FE 3E 28       	ld	a,'('
0516   4200 CD A2 00    	call	CHPUT
0517   4203 DD 7E 00    	ld	a,(ix)		; pegar byte do fabricante
0518   4206 CD AE 47    	call	printDecToAscii	; Imprimir Manufacturer ID
0519   4209 3E 29       	ld	a,')'
0520   420B CD A2 00    	call	CHPUT
0521   420E 3E 20       	ld	a,' '
0522   4210 CD A2 00    	call	CHPUT
0523   4213 DD 7E 00    	ld	a,(ix)		; pegar byte do fabricante
0524   4216 CD DA 47    	call	pegaFabricante	; achar nome do fabricante
0525   4219 EB          	ex	de,hl
0526   421A CD 61 47    	call	printString	; e imprimir
0527   421D 11 3B 4E    	ld	de,strCrLf
0528   4220 C3 61 47    	jp	printString
0529   4223             
0530   4223             
0531   4223             .printmode: 		; Print the two switches configuration
0532   4223 AF          	xor	a			; 0=Interface status
0533   4224 32 F0 7F    	ld	(SPICTRL),a
0534   4227 3A F0 7F    	ld	a, (SPISTATUS)		; Check if the mapper/megaRAM is active
0535   422A E6 01       	and	IF_M_RAM		; Is the RAM enabled?
0536   422C 11 59 4E    	ld	de,strMr_mp_desativada
0537   422F              IFDEF HASMEGARAM
0538   422F~            	jr	z,.print		; No, skip
0539   422F~            	ld	a, (SPISTATUS)		; ativa, testar se eh mapper ou megaram
0540   422F~            	and	IF_M_DRVER
0541   422F~            	ld	de,strMapper
0542   422F~            	jr	nz,.print
0543   422F~            	ld	de, strMegaram		; Megaram ativa
0544   422F~            .print: 
0545   422F~            	jp	printString
0546   422F              ELSE
0547   422F CC 61 47    	call	z,printString		; Yes, print
0548   4232 3A F0 7F    	ld	a, (SPISTATUS)		; Get the MainBIOS/DevBIOS switch status
0549   4235 E6 02       	and	IF_M_DRVER
0550   4237 11 81 4E    	ld	de,strDrvMain
0551   423A 20 03       	jr	nz,.printdrv
0552   423C 11 9A 4E    	ld	de, strDrvDev
0553   423F             .printdrv: 
0554   423F C3 61 47    	jp	printString
0555   4242              ENDIF
0556   4242             
0557   4242             
0558   4242             
0559   4242             
0560   4242             
0561   4242             ;-----------------------------------------------------------------------------
0562   4242             ;
0563   4242             ; Obtain driver version
0564   4242             ;
0565   4242             ; Input:  -
0566   4242             ; Output: A = Main version number
0567   4242             ;         B = Secondary version number
0568   4242             ;         C = Revision number
0569   4242             
0570   4242             DRV_VERSION: 
0571   4242 3E 01       	ld	a, VER_MAIN
0572   4244 06 00       	ld	b, VER_SEC
0573   4246 0E 0A       	ld	c, VER_REV
0574   4248 C9          	ret
0575   4249             
0576   4249             
0577   4249             ;-----------------------------------------------------------------------------
0578   4249             ;
0579   4249             ; BASIC expanded statement ("CALL") handler.
0580   4249             ; Works the expected way, except that if invoking CALBAS is needed,
0581   4249             ; it must be done via the CALLB0 routine in kernel page 0.
0582   4249             
0583   4249             DRV_BASSTAT: 
0584   4249 37          	scf
0585   424A C9          	ret
0586   424B             
0587   424B             
0588   424B             ;-----------------------------------------------------------------------------
0589   424B             ;
0590   424B             ; BASIC expanded device handler.
0591   424B             ; Works the expected way, except that if invoking CALBAS is needed,
0592   424B             ; it must be done via the CALLB0 routine in kernel page 0.
0593   424B             
0594   424B             DRV_BASDEV: 
0595   424B 37          	scf
0596   424C C9          	ret
0597   424D             
0598   424D             ;-----------------------------------------------------------------------------
0599   424D             ;
0600   424D             ; Extended BIOS hook.
0601   424D             ; Works the expected way, except that it must return
0602   424D             ; D'=1 if the old hook must be called, D'=0 otherwise.
0603   424D             ; It is entered with D'=1.
0604   424D             
0605   424D             DRV_EXTBIO: 
0606   424D C9          	ret
0607   424E             
0608   424E             ;-----------------------------------------------------------------------------
0609   424E             ;
0610   424E             ; Direct calls entry points.
0611   424E             ; Calls to addresses 7850h, 7853h, 7856h, 7859h and 785Ch
0612   424E             ; in kernel banks 0 and 3 will be redirected
0613   424E             ; to DIRECT0/1/2/3/4 respectively.
0614   424E             ; Receives all register data from the caller except IX and AF'.
0615   424E             
0616   424E             DRV_DIRECT0: 
0617   424E             DRV_DIRECT1: 
0618   424E             DRV_DIRECT2: 
0619   424E             DRV_DIRECT3: 
0620   424E             DRV_DIRECT4: 
0621   424E C9          	ret
0622   424F             
0623   424F             
0624   424F             ;=====
0625   424F             ;=====  BEGIN of DEVICE-BASED specific routines
0626   424F             ;=====
0627   424F             
0628   424F             ;-----------------------------------------------------------------------------
0629   424F             ;
0630   424F             ; Read or write logical sectors from/to a logical unit
0631   424F             ;
0632   424F             ;Input:    Cy=0 to read, 1 to write
0633   424F             ;          A = Device number, 1 to 7
0634   424F             ;          B = Number of sectors to read or write
0635   424F             ;          C = Logical unit number, 1 to 7
0636   424F             ;          HL = Source or destination memory address for the transfer
0637   424F             ;          DE = Address where the 4 byte sector number is stored.
0638   424F             ;Output:   A = Error code (the same codes of MSX-DOS are used):
0639   424F             ;              0: Ok
0640   424F             ;              .IDEVL: Invalid device or LUN
0641   424F             ;              .NRDY: Not ready
0642   424F             ;              .DISK: General unknown disk error
0643   424F             ;              .DATA: CRC error when reading
0644   424F             ;              .RNF: Sector not found
0645   424F             ;              .UFORM: Unformatted disk
0646   424F             ;              .WPROT: Write protected media, or read-only logical unit
0647   424F             ;              .WRERR: Write error
0648   424F             ;              .NCOMP: Incompatible disk.
0649   424F             ;              .SEEK: Seek error.
0650   424F             ;          B = Number of sectors actually read (in case of error only)
0651   424F             
0652   424F             DEV_RW: 
0653   424F F5          	push	af
0654   4251 BF FE 03    	cp	a, 3		; somente 2 dispositivos
0655   4253 30 1C       	jr	nc,.saicomerroidl
0656   4255 0D          	dec	c		; somente 1 logical unit
0657   4256 20 19       	jr	nz,.saicomerroidl
0658   4258 CD E8 43    	call	pegaWorkArea	; IY=Work area pointer
0659   425B FD 77 30    	ld	(iy+WRKAREA.NUMSD),a
0660   425E FD 70 32    	ld	(iy+WRKAREA.NUMBLOCKS),b	; save the number of blocks to transfer 
0661   4261 CD 57 46    	call	setaSDAtual
0662   4264 3A F0 7F    	ld	a,(SPISTATUS)	; Get this card slot status
0663   4267 E6 02       	and	SD_M_PRESENT	; Is there a card present?
0664   4269 28 0C       	jr	z,.cardok	; Yes, skip
0665   426B F1          	pop	af
0666   426C 3E FC       	ld	a, ENRDY	; Not ready
0667   426E 06 00       	ld	b, 0
0668   4270 C9          	ret
0669   4271             .saicomerroidl: 
0670   4271 F1          	pop	af
0671   4272 3E B5       	ld	a, EIDEVL	; error: Invalid device or LUN 
0672   4274 06 00       	ld	b, 0
0673   4276 C9          	ret
0674   4277             .cardok: 
0675   4277             ;	exx
0676   4277 D5 E5       	push	de,hl
0677   4279             
0678   4279 CD 59 4D    	call	SETLDIRHLPR	; hl'=Pointer to LDIR helper in RAM
0679   427C CD 40 44    	call	calculaCIDoffset	; ix=CID offset 
0680   427F DD 7E 0F    	ld	a,(ix+15)	; verificar se eh SDV1 ou SDV2
0681   4282 DD 6F       	ld	ixl,a		; ixl=SDcard version
0682   4284 E1 D1       	pop	hl,de
0683   4286 F1          	pop	af		; a=Device number, f=read/write flag 
0684   4287             ;	exx			; hl=Source/dest Address, de=Pointer to sect#
0685   4287             ;	ld	ixh, b 		; ixh=Number of blocks to transfer
0686   4287 38 20       	jr	c,DEV_W	; Skip if it's a write operation 
0687   4289             
0688   4289             DEV_R: 
0689   4289 1A          	ld	a, (de)		; 1. n. bloco
0690   428A F5          	push	af
0691   428B 13          	inc	de
0692   428C 1A          	ld	a, (de)		; 2. n. bloco
0693   428D F5          	push	af
0694   428E 13          	inc	de
0695   428F 1A          	ld	a, (de)		; 3. n. bloco
0696   4290 4F          	ld	c, a
0697   4291 13          	inc	de
0698   4292 1A          	ld	a, (de)		; 4. n. bloco
0699   4293 13          	inc	de
0700   4294 47          	ld	b, a
0701   4295 F1          	pop	af
0702   4296 57          	ld	d, a
0703   4297 F1          	pop	af		; HL = ponteiro destino
0704   4298 5F          	ld	e, a		; BC DE = 32 bits numero do bloco
0705   4299 CD FF 46    	call	LerBloco	; chamar rotina de leitura de dados
0706   429C D0          	ret	nc		; Return with A=0 if no error occurred
0707   429D CD 29 44    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0708   42A0 FD 7E 32    	ld	a,(iy+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0709   42A3 DD 94       	sub	ixh		; subtract the number of remaining blocks
0710   42A5 47          	ld	b,a		; b=number of blocks written
0711   42A6 3E FD       	ld	a, EDISK	; General unknown disk error
0712   42A8 C9          	ret
0713   42A9             
0714   42A9             DEV_W: 
0715   42A9             	; Test if the card is write protected
0716   42A9 3A F0 7F    	ld	a,(SPISTATUS)	; Get this card slot status
0717   42AC E6 04       	and	SD_M_WRTPROT	; Is the card write protected?
0718   42AE 28 05       	jr	z,.ok
0719   42B0 3E F8       	ld	a, EWPROT	; disco protegido
0720   42B2 06 00       	ld	b,0		; 0 blocks were written
0721   42B4 C9          	ret
0722   42B5             .ok: 
0723   42B5 1A          	ld	a, (de)		; 1. n. bloco
0724   42B6 F5          	push	af
0725   42B7 13          	inc	de
0726   42B8 1A          	ld	a, (de)		; 2. n. bloco
0727   42B9 F5          	push	af
0728   42BA 13          	inc	de
0729   42BB 1A          	ld	a, (de)		; 3. n. bloco
0730   42BC 13          	inc	de
0731   42BD 4F          	ld	c, a
0732   42BE 1A          	ld	a, (de)		; 4. n. bloco
0733   42BF 13          	inc	de
0734   42C0 47          	ld	b, a
0735   42C1 F1          	pop	af
0736   42C2 57          	ld	d, a
0737   42C3 F1          	pop	af		; HL = ponteiro destino
0738   42C4 5F          	ld	e, a		; BC DE = 32 bits numero do bloco
0739   42C5 CD 63 46    	call	GravarBloco	; chamar rotina de gravacao de dados
0740   42C8 D0          	ret	nc		; Return with A=0 if no error occurred
0741   42C9             
0742   42C9 CD 29 44    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0743   42CC FD 7E 32    	ld	a,(iy+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0744   42CF DD 94       	sub	ixh		; subtract the number of remaining blocks
0745   42D1 47          	ld	b,a		; b=number of blocks written
0746   42D2 3E FE       	ld	a,EWRERR	; Write error
0747   42D4 C9          	ret
0748   42D5             
0749   42D5             ;-----------------------------------------------------------------------------
0750   42D5             ;
0751   42D5             ; Device information gathering
0752   42D5             ;
0753   42D5             ;Input:   A = Device index, 1 to 7
0754   42D5             ;         B = Information to return:
0755   42D5             ;             0: Basic information
0756   42D5             ;             1: Manufacturer name string
0757   42D5             ;             2: Device name string
0758   42D5             ;             3: Serial number string
0759   42D5             ;         HL = Pointer to a buffer in RAM
0760   42D5             ;Output:  A = Error code:
0761   42D5             ;             0: Ok
0762   42D5             ;             1: Device not available or invalid device index
0763   42D5             ;             2: Information not available, or invalid information index
0764   42D5             ;         When basic information is requested,
0765   42D5             ;         buffer filled with the following information:
0766   42D5             ;
0767   42D5             ;+0 (1): Numer of logical units, from 1 to 7. 1 if the device has no logical
0768   42D5             ;        units (which is functionally equivalent to having only one).
0769   42D5             ;+1 (1): Device flags, always zero in Beta 2.
0770   42D5             ;
0771   42D5             ; The strings must be printable ASCII string (ASCII codes 32 to 126),
0772   42D5             ; left justified and padded with spaces. All the strings are optional,
0773   42D5             ; if not available, an error must be returned.
0774   42D5             ; If a string is provided by the device in binary format, it must be reported
0775   42D5             ; as an hexadecimal, upper-cased string, preceded by the prefix "0x".
0776   42D5             ; The maximum length for a string is 64 characters;
0777   42D5             ; if the string is actually longer, the leftmost 64 characters
0778   42D5             ; should be provided.
0779   42D5             ;
0780   42D5             ; In the case of the serial number string, the same rules for the strings
0781   42D5             ; apply, except that it must be provided right-justified,
0782   42D5             ; and if it is too long, the rightmost characters must be
0783   42D5             ; provided, not the leftmost.
0784   42D5             
0785   42D5             DEV_INFO: 
0786   42D6 BF FE 03    	cp	a,3		; somente 2 dispositivos
0787   42D8 38 03       	jr	c,.devok
0788   42DA 3E 01       	ld	a,1		; invalid device index
0789   42DC C9          	ret
0790   42DD             .devok: 
0791   42DD CD E8 43    	call	pegaWorkArea	; IY=Work area pointer
0792   42E0 FD 77 30    	ld	(iy+WRKAREA.NUMSD),a
0793   42E3 CD 57 46    	call	setaSDAtual
0794   42E6 04          	inc	b
0795   42E7 10 06       	djnz	.naoBasic
0796   42E9             
0797   42E9             ; Basic information:
0798   42E9 36 01       	ld	(hl), 1		; 1 logical unit somente
0799   42EB 23          	inc	hl
0800   42EC AF          	xor	a
0801   42ED 77          	ld	(hl),a		; reservado, deve ser 0
0802   42EE C9          	ret			; retorna com A=0 (OK)
0803   42EF             
0804   42EF             .naoBasic: 
0805   42EF 3E 02       	ld	a,2
0806   42F1             ;	ret	c		; No card present? Quit with info not available
0807   42F1             
0808   42F1 E5          	push	hl
0809   42F2 CD 40 44    	call	calculaCIDoffset	; calculamos em IX a posicao correta do offset CID dependendo do cartao atual
0810   42F5 E1          	pop	hl
0811   42F6 10 26       	djnz	.naoManuf
0812   42F8             ; Manufacturer Name:
0813   42F8 E5          	push	hl		; salva ponteiro do buffer
0814   42F9 06 40       	ld	b, 64		; preenche buffer com espaco
0815   42FB 3E 20       	ld	a, ' '
0816   42FD             .loop1: 
0817   42FD 77          	ld	(hl), a
0818   42FE 23          	inc	hl
0819   42FF 10 FC       	djnz	.loop1
0820   4301 D1          	pop	de		; recuperamos ponteiro do buffer em DE
0821   4302 3E 28       	ld	a, '('		; colocamos (xx) xxx no buffer
0822   4304 12          	ld	(de), a
0823   4305 13          	inc	de
0824   4306 DD 7E 00    	ld	a, (ix)		; byte do fabricante
0825   4309 CD 6A 47    	call	DecToAscii
0826   430C 3E 29       	ld	a, ')'
0827   430E 12          	ld	(de), a
0828   430F 13          	inc	de
0829   4310 3E 20       	ld	a, ' '
0830   4312 12          	ld	(de), a
0831   4313 13          	inc	de
0832   4314 DD 7E 00    	ld	a, (ix)		; byte do fabricante
0833   4317 CD DA 47    	call	pegaFabricante	; pegar nome do fabricante em HL
0834   431A ED B0       	ldir			; e colocar no buffer
0835   431C AF          	xor	a		; Return with A=0 (Ok)
0836   431D C9          	ret
0837   431E             
0838   431E             .naoManuf: 
0839   431E 10 1A       	djnz	.naoProduct
0840   4320             ; Product Name:
0841   4320 E5          	push	hl		; guarda HL que aponta para buffer do Nextor
0842   4321 DD E5       	push	ix
0843   4323 E1          	pop	hl		; joga IX para HL
0844   4324 16 00       	ld	d, 0
0845   4326 1E 03       	ld	e, 3		; adiciona offset do productname em HL
0846   4328 19          	add	hl, de
0847   4329 D1          	pop	de		; recupera buffer do Nextor em DE
0848   432A 01 05 00    	ld	bc, 5		; 5 caracteres
0849   432D ED B0       	ldir			; copia nome do produto
0850   432F EB          	ex	de,hl		; troca DE com HL, agora HL aponta para Buffer do nextor atualizado
0851   4330 06 3B       	ld	b, 59		; Coloca espaco no restante do buffer
0852   4332 3E 20       	ld	a, ' '
0853   4334             .loop2: 
0854   4334 77          	ld	(hl), a
0855   4335 23          	inc	hl
0856   4336 10 FC       	djnz	.loop2
0857   4338 AF          	xor	a		; Return with A=0 (Ok)
0858   4339 C9          	ret
0859   433A             
0860   433A             .naoProduct: 
0861   433A             ; Serial Number:
0862   433A 36 30       	ld	(hl),'0'	; Coloca prefixo "0x"
0863   433C 23          	inc	hl
0864   433D 36 78       	ld	(hl), 'x'
0865   433F 23          	inc	hl
0866   4340 E5          	push	hl		; guarda HL que aponta para buffer do Nextor
0867   4341 DD E5       	push	ix
0868   4343 E1          	pop	hl		; joga IX para HL
0869   4344 16 00       	ld	d, 0
0870   4346 1E 09       	ld	e, 9		; adiciona offset do productname em HL
0871   4348 19          	add	hl, de
0872   4349 D1          	pop	de		; recupera buffer do nextor em DE
0873   434A 06 04       	ld	b, 4		; 4 bytes do serial
0874   434C             .loop3: 
0875   434C 7E          	ld	a, (hl)
0876   434D CD 9A 47    	call	HexToAscii	; converter HEXA para ASCII
0877   4350 23          	inc	hl
0878   4351 10 F9       	djnz	.loop3
0879   4353 06 36       	ld	b, 54		; Coloca espaco no restante
0880   4355 3E 20       	ld	a, ' '
0881   4357             .loop4: 
0882   4357 12          	ld	(de), a
0883   4358 13          	inc	de
0884   4359 10 FC       	djnz	.loop4
0885   435B AF          	xor	a		; Return with A=0 (Ok)
0886   435C C9          	ret
0887   435D             
0888   435D             ;-----------------------------------------------------------------------------
0889   435D             ;
0890   435D             ; Obtain device status
0891   435D             ;
0892   435D             ;Input:   A = Device index, 1 to 7
0893   435D             ;         B = Logical unit number, 1 to 7
0894   435D             ;             0 to return the status of the device itself.
0895   435D             ;Output:  A = Status for the specified logical unit,
0896   435D             ;             or for the whole device if 0 was specified:
0897   435D             ;                0: The device or logical unit is not available, or the
0898   435D             ;                   device or logical unit number supplied is invalid.
0899   435D             ;                1: The device or logical unit is available and has not
0900   435D             ;                   changed since the last status request.
0901   435D             ;                2: The device or logical unit is available and has changed
0902   435D             ;                   since the last status request
0903   435D             ;                   (for devices, the device has been unplugged and a
0904   435D             ;                    different device has been plugged which has been
0905   435D             ;                    assigned the same device index; for logical units,
0906   435D             ;                    the media has been changed).
0907   435D             ;                3: The device or logical unit is available, but it is not
0908   435D             ;                   possible to determine whether it has been changed
0909   435D             ;                   or not since the last status request.
0910   435D             ;
0911   435D             ; Devices not supporting hot-plugging must always return status value 1.
0912   435D             ; Non removable logical units may return values 0 and 1.
0913   435D             ;
0914   435D             ; The returned status is always relative to the previous invokation of
0915   435D             ; DEV_STATUS itself. Please read the Driver Developer Guide for more info.
0916   435D             
0917   435D             DEV_STATUS: 
0918   435D 4F          	ld	c,a		; c=Device number
0919   435E FE 03       	cp	3		; 2 dispositivos somente
0920   4360 30 42       	jr	nc,.nodev
0921   4362 78          	ld	a,b
0922   4363 B7          	or	a		; Device itself status?
0923   4364 28 40       	jr	z,.devok	; I'm fine, thanks
0924   4366 3D          	dec	a		; Only LUN=1 are allowed
0925   4367 20 3B       	jr	nz,.nodev
0926   4369              IFDEF DEBUG
0927   4369~            	push	af
0928   4369~            	ld	a,'S'
0929   4369~            	call	PRTCHAR
0930   4369~            	pop	af
0931   4369              ENDIF
0932   4369 C5          	push	bc
0933   436A 79          	ld	a,c
0934   436B CD E8 43    	call	pegaWorkArea	; HL=IY=Work area pointer
0935   436E C1          	pop	bc
0936   436F FD 71 30    	ld	(iy+WRKAREA.NUMSD),c	; salva numero do device atual (1 ou 2)
0937   4372 79          	ld	a,c
0938   4373 32 F0 7F    	ld	(SPICTRL), a	; selects SD
0939   4376 3A F0 7F    	ld	a, (SPISTATUS)	; Get this card-slot status
0940   4379 CD B5 45    	call	disableSDs
0941   437C CB 4F       	bit	SD_PRESENT,a	; Any card here?
0942   437E 20 24       	jr	nz,.saicomerro	; Report that there's no card here
0943   4380 E6 01       	and	SD_M_DSKCHG	; Has the card changed since last time?
0944   4382 20 06       	jr	nz,.detcard	; Yes, force a detection
0945   4384             .tsterror: 
0946   4384 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; testar bit de erro do cartao nas flags
0947   4387 A1          	and	c		; Test against the card #
0948   4388 28 14       	jr	z,.semMudanca	; cartao nao marcado com erro, pula
0949   438A             .detcard: 
0950   438A CD 68 44    	call	detectaCartao	; erro na deteccao do cartao, tentar re-detectar
0951   438D 38 12       	jr	c,.cartaoComErro	; nao conseguimos detectar, sai com erro
0952   438F FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)		; conseguimos detectar, tira erro nas flags
0953   4392 2F          	cpl			; inverte bits para fazer o AND
0954   4393 4F          	ld	c, a
0955   4394 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)
0956   4397 A1          	and	c		; clear the error bit 
0957   4398 FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
0958   439B             .comMudanca: 
0959   439B              IFDEF DEBUG
0960   439B~            	ld	a,'2'
0961   439B~            	call	PRTCHAR
0962   439B              ENDIF
0963   439B 3E 02       	ld	a, 2		; informa ao Nextor que cartao esta OK e mudou
0964   439D C9          	ret
0965   439E             .semMudanca: 
0966   439E              IFDEF DEBUG
0967   439E~            	ld	a,'1'
0968   439E~            	call	PRTCHAR
0969   439E              ENDIF
0970   439E 3E 01       	ld	a, 1		; informa ao Nextor que cartao esta OK e nao mudou
0971   43A0 C9          	ret
0972   43A1             .cartaoComErro: 
0973   43A1 CD 29 44    	call	marcaErroCartao	; marcar erro do cartao nas flags
0974   43A4              IFDEF DEBUG
0975   43A4~            	ld	a,'E'
0976   43A4~            	call	PRTCHAR
0977   43A4~            	xor	a
0978   43A4~            	ret
0979   43A4              ENDIF
0980   43A4             .nodev: 
0981   43A4              IFDEF DEBUG
0982   43A4~            	ld	a,'s'
0983   43A4~            	call	PRTCHAR
0984   43A4~            	xor	a
0985   43A4~            	ret
0986   43A4              ENDIF
0987   43A4             .saicomerro: 
0988   43A4              IFDEF DEBUG
0989   43A4~            	ld	a,'0'
0990   43A4~            	call	PRTCHAR
0991   43A4              ENDIF
0992   43A4 AF          	xor	a		; this device has an error 
0993   43A5 C9          	ret
0994   43A6             .devok: 
0995   43A6 3E 03       	ld	a,3
0996   43A8 C9          	ret
0997   43A9             
0998   43A9             
0999   43A9             ;-----------------------------------------------------------------------------
1000   43A9             ;
1001   43A9             ; Obtain logical unit information
1002   43A9             ;
1003   43A9             ;Input:   A  = Device index, 1 to 7
1004   43A9             ;         B  = Logical unit number, 1 to 7
1005   43A9             ;         HL = Pointer to buffer in RAM.
1006   43A9             ;Output:  A = 0: Ok, buffer filled with information.
1007   43A9             ;             1: Error, device or logical unit not available,
1008   43A9             ;                or device index or logical unit number invalid.
1009   43A9             ;         On success, buffer filled with the following information:
1010   43A9             ;
1011   43A9             ;+0 (1): Medium type:
1012   43A9             ;        0: Block device
1013   43A9             ;        1: CD or DVD reader or recorder
1014   43A9             ;        2-254: Unused. Additional codes may be defined in the future.
1015   43A9             ;        255: Other
1016   43A9             ;+1 (2): Sector size, 0 if this information does not apply or is
1017   43A9             ;        not available.
1018   43A9             ;+3 (4): Total number of available sectors.
1019   43A9             ;        0 if this information does not apply or is not available.
1020   43A9             ;+7 (1): Flags:
1021   43A9             ;        bit 0: 1 if the medium is removable.
1022   43A9             ;        bit 1: 1 if the medium is read only. A medium that can dinamically
1023   43A9             ;               be write protected or write enabled is not considered
1024   43A9             ;               to be read-only.
1025   43A9             ;        bit 2: 1 if the LUN is a floppy disk drive.
1026   43A9             ;+8 (2): Number of cylinders
1027   43A9             ;+10 (1): Number of heads
1028   43A9             ;+11 (1): Number of sectors per track
1029   43A9             ;
1030   43A9             ; Number of cylinders, heads and sectors apply to hard disks only.
1031   43A9             ; For other types of device, these fields must be zero.
1032   43A9             
1033   43A9             LUN_INFO: 
1034   43AA BF FE 03    	cp	a, 3		; somente 2 dispositivo
1035   43AC 30 0A       	jr	nc,.saicomerro
1036   43AE 05          	dec	b		; somente 1 logical unit
1037   43AF 20 07       	jr	nz,.saicomerro
1038   43B1 E5          	push	hl
1039   43B2 CD 00 44    	call	testaCartao
1040   43B5 E1          	pop	hl
1041   43B6 30 03       	jr	nc,.ok		; nao tem erro com o cartao
1042   43B8             .saicomerro: 
1043   43B8 3E 01       	ld	a, 1		; informar erro
1044   43BA C9          	ret
1045   43BB             .ok: 
1046   43BB E5          	push	hl
1047   43BC CD 54 44    	call	calculaBLOCOSoffset	; calcular em IX e HL o offset correto do buffer que armazena total de blocos
1048   43BF E1          	pop	hl		; do cartao dependendo do cartao atual solicitado
1049   43C0 AF          	xor	a
1050   43C1 77          	ld	(hl), a		; Informar que o dispositivo eh do tipo block device
1051   43C2 23          	inc	hl
1052   43C3 77          	ld	(hl), a		; tamanho de um bloco = 512 bytes (coloca $00, $02 que  $200 = 512)
1053   43C4 23          	inc	hl
1054   43C5 3E 02       	ld	a, 2
1055   43C7 77          	ld	(hl), a
1056   43C8 23          	inc	hl
1057   43C9 DD 7E 00    	ld	a, (ix)		; copia numero de blocos total
1058   43CC 77          	ld	(hl), a
1059   43CD 23          	inc	hl
1060   43CE DD 7E 01    	ld	a, (ix+1)
1061   43D1 77          	ld	(hl), a
1062   43D2 23          	inc	hl
1063   43D3 DD 7E 02    	ld	a, (ix+2)
1064   43D6 77          	ld	(hl), a
1065   43D7 23          	inc	hl
1066   43D8 AF          	xor	a		; cartoes SD tem total de blocos em 24 bits, mas o Nextor pede numero de
1067   43D9 77          	ld	(hl), a 	; 32 bits, entao coloca 0 no MSB
1068   43DA 23          	inc	hl
1069   43DB 3E 01       	ld	a, 1		; flags: dispositivo R/W removivel
1070   43DD 77          	ld	(hl), a
1071   43DE 23          	inc	hl
1072   43DF AF          	xor	a		; CHS = 0
1073   43E0 77          	ld	(hl), a
1074   43E1 23          	inc	hl
1075   43E2 77          	ld	(hl), a
1076   43E3 23          	inc	hl
1077   43E4 77          	ld	(hl), a
1078   43E5 23          	inc	hl
1079   43E6 AF          	xor	a		; informar que dados foram preenchidos
1080   43E7 C9          	ret
1081   43E8             
1082   43E8             ;=====
1083   43E8             ;=====  END of DEVICE-BASED specific routines
1084   43E8             ;=====
1085   43E8             
1086   43E8             ;------------------------------------------------
1087   43E8             ; Rotinas auxiliares
1088   43E8             ;------------------------------------------------
1089   43E8             
1090   43E8             ;------------------------------------------------
1091   43E8             ; Pedir ao Nextor o ponteiro de dados de trabalho
1092   43E8             ; na RAM e colocar em HL e IY
1093   43E8             ; Output: 
1094   43E8             ; IY = WorkArea pointer
1095   43E8             ; Modifies: IX
1096   43E8             ;------------------------------------------------
1097   43E8             pegaWorkArea: 
1098   43E8 F5 E5       	push	af,hl
1099   43EA AF          	xor	a		; Pegar endereco da area de trabalho
1100   43EB 08          	ex	af,af'
1101   43EC AF          	xor	a
1102   43ED DD 21 45 40 	ld	ix, GWORK
1103   43F1 CD 42 40    	call	CALBNK
1104   43F4 DD 6E 00    	ld	l,(ix)		; em HL tem o ponteiro da nossa area da RAM
1105   43F7 DD 66 01    	ld	h,(ix+1)
1106   43FA E5          	push	hl
1107   43FB FD E1       	pop	iy		; em IY temos o mesmo ponteiro
1108   43FD E1 F1       	pop	hl,af
1109   43FF C9          	ret
1110   4400             
1111   4400             ;------------------------------------------------
1112   4400             ; Testa se cartao esta inserido e/ou houve erro
1113   4400             ; na ultima vez que foi acessado. Carry indica
1114   4400             ; erro
1115   4400             ; Destroi AF, HL, IX, C
1116   4400             ;------------------------------------------------
1117   4400             testaCartao: 
1118   4400 F5          	push	af
1119   4401 CD E8 43    	call	pegaWorkArea	; HL=IY=Work area pointer
1120   4404 F1          	pop	af
1121   4405 FD 77 30    	ld	(iy+WRKAREA.NUMSD), a	; salva numero do device atual (1 ou 2)
1122   4408 4F          	ld	c, a
1123   4409 32 F0 7F    	ld	(SPICTRL), a	; Selects SD
1124   440C 3A F0 7F    	ld	a, (SPISTATUS)	; testar se cartao esta inserido
1125   440F CD B5 45    	call	disableSDs
1126   4412 E6 02       	and	$02
1127   4414 20 0A       	jr	nz,.saicomerro				
1128   4416 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; testar bit de erro do cartao nas flags
1129   4419 A1          	and	c
1130   441A 28 02       	jr	z,.ok
1131   441C 37          	scf			; indica erro
1132   441D C9          	ret
1133   441E             .ok: 
1134   441E AF          	xor	a		; zera carry indicando sem erro
1135   441F C9          	ret
1136   4420             .saicomerro: 
1137   4420 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; marca bit de erro nas flags
1138   4423 B1          	or	c
1139   4424 FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
1140   4427 37          	scf
1141   4428 C9          	ret
1142   4429             
1143   4429             ;------------------------------------------------
1144   4429             ; Marcar bit de erro nas flags
1145   4429             ; Destroi AF, C
1146   4429             ;------------------------------------------------
1147   4429             marcaErroCartao: 
1148   4429 FD 4E 30    	ld	c, (iy+WRKAREA.NUMSD)		; cartao atual (1 ou 2)
1149   442C FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; marcar erro
1150   442F B1          	or	c
1151   4430 FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
1152   4433 C9          	ret
1153   4434             
1154   4434             ;------------------------------------------------
1155   4434             ; Testar se cartao atual esta protegido contra
1156   4434             ; gravacao, A=0 se protegido
1157   4434             ; Destroi AF, C
1158   4434             ;------------------------------------------------
1159   4434             testaWP: 
1160   4434 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; cartao atual (1 ou 2)
1161   4437 32 F0 7F    	ld	(SPICTRL), a
1162   443A 3A F0 7F    	ld	a, (SPISTATUS)	; testar se cartao esta protegido
1163   443D             ;	call	disableSDs
1164   443D E6 04       	and	$04
1165   443F C9          	ret			; se A for 0 cartao esta protegido
1166   4440             
1167   4440             ;------------------------------------------------
1168   4440             ; Calcula offset do buffer na RAM em HL e IX para
1169   4440             ; os dados do CID dependendo do cartao atual
1170   4440             ; Destroi AF, DE, HL e IX
1171   4440             ;------------------------------------------------
1172   4440             calculaCIDoffset: 
1173   4440 FD E5       	push	iy		; copiamos IY para HL
1174   4442 E1          	pop	hl
1175   4443 16 00       	ld	d, 0
1176   4445 1E 10       	ld	e, WRKAREA.BCID1	; DE aponta para buffer BCID1
1177   4447 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; vamos fazer IX apontar para o buffer correto
1178   444A 3D          	dec	a		; dependendo do cartao: BCID1 ou BCID2
1179   444B 28 02       	jr	z,.c1
1180   444D 1E 20       	ld	e, WRKAREA.BCID2	; DE aponta para buffer BCID2
1181   444F             .c1: 
1182   444F 19          	add	hl, de		; HL aponta para buffer correto
1183   4450 E5          	push	hl		
1184   4451 DD E1       	pop	ix		; vamos colocar HL em IX
1185   4453 C9          	ret
1186   4454             
1187   4454             ;------------------------------------------------
1188   4454             ; Calcula offset do buffer na RAM para os dados
1189   4454             ; do total de blocos dependendo do cartao atual
1190   4454             ; Offset fica em HL e IX
1191   4454             ; Destroi AF, DE, HL e IX
1192   4454             ;------------------------------------------------
1193   4454             calculaBLOCOSoffset: 
1194   4454 FD E5       	push	iy		; copiamos IY para HL
1195   4456 E1          	pop	hl
1196   4457 16 00       	ld	d, 0
1197   4459 1E 33       	ld	e, WRKAREA.BLOCKS1	; DE aponta para buffer BLOCKS1
1198   445B FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; Vamos fazer IX apontar para o buffer correto
1199   445E 3D          	dec	a		; dependendo do cartao: BLOCKS1 ou BLOCKS2
1200   445F 28 02       	jr	z,.c1
1201   4461 1E 36       	ld	e, WRKAREA.BLOCKS2	; DE aponta para buffer BLOCKS2
1202   4463             .c1: 
1203   4463 19          	add	hl, de		; HL aponta para buffer correto
1204   4464 E5          	push	hl		
1205   4465 DD E1       	pop	ix		; Vamos colocar HL em IX
1206   4467 C9          	ret
1207   4468             
1208   4468             
1209   4468             ;------------------------------------------------
1210   4468             ; Minhas funcoes para cartao SD
1211   4468             ;------------------------------------------------
1212   4468             
1213   4468             ;------------------------------------------------
1214   4468             ; Processo de inicializacao e deteccao do cartao.
1215   4468             ; Detecta se cartao responde, qual versao (SDV1
1216   4468             ; ou SDV2), faz a leitura do CSD e CID e calcula
1217   4468             ; o numero de blocos do cartao, colocando o CID
1218   4468             ; e total de blocos no buffer correto dependendo
1219   4468             ; do cartao 1 ou 2.
1220   4468             ; Retorna erro no carry. Se for 0 indica deteccao
1221   4468             ; com sucesso.
1222   4468             ; Destroi todos os registradores
1223   4468             ;------------------------------------------------
1224   4468             detectaCartao: 
1225   4468 CD 96 45    	call	iniciaSD	; manda pulsos de clock e comandos iniciais
1226   446B D8          	ret	c			; retorna se erro
1227   446C CD 37 45    	call	testaSDCV2	; tenta inicializar um cartao SDV2
1228   446F D8          	ret	c
1229   4470 FD E5       	push	iy		; colocar em HL buffer da RAM de trabalho
1230   4472 E1          	pop	hl		; CSD esta no offset 0, nao precisamos somar
1231   4473 3E 49       	ld	a, CMD9		; ler CSD
1232   4475 CD 58 45    	call	lerBlocoCxD
1233   4478 D8          	ret	c
1234   4479 CD 40 44    	call	calculaCIDoffset	; calculamos em IX e HL a posicao correta do offset CID dependendo do cartao atual
1235   447C 3E 4A       	ld	a, CMD10	; ler CID
1236   447E CD 58 45    	call	lerBlocoCxD
1237   4481 D8          	ret	c
1238   4482 3E 7A       	ld	a, CMD58	; ler OCR
1239   4484 11 00 00    	ld	de, 0
1240   4487 CD E6 45    	call	SD_SEND_CMD_2_ARGS_GET_R3	; enviar comando e receber resposta tipo R3
1241   448A D8          	ret	c
1242   448B 78          	ld	a, b		; testa bit CCS do OCR que informa se cartao eh SDV1 ou SDV2
1243   448C E6 40       	and	$40
1244   448E DD 77 0F    	ld	(ix+15), a	; salva informacao da versao do SD (V1 ou V2) no byte 15 do CID
1245   4491 CC 2C 45    	call	z,mudarTamanhoBlocoPara512	; se bit CCS do OCR for 1, eh cartao SDV2 (Block address - SDHC ou SDXD)
1246   4494 D8          	ret	c		; e nao precisamos mudar tamanho do bloco para 512
1247   4495 CD B5 45    	call	disableSDs
1248   4498             				; agora vamos calcular o total de blocos dependendo dos dados do CSD
1249   4498 CD 54 44    	call	calculaBLOCOSoffset	; calcular em IX e HL o offset correto do buffer que armazena total de blocos
1250   449B FD E5       	push	iy		; copiamos IY para HL
1251   449D E1          	pop	hl
1252   449E 16 00       	ld	d, 0
1253   44A0 1E 05       	ld	e, WRKAREA.BCSD+5
1254   44A2 19          	add	hl, de		; HL aponta para buffer BCSD+5
1255   44A3 FD 7E 00    	ld	a, (iy+WRKAREA.BCSD)
1256   44A6 E6 C0       	and	$C0		; testa versao do registro CSD
1257   44A8 28 06       	jr	z,.calculaCSD1
1258   44AA FE 40       	cp	$40
1259   44AC 28 54       	jr	z,.calculaCSD2
1260   44AE 37          	scf			; versao do registro CSD nao reconhecida, informa erro na deteccao
1261   44AF C9          	ret
1262   44B0             
1263   44B0             ; -----------------------------------
1264   44B0             ; Registro CSD versao 1, calcular da
1265   44B0             ; maneira correta para a versao 1
1266   44B0             ; -----------------------------------
1267   44B0             .calculaCSD1: 
1268   44B0 7E          	ld	a, (hl)
1269   44B1 E6 0F       	and	$0F		; isola READ_BL_LEN
1270   44B3 F5          	push	af
1271   44B4 23          	inc	hl
1272   44B5 7E          	ld	a, (hl)		; 2 primeiros bits de C_SIZE
1273   44B6 E6 03       	and	3
1274   44B8 57          	ld	d, a
1275   44B9 23          	inc	hl
1276   44BA 5E          	ld	e, (hl)		; 8 bits de C_SIZE (DE contem os primeiros 10 bits de C_SIZE)
1277   44BB 23          	inc	hl
1278   44BC 7E          	ld	a, (hl)
1279   44BD E6 C0       	and	$C0		; 2 ultimos bits de C_SIZE
1280   44BF 87          	add	a, a		; rotaciona a esquerda
1281   44C0 CB 13       	rl	e		; rotaciona para DE
1282   44C2 CB 12       	rl	d
1283   44C4 87          	add	a, a		; mais uma rotacao
1284   44C5 CB 13       	rl	e		; rotaciona para DE
1285   44C7 CB 12       	rl	d
1286   44C9 13          	inc	de		; agora DE contem todos os 12 bits de C_SIZE, incrementa 1
1287   44CA 23          	inc	hl
1288   44CB 7E          	ld	a, (hl)		; proximo byte
1289   44CC E6 03       	and	3		; 2 bits de C_SIZE_MUL
1290   44CE 47          	ld	b, a		; B contem os 2 bits de C_SIZE_MUL
1291   44CF 23          	inc	hl						
1292   44D0 7E          	ld	a, (hl)		; proximo byte
1293   44D1 E6 80       	and	$80		; 1 bit de C_SIZE_MUL
1294   44D3 87          	add	a, a		; rotaciona para esquerda jogando no carry
1295   44D4 CB 10       	rl	b		; rotaciona para B
1296   44D6 04          	inc	b		; agora B contem os 3 bits de C_SIZE_MUL
1297   44D7 04          	inc	b		; faz B = C_SIZE_MUL + 2
1298   44D8 F1          	pop	af		; volta em A o READ_BL_LEN
1299   44D9 80          	add	a, b		; A = READ_BL_LEN + (C_SIZE_MUL+2)
1300   44DA 01 00 00    	ld	bc, 0
1301   44DD CD F6 44    	call	.eleva2
1302   44E0 5A          	ld	e, d		; aqui temos 32 bits (BC DE) com o tamanho do cartao
1303   44E1 51          	ld	d, c		; ignoramos os 8 ultimos bits em E, fazemos BC DE => 0B CD (divide por 256)
1304   44E2 48          	ld	c, b
1305   44E3 06 00       	ld	b, 0
1306   44E5 CB 39       	srl	c		; rotacionamos a direita o C, carry = LSB (divide por 2)
1307   44E7 CB 1A       	rr	d		; rotacionamos D e E
1308   44E9 CB 1B       	rr	e		; no final BC DE contem tamanho do cartao / 512 = numero de blocos
1309   44EB             .salvaBlocos: 
1310   44EB DD 71 02    	ld	(ix+2), c	; colocar no buffer BLOCOS correto a quantidade de blocos
1311   44EE DD 72 01    	ld	(ix+1), d	; que o cartao (1 ou 2) tem
1312   44F1 DD 73 00    	ld	(ix), e
1313   44F4 AF          	xor	a		; limpa carry
1314   44F5 C9          	ret
1315   44F6             
1316   44F6             .eleva2: 			; aqui temos: A = (READ_BL_LEN + (C_SIZE_MUL+2))
1317   44F6             				; BC = 0
1318   44F6             				; DE = C_SIZE
1319   44F6 CB 23       	sla	e		; rotacionamos C_SIZE por 'A' vezes
1320   44F8 CB 12       	rl	d
1321   44FA CB 11       	rl	c
1322   44FC CB 10       	rl	b
1323   44FE 3D          	dec	a		; subtraimos 1
1324   44FF 20 F5       	jr	nz,.eleva2
1325   4501 C9          	ret			; em BC DE temos o tamanho do cartao (bytes) em 32 bits
1326   4502             
1327   4502             ; -----------------------------------
1328   4502             ; Registro CSD versao 2, calcular da
1329   4502             ; maneira correta para a versao 2
1330   4502             ; -----------------------------------
1331   4502             .calculaCSD2: 
1332   4502 23          	inc	hl		; HL ja aponta para BCSD+5, fazer HL apontar para BCSD+7
1333   4503 23          	inc	hl
1334   4504 7E          	ld	a, (hl)
1335   4505 E6 3F       	and	$3F
1336   4507 4F          	ld	c, a
1337   4508 23          	inc	hl
1338   4509 56          	ld	d, (hl)
1339   450A 23          	inc	hl
1340   450B 5E          	ld	e, (hl)
1341   450C CD 18 45    	call	.inc32		; soma 1
1342   450F CD 20 45    	call	.desloca32	; multiplica por 512
1343   4512 CD 25 45    	call	.rotaciona24	; multiplica por 2
1344   4515 C3 EB 44    	jp		.salvaBlocos
1345   4518             
1346   4518             .inc32: 
1347   4518 1C          	inc	e
1348   4519 C0          	ret	nz
1349   451A 14          	inc	d
1350   451B C0          	ret	nz
1351   451C 0C          	inc	c
1352   451D C0          	ret	nz
1353   451E 04          	inc	b
1354   451F C9          	ret
1355   4520             
1356   4520             .desloca32: 
1357   4520 41          	ld	b, c
1358   4521 4A          	ld	c, d
1359   4522 53          	ld	d, e
1360   4523 1E 00       	ld	e, 0
1361   4525             .rotaciona24: 
1362   4525 CB 22       	sla	d
1363   4527 CB 11       	rl	c
1364   4529 CB 10       	rl	b
1365   452B C9          	ret
1366   452C             
1367   452C             ; ------------------------------------------------
1368   452C             ; Setar o tamanho do bloco para 512 se o cartao
1369   452C             ; for SDV1
1370   452C             ; ------------------------------------------------
1371   452C             mudarTamanhoBlocoPara512: 
1372   452C 3E 50       	ld	a, CMD16
1373   452E 01 00 00    	ld	bc, 0
1374   4531 11 00 02    	ld	de, 512
1375   4534 C3 D1 45    	jp	SD_SEND_CMD_GET_ERROR
1376   4537             
1377   4537             ; ------------------------------------------------
1378   4537             ; Tenta inicializar um cartao SDV2, se houver erro
1379   4537             ; o cartao deve ser SDV1
1380   4537             ; ------------------------------------------------
1381   4537             testaSDCV2: 
1382   4537 3E 48       	ld	a, CMD8
1383   4539 11 AA 01    	ld	de, $1AA
1384   453C CD E6 45    	call	SD_SEND_CMD_2_ARGS_GET_R3
1385   453F 21 CA 45    	ld	hl, SD_SEND_CMD1	; HL aponta para rotina correta
1386   4542 38 03       	jr	c,.pula		; cartao recusou CMD8, enviar comando CMD1
1387   4544 21 BC 45    	ld	hl, SD_SEND_ACMD41	; cartao aceitou CMD8, enviar comando ACMD41
1388   4547             .pula: 
1389   4547 01 14 00    	ld	bc, 20		; B = 0, C = 20: 5120 tentativas
1390   454A             .loop: 
1391   454A C5          	push	bc
1392   454B CD 57 45    	call	.jumpHL		; chamar rotina correta em HL
1393   454E C1          	pop	bc
1394   454F D0          	ret	nc
1395   4550 10 F8       	djnz	.loop
1396   4552 0D          	dec	c
1397   4553 20 F5       	jr	nz,.loop
1398   4555 37          	scf
1399   4556 C9          	ret
1400   4557             .jumpHL: 
1401   4557 E9          	jp	(hl)		; chamar rotina correta em HL
1402   4558             
1403   4558             ; ------------------------------------------------
1404   4558             ; Ler registro CID ou CSD, o comando vem em A
1405   4558             ; ------------------------------------------------
1406   4558             lerBlocoCxD: 
1407   4558 CD CC 45    	call	SD_SEND_CMD_NO_ARGS
1408   455B D8          	ret	c
1409   455C CD 2B 46    	call	WAIT_RESP_FE
1410   455F D8          	ret	c
1411   4560 EB          	ex	de,hl
1412   4561             
1413   4561             	; Check for a Z80 or R800
1414   4561             ;	or 	a		; Clear Cy
1415   4561 3E 14       	ld	a,20
1416   4563 ED F9       	db	#ED,#F9		; mulub a,a
1417   4565 21 00 7B    	ld	hl, SPIDATA
1418   4568 38 25       	jr	c,.r800		; Use LDIR for R800
1419   456A ED A0       > ldi	
1419   456C ED A0       > ldi	
1419   456E ED A0       > ldi	
1419   4570 ED A0       > ldi	
1419   4572 ED A0       > ldi	
1419   4574 ED A0       > ldi	
1419   4576 ED A0       > ldi	
1419   4578 ED A0       > ldi	
1419   457A ED A0       > ldi	
1419   457C ED A0       > ldi	
1419   457E ED A0       > ldi	
1419   4580 ED A0       > ldi	
1419   4582 ED A0       > ldi	
1419   4584 ED A0       > ldi	
1419   4586 ED A0       > ldi	
1419   4588 ED A0       > ldi	
1420   458A             .end
1421   458A 7E           	ld	a, (hl)
1422   458B 7E          	ld	a, (hl)		; byte de resposta
1423   458C B7          	or	a
1424   458D EB          	ex	de,hl
1425   458E             ;	jr	disableSDs
1426   458E C9          	ret
1427   458F             
1428   458F             .r800: 
1429   458F 01 10 00    	ld	bc,16
1430   4592 ED B0       	ldir
1431   4594 18 F4       	jr	.end
1432   4596             
1433   4596             ; ------------------------------------------------
1434   4596             ; Algoritmo para inicializar um cartao SD
1435   4596             ; Destroi AF, B, DE
1436   4596             ; ------------------------------------------------
1437   4596             iniciaSD: 
1438   4596 CD B5 45    	call	disableSDs
1439   4599             
1440   4599 06 0A       	ld	b, 10		; enviar 80 pulsos de clock com cartao desabilitado
1441   459B             enviaClocksInicio: 
1442   459B 3E FF       	ld	a, $FF		; manter MOSI em 1
1443   459D 32 00 7B    	ld	(SPIDATA), a
1444   45A0 10 F9       	djnz	enviaClocksInicio
1445   45A2 CD 57 46    	call	setaSDAtual	; ativar cartao atual
1446   45A5 06 08       	ld	b, 8		; 8 tentativas para CMD0
1447   45A7             SD_SEND_CMD0: 
1448   45A7 3E 40       	ld	a, CMD0		; primeiro comando: CMD0
1449   45A9 11 00 00    	ld	de, 0
1450   45AC C5          	push	bc
1451   45AD CD D9 45    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
1452   45B0 C1          	pop	bc
1453   45B1 D0          	ret	nc			; retorna se cartao respondeu ao CMD0
1454   45B2 10 F3       	djnz	SD_SEND_CMD0
1455   45B4 37          	scf			; cartao nao respondeu ao CMD0, informar erro
1456   45B5             	; fall throw
1457   45B5             
1458   45B5             ; ------------------------------------------------
1459   45B5             ; Desabilitar (de-selecionar) todos os cartoes
1460   45B5             ; Nao destroi registradores
1461   45B5             ; ------------------------------------------------
1462   45B5             disableSDs: 
1463   45B5 F5          	push	af
1464   45B6 AF          	xor	a
1465   45B7 32 F0 7F    	ld	(SPICTRL), a
1466   45BA F1          	pop	af
1467   45BB C9          	ret
1468   45BC             
1469   45BC             ; ------------------------------------------------
1470   45BC             ; Enviar comando ACMD41
1471   45BC             ; ------------------------------------------------
1472   45BC             SD_SEND_ACMD41: 
1473   45BC 3E 77       	ld	a, CMD55
1474   45BE CD CC 45    	call	SD_SEND_CMD_NO_ARGS
1475   45C1 3E 69       	ld	a, ACMD41
1476   45C3 01 00 40    	ld	bc, $4000
1477   45C6 51          	ld	d, c
1478   45C7 59          	ld	e, c
1479   45C8 18 07       	jr		SD_SEND_CMD_GET_ERROR
1480   45CA             
1481   45CA             ; ------------------------------------------------
1482   45CA             ; Enviar CMD1 para cartao. Carry indica erro
1483   45CA             ; Destroi AF, BC, DE
1484   45CA             ; ------------------------------------------------
1485   45CA             SD_SEND_CMD1: 
1486   45CA 3E 41       	ld	a, CMD1
1487   45CC             SD_SEND_CMD_NO_ARGS: 
1488   45CC 01 00 00    	ld	bc, 0
1489   45CF 50          	ld	d, b
1490   45D0 59          	ld	e, c
1491   45D1             SD_SEND_CMD_GET_ERROR: 
1492   45D1 CD FF 45    	call	SD_SEND_CMD
1493   45D4 B7          	or	a
1494   45D5 C8          	ret	z			; se A=0 nao houve erro, retornar
1495   45D6             	; fall throw
1496   45D6             
1497   45D6             ; ------------------------------------------------
1498   45D6             ; Informar erro
1499   45D6             ; Nao destroi registradores
1500   45D6             ; ------------------------------------------------
1501   45D6             setaErro: 
1502   45D6 37          	scf
1503   45D7 18 DC       	jr		disableSDs
1504   45D9             
1505   45D9             ; ------------------------------------------------
1506   45D9             ; Enviar comando em A com 2 bytes de parametros
1507   45D9             ; em DE e testar retorno BUSY
1508   45D9             ; Retorna em A a resposta do cartao
1509   45D9             ; Destroi AF, BC
1510   45D9             ; ------------------------------------------------
1511   45D9             SD_SEND_CMD_2_ARGS_TEST_BUSY: 
1512   45D9 01 00 00    	ld	bc, 0
1513   45DC CD FF 45    	call	SD_SEND_CMD
1514   45DF 47          	ld	b, a
1515   45E0 E6 FE       	and	$FE		; testar bit 0 (flag BUSY)
1516   45E2 78          	ld	a, b
1517   45E3 20 F1       	jr	nz,setaErro	; BUSY em 1, informar erro
1518   45E5 C9          	ret			; sem erros
1519   45E6             
1520   45E6             ; ------------------------------------------------
1521   45E6             ; Enviar comando em A com 2 bytes de parametros
1522   45E6             ; em DE e ler resposta do tipo R3 em BC DE
1523   45E6             ; Retorna em A a resposta do cartao
1524   45E6             ; Destroi AF, BC, DE, HL
1525   45E6             ; ------------------------------------------------
1526   45E6             SD_SEND_CMD_2_ARGS_GET_R3: 
1527   45E6 CD D9 45    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
1528   45E9 D8          	ret	c
1529   45EA F5          	push	af
1530   45EB CD 39 46    	call	WAIT_RESP_NO_FF
1531   45EE 67          	ld	h, a
1532   45EF CD 39 46    	call	WAIT_RESP_NO_FF
1533   45F2 6F          	ld	l, a
1534   45F3 CD 39 46    	call	WAIT_RESP_NO_FF
1535   45F6 57          	ld	d, a
1536   45F7 CD 39 46    	call	WAIT_RESP_NO_FF
1537   45FA 5F          	ld	e, a
1538   45FB 44          	ld	b, h
1539   45FC 4D          	ld	c, l
1540   45FD F1          	pop	af
1541   45FE C9          	ret
1542   45FF             
1543   45FF             ; ------------------------------------------------
1544   45FF             ; Enviar comando em A com 4 bytes de parametros
1545   45FF             ; em BC DE e enviar CRC correto se for CMD0 ou 
1546   45FF             ; CMD8 e aguardar processamento do cartao
1547   45FF             ; Output  : A=0 if there was no error
1548   45FF             ; Modifies:  AF, B, AF'
1549   45FF             ; ------------------------------------------------
1550   45FF             SD_SEND_CMD: 
1551   45FF CD 57 46    	call	setaSDAtual
1552   4602 32 00 7B    	ld	(SPIDATA), a
1553   4605 F5          	push	af
1554   4606 78          	ld	a, b
1555   4607 32 00 7B    	ld	(SPIDATA), a
1556   460A 79          	ld	a, c
1557   460B 32 00 7B    	ld	(SPIDATA), a
1558   460E 7A          	ld	a, d
1559   460F 32 00 7B    	ld	(SPIDATA), a
1560   4612 7B          	ld	a, e
1561   4613 32 00 7B    	ld	(SPIDATA), a
1562   4616 F1          	pop	af
1563   4617 FE 40       	cp	CMD0
1564   4619 06 95       	ld	b, $95		; CRC para CMD0
1565   461B 28 08       	jr	z,enviaCRC
1566   461D FE 48       	cp	CMD8
1567   461F 06 87       	ld	b, $87		; CRC para CMD8
1568   4621 28 02       	jr	z,enviaCRC
1569   4623 06 FF       	ld	b, $FF		; CRC dummy
1570   4625             enviaCRC: 
1571   4625 78          	ld	a, b
1572   4626 32 00 7B    	ld	(SPIDATA), a
1573   4629 18 0E       	jr	WAIT_RESP_NO_FF
1574   462B             
1575   462B             ; ------------------------------------------------
1576   462B             ; Esperar que resposta do cartao seja $FE
1577   462B             ; Destroi AF, B
1578   462B             ; ------------------------------------------------
1579   462B             WAIT_RESP_FE: 
1580   462B 06 0A       	ld	b, 10		; 10 tentativas
1581   462D             .loop: 
1582   462D C5          	push	bc
1583   462E CD 39 46    	call	WAIT_RESP_NO_FF	; esperar resposta diferente de $FF
1584   4631 C1          	pop	bc
1585   4632 FE FE       	cp	$FE		; resposta  $FE ?
1586   4634 C8          	ret	z		; sim, retornamos com carry=0
1587   4635 10 F6       	djnz	.loop
1588   4637 37          	scf			; erro, carry=1
1589   4638 C9          	ret
1590   4639             
1591   4639             ; ------------------------------------------------
1592   4639             ; Esperar que resposta do cartao seja diferente
1593   4639             ; de $FF
1594   4639             ; Destroi AF, BC
1595   4639             ; ------------------------------------------------
1596   4639             WAIT_RESP_NO_FF: 
1597   4639 01 01 00    	ld	bc, 1		; 256 tentativas
1598   463C             .loop: 
1599   463C 3A 00 7B    	ld	a, (SPIDATA)
1600   463F FE FF       	cp	$FF		; testa $FF
1601   4641 C0          	ret		nz		; sai se nao for $FF
1602   4642 10 F8       	djnz	.loop
1603   4644 0D          	dec	c
1604   4645 20 F5       	jr	nz,.loop
1605   4647 C9          	ret
1606   4648             
1607   4648             ; ------------------------------------------------
1608   4648             ; Esperar que resposta do cartao seja diferente
1609   4648             ; de $00
1610   4648             ; Destroi A, BC
1611   4648             ; ------------------------------------------------
1612   4648             WAIT_RESP_NO_00: 
1613   4648 01 80 00    	ld	bc, 128		; 32768 tentativas
1614   464B             .loop: 
1615   464B 3A 00 7B    	ld	a, (SPIDATA)
1616   464E B7          	or	a
1617   464F C0          	ret	nz			; se resposta for <> $00, sai
1618   4650 10 F9       	djnz	.loop
1619   4652 0D          	dec	c
1620   4653 20 F6       	jr	nz,.loop
1621   4655 37          	scf			; erro
1622   4656 C9          	ret
1623   4657             
1624   4657             ; ------------------------------------------------
1625   4657             ; Sets the requested card slot and check its status
1626   4657             ; In case it detects that the card was changed, it will call the detection
1627   4657             ; routine to re-dectect the card type
1628   4657             ; Input: Target card slot
1629   4657             ; Output: Cy = No SD card is present
1630   4657             ;         A: 0=The same card is still present
1631   4657             ;            1=The card was changed since the last check
1632   4657             ; ------------------------------------------------
1633   4657             setaSDAtual: 
1634   4657 F5          	push	af
1635   4658 3A 00 7B    	ld	a, (SPIDATA)	; dummy read
1636   465B FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)
1637   465E 32 F0 7F    	ld	(SPICTRL), a
1638   4661 F1          	pop	af
1639   4662 C9          	ret
1640   4663             
1641   4663              IFDEF BLA
1642   4663~            	ld	a, (SPIDATA)	; dummy read
1643   4663~            	ld	a, (iy+WRKAREA.NUMSD)
1644   4663~            ;	cpl			; invert bits
1645   4663~            ;	and	3
1646   4663~            	ld	(SPICTRL), a
1647   4663~            	;
1648   4663~            	ld	a,(SPISTATUS)	; Get this card slot status
1649   4663~            	bit	SD_PRESENT,a	; Is there a card present?
1650   4663~            	scf
1651   4663~            	ret	nz		; No, return with error
1652   4663~            1653   4663~            	; ***Workaround for the problem that Nextor doesn't call DEV_STATUS to
1654   4663~            	; check if the media has changed before every disk operation, so we
1655   4663~            	; need to always check if it changed.
1656   4663~            	and	SD_M_DSKCHG	; Was the card changed since last checked?
1657   4663~            	ret	z		; No, return
1658   4663~            	push	bc,de,hl,ix
1659   4663~            	call	detectaCartao	; Detect the new card
1660   4663~            	pop	ix,hl,de,bc
1661   4663~            	ret	c		; Error? Then return
1662   4663~            	ld	a,1
1663   4663~            	ret
1664   4663              ENDIF ; BLA
1665   4663             
1666   4663             ; ------------------------------------------------
1667   4663             ; Grava um bloco de 512 bytes no cartao
1668   4663             ; HL = aponta para o inicio dos dados
1669   4663             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
1670   4663             ; IXH = Number of blocks
1671   4663             ; IXL = SDcard version (0 or 1)
1672   4663             ; Modifies:  AF, BC, DE, HL, IXL
1673   4663             ; ------------------------------------------------
1674   4663             GravarBloco: 
1675   4663              IFDEF DEBUG
1676   4663~            	push	af
1677   4663~            	ld	a,'G'
1678   4663~            	call	PRTCHAR
1679   4663~            	pop	af
1680   4663              ENDIF
1681   4663             ;	ld	a, (ix+15)	; verificar se eh SDV1 ou SDV2
1682   4663 DD 7D       	ld	a,ixl
1683   4665 B7          	or	a
1684   4666 CC 55 47    	call	z,blocoParaByte		; se for SDV1 coverter blocos para bytes
1685   4669             ;	call	setaSDAtual	; selecionar cartao atual
1686   4669 FD 7E 32    	ld	a, (iy+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
1687   466C DD 67       	ld	ixh,a		; ixh=Number of blocks
1688   466E 3D          	dec	a
1689   466F CA D0 46    	jp	z,.umBloco	; somente um bloco, gravar usando CMD24
1690   4672             
1691   4672             ; multiplos blocos
1692   4672              IFDEF DEBUG
1693   4672~            	push	af
1694   4672~            	ld	a,'M'
1695   4672~            	call	PRTCHAR
1696   4672~            	pop	af
1697   4672              ENDIF
1698   4672 C5          	push	bc
1699   4673 D5          	push	de
1700   4674 3E 77       	ld	a, CMD55	; Multiplos blocos, mandar ACMD23 com total de blocos
1701   4676 CD CC 45    	call	SD_SEND_CMD_NO_ARGS
1702   4679 3E 57       	ld	a, ACMD23
1703   467B 01 00 00    	ld	bc, 0
1704   467E 51          	ld	d, c
1705   467F FD 5E 32    	ld	e, (iy+WRKAREA.NUMBLOCKS)	; parametro = total de blocos a gravar
1706   4682 CD D1 45    	call	SD_SEND_CMD_GET_ERROR
1707   4685 D1          	pop	de
1708   4686 C1          	pop	bc
1709   4687 DA FB 46    	jp	c,terminaLeituraEscritaBloco	; erro no ACMD23
1710   468A              IFDEF DEBUG
1711   468A~            	call	PRTDOT
1712   468A              ENDIF
1713   468A 3E 59       	ld	a, CMD25	; comando CMD25 = write multiple blocks
1714   468C CD D1 45    	call	SD_SEND_CMD_GET_ERROR
1715   468F DA FB 46    	jp	c,terminaLeituraEscritaBloco	; erro
1716   4692              IFDEF DEBUG
1717   4692~            	call	PRTDOT
1718   4692              ENDIF
1719   4692             .loop: 
1720   4692              IFDEF DEBUG
1721   4692~            	call	PRTDASH
1722   4692              ENDIF
1723   4692 3E FC       	ld	a, $FC		; mandar $FC para indicar que os proximos dados sao
1724   4694 32 00 7B    	ld	(SPIDATA),a	; dados para gravacao
1725   4697             
1726   4697 11 00 7B    	ld	de,SPIDATA
1727   469A CD 57 4D    	call	RUN_HLPR
1728   469D             
1729   469D             ;	ld	de,$FFFF	; envia dummy CRC
1730   469D             ;	ld	(SPIDATA),de
1731   469D 32 00 7B    	ld	(SPIDATA),a
1732   46A0 32 00 7B    	ld	(SPIDATA),a
1733   46A3 CD 39 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1734   46A6 E6 1F       	and	$1F		; testa bits erro
1735   46A8 FE 05       	cp	5
1736   46AA 37          	scf
1737   46AB C2 FB 46    	jp	nz,terminaLeituraEscritaBloco	; resposta errada, informar erro
1738   46AE CD 48 46    	call	WAIT_RESP_NO_00	; esperar cartao
1739   46B1 DA FB 46    	jp	c,terminaLeituraEscritaBloco
1740   46B4 DD 25       	dec	ixh		; Next block
1741   46B6 C2 92 46    	jp	nz,.loop
1742   46B9             
1743   46B9             ;	ld	hl, (SPIDATA)	; acabou os blocos, fazer 2 dummy reads
1744   46B9 3A 00 7B    	ld	a, (SPIDATA)
1745   46BC 3A 00 7B    	ld	a, (SPIDATA)
1746   46BF 3E FD       	ld	a, $FD		; enviar $FD para informar ao cartao que acabou os dados
1747   46C1 32 00 7B    	ld	(SPIDATA),a
1748   46C4             ;	ld	hl,(SPIDATA)	; 2 dummy reads
1749   46C4 3A 00 7B    	ld	a, (SPIDATA)
1750   46C7 3A 00 7B    	ld	a, (SPIDATA)
1751   46CA CD 48 46    	call	WAIT_RESP_NO_00	; esperar cartao
1752   46CD C3 FA 46    	jp	.fim		; CMD25 concluido, sair informando nenhum erro
1753   46D0             
1754   46D0             .umBloco: 
1755   46D0              IFDEF DEBUG
1756   46D0~            	push	af
1757   46D0~            	ld	a,'S'
1758   46D0~            	call	PRTCHAR
1759   46D0~            	pop	af
1760   46D0              ENDIF
1761   46D0 3E 58       	ld	a, CMD24	; gravar somente um bloco com comando CMD24 = Write Single Block
1762   46D2 CD D1 45    	call	SD_SEND_CMD_GET_ERROR
1763   46D5 DA FB 46    	jp	c,terminaLeituraEscritaBloco	; erro
1764   46D8             
1765   46D8              IFDEF DEBUG
1766   46D8~            	call	PRTDOT
1767   46D8              ENDIF
1768   46D8 3E FE       	ld	a, $FE		; mandar $FE para indicar que vamos mandar dados para gravacao
1769   46DA 32 00 7B    	ld	(SPIDATA),a
1770   46DD             
1771   46DD 11 00 7B    	ld	de,SPIDATA
1772   46E0 CD 57 4D    	call	RUN_HLPR
1773   46E3             
1774   46E3             ;	ld	de,$FFFF	; envia dummy CRC
1775   46E3             ;	ld	(SPIDATA),de
1776   46E3 32 00 7B    	ld	(SPIDATA),a
1777   46E6 32 00 7B    	ld	(SPIDATA),a
1778   46E9 CD 39 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1779   46EC E6 1F       	and	$1F		; testa bits erro
1780   46EE FE 05       	cp	5
1781   46F0 37          	scf
1782   46F1 C2 FB 46    	jp	nz,terminaLeituraEscritaBloco	; resposta errada, informar erro
1783   46F4             .esp: 
1784   46F4 CD 39 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1785   46F7 B7          	or	a
1786   46F8 28 FA       	jr	z,.esp
1787   46FA             .fim: 
1788   46FA AF          	xor	a		; zera carry e informa nenhum erro
1789   46FB             terminaLeituraEscritaBloco: 
1790   46FB             ;	push	af
1791   46FB CD B5 45    	call	disableSDs	; desabilitar todos os cartoes
1792   46FE             ;	pop	af
1793   46FE C9          	ret
1794   46FF             
1795   46FF             
1796   46FF             ; ------------------------------------------------
1797   46FF             ; Ler um bloco de 512 bytes do cartao
1798   46FF             ; HL =  aponta para o inicio dos dados
1799   46FF             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
1800   46FF             ; IXH = Number of blocks
1801   46FF             ; IXL = SDcard version (0 or 1)
1802   46FF             ; Destroi AF, BC, DE, HL, IXL
1803   46FF             ; ------------------------------------------------
1804   46FF             LerBloco: 
1805   46FF             ;	ld	a, (ix+15)	; verificar se eh SDV1 ou SDV2
1806   46FF DD 7D       	ld	a,ixl
1807   4701 B7          	or	a
1808   4702 CC 55 47    	call	z,blocoParaByte	; se for SDV1 coverter blocos para bytes
1809   4705             ;	call	setaSDAtual
1810   4705             
1811   4705 FD 7E 32    	ld	a, (iy+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
1812   4708 DD 67       	ld	ixh,a		; ixh=Number of blocks
1813   470A 3D          	dec	a
1814   470B CA 36 47    	jp	z,.umBloco	; only one block
1815   470E             
1816   470E             ; multiplos blocos
1817   470E 3E 52       	ld	a, CMD18	; ler multiplos blocos com CMD18 = Read Multiple Blocks
1818   4710 CD D1 45    	call	SD_SEND_CMD_GET_ERROR
1819   4713 DA FB 46    	jp	c,terminaLeituraEscritaBloco
1820   4716 EB          	ex	de,hl		; de=Destination address
1821   4717             .loop: 
1822   4717 CD 2B 46    	call	WAIT_RESP_FE
1823   471A DA FB 46    	jp	c,terminaLeituraEscritaBloco
1824   471D             
1825   471D 21 00 7B    	ld	hl, SPIDATA
1826   4720 CD 57 4D    	call	RUN_HLPR
1827   4723             
1828   4723             ;	ld	hl, (SPIDATA)	; descarta CRC
1829   4723 3A 00 7B    	ld	a, (SPIDATA)
1830   4726 3A 00 7B    	ld	a, (SPIDATA)
1831   4729 DD 25       	dec	ixh
1832   472B C2 17 47    	jp	nz,.loop
1833   472E 3E 4C       	ld	a, CMD12	; acabou os blocos, mandar CMD12 para cancelar leitura
1834   4730 CD CC 45    	call	SD_SEND_CMD_NO_ARGS
1835   4733 C3 51 47    	jp	.fim
1836   4736             
1837   4736             .umBloco: 
1838   4736 3E 51       	ld	a, CMD17	; ler somente um bloco com CMD17 = Read Single Block
1839   4738 CD D1 45    	call	SD_SEND_CMD_GET_ERROR
1840   473B DA FB 46    	jp	c,terminaLeituraEscritaBloco
1841   473E             
1842   473E CD 2B 46    	call	WAIT_RESP_FE
1843   4741 DA FB 46    	jp	c,terminaLeituraEscritaBloco
1844   4744 EB          	ex	de,hl
1845   4745             
1846   4745 21 00 7B    	ld	hl, SPIDATA
1847   4748 CD 57 4D    	call	RUN_HLPR
1848   474B             
1849   474B             ;	ld	hl, (SPIDATA)	; descarta CRC
1850   474B 3A 00 7B    	ld	a, (SPIDATA)
1851   474E 3A 00 7B    	ld	a, (SPIDATA)
1852   4751             .fim: 
1853   4751 AF          	xor	a		; zera carry para informar leitura sem erros
1854   4752 C3 FB 46    	jp	terminaLeituraEscritaBloco
1855   4755             
1856   4755             
1857   4755             ; ------------------------------------------------
1858   4755             ; Converte blocos para bytes. Na pratica faz
1859   4755             ; BC DE = (BC DE) * 512
1860   4755             ; ------------------------------------------------
1861   4755             blocoParaByte: 
1862   4755 41          	ld	b, c
1863   4756 4A          	ld	c, d
1864   4757 53          	ld	d, e
1865   4758 1E 00       	ld	e, 0
1866   475A CB 22       	sla	d
1867   475C CB 11       	rl	c
1868   475E CB 10       	rl	b
1869   4760 C9          	ret
1870   4761             
1871   4761             ; ------------------------------------------------
1872   4761             ; Funcoes utilitarias
1873   4761             ; ------------------------------------------------
1874   4761             
1875   4761             
1876   4761             ; ------------------------------------------------
1877   4761             ; Imprime string na tela apontada por DE
1878   4761             ; Destroi todos os registradores
1879   4761             ; ------------------------------------------------
1880   4761             printString: 
1881   4761 1A          	ld	a, (de)
1882   4762 B7          	or	a
1883   4763 C8          	ret	z
1884   4764 CD A2 00    	call	CHPUT
1885   4767 13          	inc	de
1886   4768 18 F7       	jr	printString
1887   476A             
1888   476A             
1889   476A             ; ------------------------------------------------
1890   476A             ; Converte o byte em A para string em decimal no
1891   476A             ; buffer apontado por DE
1892   476A             ; Destroi AF, BC, HL, DE
1893   476A             ; ------------------------------------------------
1894   476A             DecToAscii: 
1895   476A 26 00       	ld	h, 0
1896   476C 6F          	ld	l, a		; copiar A para HL
1897   476D FD 36 39 01 	ld	(iy+WRKAREA.TEMP),1	; flag para indicar que devemos cortar os zeros a esquerda
1898   4771 01 9C FF    	ld	bc, -100	; centenas
1899   4774 CD 82 47    	call	.num1
1900   4777 0E F6       	ld	c, -10		; dezenas
1901   4779 CD 82 47    	call	.num1
1902   477C FD 36 39 02 	ld	(iy+WRKAREA.TEMP),2	; unidade deve exibir 0 se for zero e nao corta-lo
1903   4780 0E FF       	ld	c, -1		; unidades
1904   4782             .num1: 
1905   4782 3E 2F       	ld	a, '0'-1
1906   4784             .num2: 
1907   4784 3C          	inc	a		; contar o valor em ascii de '0' a '9'
1908   4785 09          	add	hl, bc		; somar com negativo
1909   4786 38 FC       	jr	c,.num2		; ainda nao zeramos
1910   4788 ED 42       	sbc	hl, bc		; retoma valor original
1911   478A FD 35 39    	dec	(iy+WRKAREA.TEMP)	; se flag do corte do zero indicar para nao cortar, pula
1912   478D 20 08       	jr	nz,.naozero
1913   478F FE 30       	cp	'0'		; devemos cortar os zeros a esquerda. Eh zero?
1914   4791 20 04       	jr	nz,.naozero
1915   4793 FD 34 39    	inc	(iy+WRKAREA.TEMP)	; se for zero, nao salvamos e voltamos a flag
1916   4796 C9          	ret
1917   4797             .naozero: 
1918   4797 12          	ld	(de), a		; eh zero ou eh outro numero, salvar
1919   4798 13          	inc	de		; incrementa ponteiro de destino
1920   4799 C9          	ret
1921   479A             
1922   479A             ; ------------------------------------------------
1923   479A             ; Converte o byte em A para string em hexa no
1924   479A             ; buffer apontado por DE
1925   479A             ; Destroi AF, C, DE
1926   479A             ; ------------------------------------------------
1927   479A             HexToAscii: 
1928   479A 4F          	ld	c, a
1929   479B 1F          	rra
1930   479C 1F          	rra
1931   479D 1F          	rra
1932   479E 1F          	rra
1933   479F CD A3 47    	call	.conv
1934   47A2 79          	ld  	a, c
1935   47A3             .conv: 
1936   47A3 E6 0F       	and	$0F
1937   47A5 C6 90       	add	a, $90
1938   47A7 27          	daa
1939   47A8 CE 40       	adc	a, $40
1940   47AA 27          	daa
1941   47AB 12          	ld	(de), a
1942   47AC 13          	inc	de
1943   47AD C9          	ret
1944   47AE             
1945   47AE             ; ------------------------------------------------
1946   47AE             ; Converte o byte em A para string em decimal e
1947   47AE             ; imprime na tela
1948   47AE             ; Destroi AF, BC, HL, DE
1949   47AE             ; ------------------------------------------------
1950   47AE             printDecToAscii: 
1951   47AE 26 00       	ld	h, 0
1952   47B0 6F          	ld	l, a		; copiar A para HL
1953   47B1 06 01       	ld	b, 1		; flag para indicar que devemos cortar os zeros a esquerda
1954   47B3 11 9C FF    	ld	de, -100	; centenas
1955   47B6 CD C2 47    	call	.num1
1956   47B9 1E F6       	ld	e, -10		; dezenas
1957   47BB CD C2 47    	call	.num1
1958   47BE 06 02       	ld	b, 2		; unidade deve exibir 0 se for zero e nao corta-lo
1959   47C0 1E FF       	ld	e, -1		; unidades
1960   47C2             .num1: 
1961   47C2 3E 2F       	ld	a, '0'-1
1962   47C4             .num2: 
1963   47C4 3C          	inc	a		; contar o valor em ascii de '0' a '9'
1964   47C5 19          	add	hl, de		; somar com negativo
1965   47C6 38 FC       	jr	c,.num2		; ainda nao zeramos
1966   47C8 ED 52       	sbc	hl, de		; retoma valor original
1967   47CA 10 06       	djnz	.naozero	; se flag do corte do zero indicar para nao cortar, pula
1968   47CC FE 30       	cp	'0'		; devemos cortar os zeros a esquerda. Eh zero?
1969   47CE 20 02       	jr	nz,.naozero
1970   47D0 04          	inc	b		; se for zero, nao imprimimos e voltamos a flag
1971   47D1 C9          	ret
1972   47D2             .naozero: 
1973   47D2 E5          	push	hl		; nao eh zero ou eh outro numero, imprimir
1974   47D3 C5          	push	bc
1975   47D4 CD A2 00    	call	CHPUT
1976   47D7 C1          	pop	bc
1977   47D8 E1          	pop	hl
1978   47D9 C9          	ret
1979   47DA             
1980   47DA             ; ------------------------------------------------
1981   47DA             ; Procura pelo nome do fabricante em uma tabela.
1982   47DA             ; A contem o byte do fabricante
1983   47DA             ; Devolve HL apontando para o buffer do fabricante
1984   47DA             ; e BC com o comprimento do texto
1985   47DA             ; Destroi AF, BC, HL
1986   47DA             ; ------------------------------------------------
1987   47DA             pegaFabricante: 
1988   47DA 4F          	ld	c, a
1989   47DB 21 FC 47    	ld	hl, tblFabricantes
1990   47DE             
1991   47DE             .loop: 
1992   47DE 7E          	ld	a, (hl)
1993   47DF 23          	inc	hl
1994   47E0 B9          	cp	c
1995   47E1 28 0C       	jr	z,.achado
1996   47E3 B7          	or	a
1997   47E4 28 09       	jr	z,.achado
1998   47E6 C5          	push	bc
1999   47E7 CD EF 47    	call	.achado
2000   47EA 09          	add	hl, bc
2001   47EB 23          	inc	hl
2002   47EC C1          	pop	bc
2003   47ED 18 EF       	jr	.loop
2004   47EF             
2005   47EF             .achado: 
2006   47EF 0E 00       	ld	c, 0
2007   47F1 E5          	push	hl
2008   47F2 AF          	xor	a
2009   47F3             .loop2: 
2010   47F3 0C          	inc	c
2011   47F4 23          	inc	hl
2012   47F5 BE          	cp	(hl)
2013   47F6 20 FB       	jr	nz,.loop2
2014   47F8 E1          	pop	hl
2015   47F9 06 00       	ld	b, 0
2016   47FB C9          	ret
2017   47FC             
2018   47FC             tblFabricantes: 
2019   47FC 01          	db	1
2020   47FD             	db	"Panasonic",0
2020   47FD 50616E61736F6E696300
2021   4807 02          	db	2
2022   4808             	db	"Toshiba",0
2022   4808 546F736869626100
2023   4810 03          	db	3
2024   4811             	db	"SanDisk",0
2024   4811 53616E4469736B00
2025   4819 04          	db	4
2026   481A             	db	"SMI-S",0
2026   481A 534D492D5300
2027   4820 06          	db	6
2028   4821             	db	"Renesas",0
2028   4821 52656E6573617300
2029   4829 11          	db	17
2030   482A             	db	"Dane-Elec",0
2030   482A 44616E652D456C656300
2031   4834 13          	db	19
2032   4835             	db	"KingMax",0
2032   4835 4B696E674D617800
2033   483D 15          	db	21
2034   483E             	db	"Samsung",0
2034   483E 53616D73756E6700
2035   4846 18          	db	24
2036   4847             	db	"Infineon",0
2036   4847 496E66696E656F6E00
2037   4850 1A          	db	26
2038   4851 50 51 49 00 	db	"PQI",0
2039   4855 1B          	db	27
2040   4856 536F6E7900  	db	"Sony",0
2041   485B 1C          	db	28
2042   485C             	db	"Transcend",0
2042   485C 5472616E7363656E6400
2043   4866 1D          	db	29
2044   4867             	db	"A-DATA",0
2044   4867 412D4441544100
2045   486E 1F          	db	31
2046   486F             	db	"SiliconPower",0
2046   486F 53696C69636F6E506F77657200
2047   487C 27          	db	39
2048   487D             	db	"Verbatim",0
2048   487D 566572626174696D00
2049   4886 41          	db	65
2050   4887 4F 4B 49 00 	db	"OKI",0
2051   488B 73          	db	115
2052   488C             	db	"SilverHT",0
2052   488C 53696C766572485400
2053   4895 89          	db	137
2054   4896             	db	"L.Data",0
2054   4896 4C2E4461746100
2055   489D 00          	db	0
2056   489E             	db	"Generico",0
2056   489E 47656E657269636F00
2057   48A7             
2058   48A7             
2059   48A7             ; ------------------------------------------------
2060   48A7             ; Restore screen parameters on MSX>=2 if they're
2061   48A7             ; not set yet
2062   48A7             ; ------------------------------------------------
2063   48A7             MYSETSCR: 
2064   48A7 3A 2D 00    	ld	a,(MSXVER)
2065   48AA B7          	or	a			; MSX1?
2066   48AB 20 08       	jr	nz,.notMSX1		; No, skip
2067   48AD             .MSX1: 
2068   48AD 3A AF FC    	ld	a,(SCRMOD)
2069   48B0 B7          	or	a			; SCREEN0 already?
2070   48B1 C8          	ret	z			; Yes, quit
2071   48B2 C3 6C 00    	jp	INITXT			; set screen0
2072   48B5             
2073   48B5             .notMSX1: 
2074   48B5 0E 23       	ld	c,$23			; Block-2, R#3
2075   48B7 DD 21 F5 01 	ld 	ix,REDCLK
2076   48BB CD 5F 01    	call	EXTROM
2077   48BE E6 01       	and	1
2078   48C0 47          	ld	b,a
2079   48C1 3A AF FC    	ld	a,(SCRMOD)
2080   48C4 B8          	cp	b
2081   48C5 20 1C       	jr	nz,.restore
2082   48C7 0C          	inc	c
2083   48C8 DD 21 F5 01 	ld 	ix,REDCLK
2084   48CC CD 5F 01    	call	EXTROM
2085   48CF 47          	ld	b,a
2086   48D0 0C          	inc	c
2087   48D1 DD 21 F5 01 	ld 	ix,REDCLK
2088   48D5 CD 5F 01    	call	EXTROM
2089   48D8 87          	add	a,a
2090   48D9 87          	add	a,a
2091   48DA 87          	add	a,a
2092   48DB 87          	add	a,a
2093   48DC B0          	or	b
2094   48DD 47          	ld	b,a
2095   48DE 3A B0 F3    	ld	a,(LINLEN)
2096   48E1 B8          	cp	b
2097   48E2 C8          	ret	z
2098   48E3             .restore: 
2099   48E3 AF          	xor	a		; Don't displat the function keys
2100   48E4 DD 21 85 01 	ld	ix,SDFSCR
2101   48E8 C3 5F 01    	jp	EXTROM
2102   48EB             
2103   48EB             ; ------------------------------------------------
2104   48EB             ; Check if the STOP key was signaled on DRV_INIT
2105   48EB             ; ------------------------------------------------
2106   48EB             INICHKSTOP: 
2107   48EB 3A 9B FC    	ld	a,(INTFLG)
2108   48EE FE 04       	cp	4			; Was STOP pressed?
2109   48F0 C0          	ret	nz			; No, quit as fast as possible 
2110   48F1             
2111   48F1             	; Handle STOP to pause and read messages, and ask for the copyright info
2112   48F1 11 8F 4D    	ld	de,strBootpaused
2113   48F4 CD 61 47    	call	printString
2114   48F7 3E 07       .wait1: 	ld	a,7
2115   48F9 CD 41 01    	call	SNSMAT
2116   48FC E6 10       	and	$10			; Is STOP still pressed?
2117   48FE 28 F7       	jr	z,.wait1		; Wait for STOP to be released
2118   4900 AF          	xor	a
2119   4901 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2120   4904 06 00       	ld	b,0			; b=inhibit 'i' key flag
2121   4906 CD 9C 00    .wait2:  call	CHSNS
2122   4909 C4 26 49    	call	nz,.chkikey		; Wait until a key is pressed
2123   490C 3A 9B FC    	ld	a,(INTFLG)
2124   490F FE 04       	cp	4			; Was STOP pressed?
2125   4911 20 F3       	jr	nz,.wait2		; No, return
2126   4913 AF          	xor	a
2127   4914 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2128   4917 CD 56 01    	call	KILBUF
2129   491A 06 1E       	ld	b,30			; Since the user is trying pause the
2130   491C 76          .wait3: 	halt				; boot messages, this gives him enough
2131   491D             					; time to react and pause the next
2132   491D             					; driver
2133   491D 3A 9B FC    	ld	a,(INTFLG)
2134   4920 FE 04       	cp	4			; Was STOP pressed?
2135   4922 C8          	ret	z			; quit so the next driver can process it
2136   4923 10 F7       	djnz	.wait3			; The user will have the impression
2137   4925             					; that he has a perfect timing.   ;)
2138   4925 C9          	ret
2139   4926             
2140   4926             .chkikey: 
2141   4926 CB 40       	bit	0,b			; Was the copyright message shown?
2142   4928 C0          	ret	nz			; Yes, return
2143   4929 CD 9F 00    	call	CHGET
2144   492C FE 69       	cp	'i'
2145   492E 28 03       	jr	z,.showcopyright
2146   4930 FE 49       	cp	'I'
2147   4932 C0          	ret	nz
2148   4933             .showcopyright: 
2149   4933 04          	inc	b			; Inhibit further presses of the i key 
2150   4934 11 BA 4D    	ld	de,strCopyright
2151   4937 C3 61 47    	jp	printString
2152   493A             
2153   493A             
2154   493A             
2155   493A             ; ------------------------------------------------
2156   493A             ; Install the R800 data transfer helper routine on WorkArea 
2157   493A             ; ------------------------------------------------
2158   493A             INSTR800HLP: 
2159   493A 3A 2D 00    	ld	a,(MSXVER)
2160   493D FE 03       	cp	3		; MSX Turbo-R?
2161   493F D8          	ret	c		; No, return
2162   4940 CD 66 4D    	call	GTR800LDIR
2163   4943 D9          	exx
2164   4944 EB          	ex	de,hl
2165   4945 21 4E 49    	ld	hl,R800DATHLP
2166   4948 01 07 00    	ld	bc,R800DATHLP.end-R800DATHLP
2167   494B ED B0       	ldir
2168   494D C9          	ret
2169   494E             
2170   494E             ; ------------------------------------------------
2171   494E             ; R800 optimized data transfer routine, copied to the WorkArea
2172   494E             ; ------------------------------------------------
2173   494E             R800DATHLP: 
2174   494E D9          	exx
2175   494F 01 00 02    	ld	bc,512
2176   4952 ED B0       	ldir
2177   4954 C9          	ret
2178   4955             .end
2179   4955              
2180   4955             
2181   4955             ; ------------------------------------------------
2182   4955             ; Z80 optimized data transfer routine, kept in ROM 
2183   4955             ; ------------------------------------------------
2184   4955             LDI512: 	; Z80 optimized 512 byte transfer
2185   4955 D9          	exx
2186   4956 ED A0       > ldi
2186   4958 ED A0       > ldi
2186   495A ED A0       > ldi
2186   495C ED A0       > ldi
2186   495E ED A0       > ldi
2186   4960 ED A0       > ldi
2186   4962 ED A0       > ldi
2186   4964 ED A0       > ldi
2186   4966 ED A0       > ldi
2186   4968 ED A0       > ldi
2186   496A ED A0       > ldi
2186   496C ED A0       > ldi
2186   496E ED A0       > ldi
2186   4970 ED A0       > ldi
2186   4972 ED A0       > ldi
2186   4974 ED A0       > ldi
2186   4976 ED A0       > ldi
2186   4978 ED A0       > ldi
2186   497A ED A0       > ldi
2186   497C ED A0       > ldi
2186   497E ED A0       > ldi
2186   4980 ED A0       > ldi
2186   4982 ED A0       > ldi
2186   4984 ED A0       > ldi
2186   4986 ED A0       > ldi
2186   4988 ED A0       > ldi
2186   498A ED A0       > ldi
2186   498C ED A0       > ldi
2186   498E ED A0       > ldi
2186   4990 ED A0       > ldi
2186   4992 ED A0       > ldi
2186   4994 ED A0       > ldi
2186   4996 ED A0       > ldi
2186   4998 ED A0       > ldi
2186   499A ED A0       > ldi
2186   499C ED A0       > ldi
2186   499E ED A0       > ldi
2186   49A0 ED A0       > ldi
2186   49A2 ED A0       > ldi
2186   49A4 ED A0       > ldi
2186   49A6 ED A0       > ldi
2186   49A8 ED A0       > ldi
2186   49AA ED A0       > ldi
2186   49AC ED A0       > ldi
2186   49AE ED A0       > ldi
2186   49B0 ED A0       > ldi
2186   49B2 ED A0       > ldi
2186   49B4 ED A0       > ldi
2186   49B6 ED A0       > ldi
2186   49B8 ED A0       > ldi
2186   49BA ED A0       > ldi
2186   49BC ED A0       > ldi
2186   49BE ED A0       > ldi
2186   49C0 ED A0       > ldi
2186   49C2 ED A0       > ldi
2186   49C4 ED A0       > ldi
2186   49C6 ED A0       > ldi
2186   49C8 ED A0       > ldi
2186   49CA ED A0       > ldi
2186   49CC ED A0       > ldi
2186   49CE ED A0       > ldi
2186   49D0 ED A0       > ldi
2186   49D2 ED A0       > ldi
2186   49D4 ED A0       > ldi
2186   49D6 ED A0       > ldi
2186   49D8 ED A0       > ldi
2186   49DA ED A0       > ldi
2186   49DC ED A0       > ldi
2186   49DE ED A0       > ldi
2186   49E0 ED A0       > ldi
2186   49E2 ED A0       > ldi
2186   49E4 ED A0       > ldi
2186   49E6 ED A0       > ldi
2186   49E8 ED A0       > ldi
2186   49EA ED A0       > ldi
2186   49EC ED A0       > ldi
2186   49EE ED A0       > ldi
2186   49F0 ED A0       > ldi
2186   49F2 ED A0       > ldi
2186   49F4 ED A0       > ldi
2186   49F6 ED A0       > ldi
2186   49F8 ED A0       > ldi
2186   49FA ED A0       > ldi
2186   49FC ED A0       > ldi
2186   49FE ED A0       > ldi
2186   4A00 ED A0       > ldi
2186   4A02 ED A0       > ldi
2186   4A04 ED A0       > ldi
2186   4A06 ED A0       > ldi
2186   4A08 ED A0       > ldi
2186   4A0A ED A0       > ldi
2186   4A0C ED A0       > ldi
2186   4A0E ED A0       > ldi
2186   4A10 ED A0       > ldi
2186   4A12 ED A0       > ldi
2186   4A14 ED A0       > ldi
2186   4A16 ED A0       > ldi
2186   4A18 ED A0       > ldi
2186   4A1A ED A0       > ldi
2186   4A1C ED A0       > ldi
2186   4A1E ED A0       > ldi
2186   4A20 ED A0       > ldi
2186   4A22 ED A0       > ldi
2186   4A24 ED A0       > ldi
2186   4A26 ED A0       > ldi
2186   4A28 ED A0       > ldi
2186   4A2A ED A0       > ldi
2186   4A2C ED A0       > ldi
2186   4A2E ED A0       > ldi
2186   4A30 ED A0       > ldi
2186   4A32 ED A0       > ldi
2186   4A34 ED A0       > ldi
2186   4A36 ED A0       > ldi
2186   4A38 ED A0       > ldi
2186   4A3A ED A0       > ldi
2186   4A3C ED A0       > ldi
2186   4A3E ED A0       > ldi
2186   4A40 ED A0       > ldi
2186   4A42 ED A0       > ldi
2186   4A44 ED A0       > ldi
2186   4A46 ED A0       > ldi
2186   4A48 ED A0       > ldi
2186   4A4A ED A0       > ldi
2186   4A4C ED A0       > ldi
2186   4A4E ED A0       > ldi
2186   4A50 ED A0       > ldi
2186   4A52 ED A0       > ldi
2186   4A54 ED A0       > ldi
2186   4A56 ED A0       > ldi
2186   4A58 ED A0       > ldi
2186   4A5A ED A0       > ldi
2186   4A5C ED A0       > ldi
2186   4A5E ED A0       > ldi
2186   4A60 ED A0       > ldi
2186   4A62 ED A0       > ldi
2186   4A64 ED A0       > ldi
2186   4A66 ED A0       > ldi
2186   4A68 ED A0       > ldi
2186   4A6A ED A0       > ldi
2186   4A6C ED A0       > ldi
2186   4A6E ED A0       > ldi
2186   4A70 ED A0       > ldi
2186   4A72 ED A0       > ldi
2186   4A74 ED A0       > ldi
2186   4A76 ED A0       > ldi
2186   4A78 ED A0       > ldi
2186   4A7A ED A0       > ldi
2186   4A7C ED A0       > ldi
2186   4A7E ED A0       > ldi
2186   4A80 ED A0       > ldi
2186   4A82 ED A0       > ldi
2186   4A84 ED A0       > ldi
2186   4A86 ED A0       > ldi
2186   4A88 ED A0       > ldi
2186   4A8A ED A0       > ldi
2186   4A8C ED A0       > ldi
2186   4A8E ED A0       > ldi
2186   4A90 ED A0       > ldi
2186   4A92 ED A0       > ldi
2186   4A94 ED A0       > ldi
2186   4A96 ED A0       > ldi
2186   4A98 ED A0       > ldi
2186   4A9A ED A0       > ldi
2186   4A9C ED A0       > ldi
2186   4A9E ED A0       > ldi
2186   4AA0 ED A0       > ldi
2186   4AA2 ED A0       > ldi
2186   4AA4 ED A0       > ldi
2186   4AA6 ED A0       > ldi
2186   4AA8 ED A0       > ldi
2186   4AAA ED A0       > ldi
2186   4AAC ED A0       > ldi
2186   4AAE ED A0       > ldi
2186   4AB0 ED A0       > ldi
2186   4AB2 ED A0       > ldi
2186   4AB4 ED A0       > ldi
2186   4AB6 ED A0       > ldi
2186   4AB8 ED A0       > ldi
2186   4ABA ED A0       > ldi
2186   4ABC ED A0       > ldi
2186   4ABE ED A0       > ldi
2186   4AC0 ED A0       > ldi
2186   4AC2 ED A0       > ldi
2186   4AC4 ED A0       > ldi
2186   4AC6 ED A0       > ldi
2186   4AC8 ED A0       > ldi
2186   4ACA ED A0       > ldi
2186   4ACC ED A0       > ldi
2186   4ACE ED A0       > ldi
2186   4AD0 ED A0       > ldi
2186   4AD2 ED A0       > ldi
2186   4AD4 ED A0       > ldi
2186   4AD6 ED A0       > ldi
2186   4AD8 ED A0       > ldi
2186   4ADA ED A0       > ldi
2186   4ADC ED A0       > ldi
2186   4ADE ED A0       > ldi
2186   4AE0 ED A0       > ldi
2186   4AE2 ED A0       > ldi
2186   4AE4 ED A0       > ldi
2186   4AE6 ED A0       > ldi
2186   4AE8 ED A0       > ldi
2186   4AEA ED A0       > ldi
2186   4AEC ED A0       > ldi
2186   4AEE ED A0       > ldi
2186   4AF0 ED A0       > ldi
2186   4AF2 ED A0       > ldi
2186   4AF4 ED A0       > ldi
2186   4AF6 ED A0       > ldi
2186   4AF8 ED A0       > ldi
2186   4AFA ED A0       > ldi
2186   4AFC ED A0       > ldi
2186   4AFE ED A0       > ldi
2186   4B00 ED A0       > ldi
2186   4B02 ED A0       > ldi
2186   4B04 ED A0       > ldi
2186   4B06 ED A0       > ldi
2186   4B08 ED A0       > ldi
2186   4B0A ED A0       > ldi
2186   4B0C ED A0       > ldi
2186   4B0E ED A0       > ldi
2186   4B10 ED A0       > ldi
2186   4B12 ED A0       > ldi
2186   4B14 ED A0       > ldi
2186   4B16 ED A0       > ldi
2186   4B18 ED A0       > ldi
2186   4B1A ED A0       > ldi
2186   4B1C ED A0       > ldi
2186   4B1E ED A0       > ldi
2186   4B20 ED A0       > ldi
2186   4B22 ED A0       > ldi
2186   4B24 ED A0       > ldi
2186   4B26 ED A0       > ldi
2186   4B28 ED A0       > ldi
2186   4B2A ED A0       > ldi
2186   4B2C ED A0       > ldi
2186   4B2E ED A0       > ldi
2186   4B30 ED A0       > ldi
2186   4B32 ED A0       > ldi
2186   4B34 ED A0       > ldi
2186   4B36 ED A0       > ldi
2186   4B38 ED A0       > ldi
2186   4B3A ED A0       > ldi
2186   4B3C ED A0       > ldi
2186   4B3E ED A0       > ldi
2186   4B40 ED A0       > ldi
2186   4B42 ED A0       > ldi
2186   4B44 ED A0       > ldi
2186   4B46 ED A0       > ldi
2186   4B48 ED A0       > ldi
2186   4B4A ED A0       > ldi
2186   4B4C ED A0       > ldi
2186   4B4E ED A0       > ldi
2186   4B50 ED A0       > ldi
2186   4B52 ED A0       > ldi
2186   4B54 ED A0       > ldi
2186   4B56 ED A0       > ldi
2186   4B58 ED A0       > ldi
2186   4B5A ED A0       > ldi
2186   4B5C ED A0       > ldi
2186   4B5E ED A0       > ldi
2186   4B60 ED A0       > ldi
2186   4B62 ED A0       > ldi
2186   4B64 ED A0       > ldi
2186   4B66 ED A0       > ldi
2186   4B68 ED A0       > ldi
2186   4B6A ED A0       > ldi
2186   4B6C ED A0       > ldi
2186   4B6E ED A0       > ldi
2186   4B70 ED A0       > ldi
2186   4B72 ED A0       > ldi
2186   4B74 ED A0       > ldi
2186   4B76 ED A0       > ldi
2186   4B78 ED A0       > ldi
2186   4B7A ED A0       > ldi
2186   4B7C ED A0       > ldi
2186   4B7E ED A0       > ldi
2186   4B80 ED A0       > ldi
2186   4B82 ED A0       > ldi
2186   4B84 ED A0       > ldi
2186   4B86 ED A0       > ldi
2186   4B88 ED A0       > ldi
2186   4B8A ED A0       > ldi
2186   4B8C ED A0       > ldi
2186   4B8E ED A0       > ldi
2186   4B90 ED A0       > ldi
2186   4B92 ED A0       > ldi
2186   4B94 ED A0       > ldi
2186   4B96 ED A0       > ldi
2186   4B98 ED A0       > ldi
2186   4B9A ED A0       > ldi
2186   4B9C ED A0       > ldi
2186   4B9E ED A0       > ldi
2186   4BA0 ED A0       > ldi
2186   4BA2 ED A0       > ldi
2186   4BA4 ED A0       > ldi
2186   4BA6 ED A0       > ldi
2186   4BA8 ED A0       > ldi
2186   4BAA ED A0       > ldi
2186   4BAC ED A0       > ldi
2186   4BAE ED A0       > ldi
2186   4BB0 ED A0       > ldi
2186   4BB2 ED A0       > ldi
2186   4BB4 ED A0       > ldi
2186   4BB6 ED A0       > ldi
2186   4BB8 ED A0       > ldi
2186   4BBA ED A0       > ldi
2186   4BBC ED A0       > ldi
2186   4BBE ED A0       > ldi
2186   4BC0 ED A0       > ldi
2186   4BC2 ED A0       > ldi
2186   4BC4 ED A0       > ldi
2186   4BC6 ED A0       > ldi
2186   4BC8 ED A0       > ldi
2186   4BCA ED A0       > ldi
2186   4BCC ED A0       > ldi
2186   4BCE ED A0       > ldi
2186   4BD0 ED A0       > ldi
2186   4BD2 ED A0       > ldi
2186   4BD4 ED A0       > ldi
2186   4BD6 ED A0       > ldi
2186   4BD8 ED A0       > ldi
2186   4BDA ED A0       > ldi
2186   4BDC ED A0       > ldi
2186   4BDE ED A0       > ldi
2186   4BE0 ED A0       > ldi
2186   4BE2 ED A0       > ldi
2186   4BE4 ED A0       > ldi
2186   4BE6 ED A0       > ldi
2186   4BE8 ED A0       > ldi
2186   4BEA ED A0       > ldi
2186   4BEC ED A0       > ldi
2186   4BEE ED A0       > ldi
2186   4BF0 ED A0       > ldi
2186   4BF2 ED A0       > ldi
2186   4BF4 ED A0       > ldi
2186   4BF6 ED A0       > ldi
2186   4BF8 ED A0       > ldi
2186   4BFA ED A0       > ldi
2186   4BFC ED A0       > ldi
2186   4BFE ED A0       > ldi
2186   4C00 ED A0       > ldi
2186   4C02 ED A0       > ldi
2186   4C04 ED A0       > ldi
2186   4C06 ED A0       > ldi
2186   4C08 ED A0       > ldi
2186   4C0A ED A0       > ldi
2186   4C0C ED A0       > ldi
2186   4C0E ED A0       > ldi
2186   4C10 ED A0       > ldi
2186   4C12 ED A0       > ldi
2186   4C14 ED A0       > ldi
2186   4C16 ED A0       > ldi
2186   4C18 ED A0       > ldi
2186   4C1A ED A0       > ldi
2186   4C1C ED A0       > ldi
2186   4C1E ED A0       > ldi
2186   4C20 ED A0       > ldi
2186   4C22 ED A0       > ldi
2186   4C24 ED A0       > ldi
2186   4C26 ED A0       > ldi
2186   4C28 ED A0       > ldi
2186   4C2A ED A0       > ldi
2186   4C2C ED A0       > ldi
2186   4C2E ED A0       > ldi
2186   4C30 ED A0       > ldi
2186   4C32 ED A0       > ldi
2186   4C34 ED A0       > ldi
2186   4C36 ED A0       > ldi
2186   4C38 ED A0       > ldi
2186   4C3A ED A0       > ldi
2186   4C3C ED A0       > ldi
2186   4C3E ED A0       > ldi
2186   4C40 ED A0       > ldi
2186   4C42 ED A0       > ldi
2186   4C44 ED A0       > ldi
2186   4C46 ED A0       > ldi
2186   4C48 ED A0       > ldi
2186   4C4A ED A0       > ldi
2186   4C4C ED A0       > ldi
2186   4C4E ED A0       > ldi
2186   4C50 ED A0       > ldi
2186   4C52 ED A0       > ldi
2186   4C54 ED A0       > ldi
2186   4C56 ED A0       > ldi
2186   4C58 ED A0       > ldi
2186   4C5A ED A0       > ldi
2186   4C5C ED A0       > ldi
2186   4C5E ED A0       > ldi
2186   4C60 ED A0       > ldi
2186   4C62 ED A0       > ldi
2186   4C64 ED A0       > ldi
2186   4C66 ED A0       > ldi
2186   4C68 ED A0       > ldi
2186   4C6A ED A0       > ldi
2186   4C6C ED A0       > ldi
2186   4C6E ED A0       > ldi
2186   4C70 ED A0       > ldi
2186   4C72 ED A0       > ldi
2186   4C74 ED A0       > ldi
2186   4C76 ED A0       > ldi
2186   4C78 ED A0       > ldi
2186   4C7A ED A0       > ldi
2186   4C7C ED A0       > ldi
2186   4C7E ED A0       > ldi
2186   4C80 ED A0       > ldi
2186   4C82 ED A0       > ldi
2186   4C84 ED A0       > ldi
2186   4C86 ED A0       > ldi
2186   4C88 ED A0       > ldi
2186   4C8A ED A0       > ldi
2186   4C8C ED A0       > ldi
2186   4C8E ED A0       > ldi
2186   4C90 ED A0       > ldi
2186   4C92 ED A0       > ldi
2186   4C94 ED A0       > ldi
2186   4C96 ED A0       > ldi
2186   4C98 ED A0       > ldi
2186   4C9A ED A0       > ldi
2186   4C9C ED A0       > ldi
2186   4C9E ED A0       > ldi
2186   4CA0 ED A0       > ldi
2186   4CA2 ED A0       > ldi
2186   4CA4 ED A0       > ldi
2186   4CA6 ED A0       > ldi
2186   4CA8 ED A0       > ldi
2186   4CAA ED A0       > ldi
2186   4CAC ED A0       > ldi
2186   4CAE ED A0       > ldi
2186   4CB0 ED A0       > ldi
2186   4CB2 ED A0       > ldi
2186   4CB4 ED A0       > ldi
2186   4CB6 ED A0       > ldi
2186   4CB8 ED A0       > ldi
2186   4CBA ED A0       > ldi
2186   4CBC ED A0       > ldi
2186   4CBE ED A0       > ldi
2186   4CC0 ED A0       > ldi
2186   4CC2 ED A0       > ldi
2186   4CC4 ED A0       > ldi
2186   4CC6 ED A0       > ldi
2186   4CC8 ED A0       > ldi
2186   4CCA ED A0       > ldi
2186   4CCC ED A0       > ldi
2186   4CCE ED A0       > ldi
2186   4CD0 ED A0       > ldi
2186   4CD2 ED A0       > ldi
2186   4CD4 ED A0       > ldi
2186   4CD6 ED A0       > ldi
2186   4CD8 ED A0       > ldi
2186   4CDA ED A0       > ldi
2186   4CDC ED A0       > ldi
2186   4CDE ED A0       > ldi
2186   4CE0 ED A0       > ldi
2186   4CE2 ED A0       > ldi
2186   4CE4 ED A0       > ldi
2186   4CE6 ED A0       > ldi
2186   4CE8 ED A0       > ldi
2186   4CEA ED A0       > ldi
2186   4CEC ED A0       > ldi
2186   4CEE ED A0       > ldi
2186   4CF0 ED A0       > ldi
2186   4CF2 ED A0       > ldi
2186   4CF4 ED A0       > ldi
2186   4CF6 ED A0       > ldi
2186   4CF8 ED A0       > ldi
2186   4CFA ED A0       > ldi
2186   4CFC ED A0       > ldi
2186   4CFE ED A0       > ldi
2186   4D00 ED A0       > ldi
2186   4D02 ED A0       > ldi
2186   4D04 ED A0       > ldi
2186   4D06 ED A0       > ldi
2186   4D08 ED A0       > ldi
2186   4D0A ED A0       > ldi
2186   4D0C ED A0       > ldi
2186   4D0E ED A0       > ldi
2186   4D10 ED A0       > ldi
2186   4D12 ED A0       > ldi
2186   4D14 ED A0       > ldi
2186   4D16 ED A0       > ldi
2186   4D18 ED A0       > ldi
2186   4D1A ED A0       > ldi
2186   4D1C ED A0       > ldi
2186   4D1E ED A0       > ldi
2186   4D20 ED A0       > ldi
2186   4D22 ED A0       > ldi
2186   4D24 ED A0       > ldi
2186   4D26 ED A0       > ldi
2186   4D28 ED A0       > ldi
2186   4D2A ED A0       > ldi
2186   4D2C ED A0       > ldi
2186   4D2E ED A0       > ldi
2186   4D30 ED A0       > ldi
2186   4D32 ED A0       > ldi
2186   4D34 ED A0       > ldi
2186   4D36 ED A0       > ldi
2186   4D38 ED A0       > ldi
2186   4D3A ED A0       > ldi
2186   4D3C ED A0       > ldi
2186   4D3E ED A0       > ldi
2186   4D40 ED A0       > ldi
2186   4D42 ED A0       > ldi
2186   4D44 ED A0       > ldi
2186   4D46 ED A0       > ldi
2186   4D48 ED A0       > ldi
2186   4D4A ED A0       > ldi
2186   4D4C ED A0       > ldi
2186   4D4E ED A0       > ldi
2186   4D50 ED A0       > ldi
2186   4D52 ED A0       > ldi
2186   4D54 ED A0       > ldi
2187   4D56 C9          	ret
2188   4D57             
2189   4D57             ; ------------------------------------------------
2190   4D57             ; Jumps to a helper routine, usually in RAM
2191   4D57             ; Input: HL': Address of the target routine
2192   4D57             ; ------------------------------------------------
2193   4D57             RUN_HLPR: 
2194   4D57 D9          	exx
2195   4D58 E9          	jp	(hl)
2196   4D59             
2197   4D59             ; ------------------------------------------------
2198   4D59             ; Setup the arbitrary block size LDIR helper to be used
2199   4D59             ; Input   : none
2200   4D59             ; Output  : HL': Address of the block transfer routine to be used 
2201   4D59             ; Modifies: AF, DE', HL'
2202   4D59             ; ------------------------------------------------
2203   4D59             SETLDIRHLPR: 
2204   4D59 D9          	exx
2205   4D5A             	; Check for a Z80 or R800
2206   4D5A AF          	xor	a		; Clear Cy
2207   4D5B 3D          	dec	a		; A=#FF
2208   4D5C ED F9       	db	#ED,#F9		; mulub a,a
2209   4D5E 38 05       	jr	c,.useLDIR	; Always use LDIR in RAM for the R800
2210   4D60             
2211   4D60 21 55 49    	ld	hl,LDI512
2212   4D63 D9          	exx
2213   4D64 C9          	ret
2214   4D65             
2215   4D65             .useLDIR: 
2216   4D65 D9          	exx
2217   4D66             	; ***Continues on GTR800LDIR
2218   4D66             
2219   4D66             ; ------------------------------------------------
2220   4D66             ; Obtain the pointer to the R800 data transfer helper routine
2221   4D66             ; Input   : IY=Pointer to the WorkArea
2222   4D66             ; Output  : HL=pointer to R800 data transfer helper routine 
2223   4D66             ; Modifies: DE
2224   4D66             ;	    - Does an exx at the end
2225   4D66             ; ------------------------------------------------
2226   4D66             GTR800LDIR: 
2227   4D66 FD E5       	push	iy
2228   4D68 E1          	pop	hl			; hl=WorkArea
2229   4D69 11 3A 00    	ld	de,WRKAREA.TRLDIR
2230   4D6C 19          	add	hl,de
2231   4D6D D9          	exx
2232   4D6E C9          	ret
2233   4D6F             
2234   4D6F             
2235   4D6F             ; ------------------------------------------------
2236   4D6F             ; Debugging routines
2237   4D6F             ; ------------------------------------------------
2238   4D6F              IFDEF DEBUG
2239   4D6F~            PRTCHAR: 
2240   4D6F~            	push	ix,iy
2241   4D6F~            	ld	ix,CHPUT
2242   4D6F~            	ld	iy,(EXPTBL-1)
2243   4D6F~            	call	CALSLT
2244   4D6F~            	pop	iy,ix
2245   4D6F~            	ret
2246   4D6F~            PRTDOT: 
2247   4D6F~            	push	af
2248   4D6F~            	ld	a,'.'
2249   4D6F~            	call	PRTCHAR
2250   4D6F~            	pop	af
2251   4D6F~            	ret
2252   4D6F~            PRTDASH: 
2253   4D6F~            	push	af
2254   4D6F~            	ld	a,'-'
2255   4D6F~            	call	PRTCHAR
2256   4D6F~            	pop	af
2257   4D6F~            	ret
2258   4D6F              ENDIF
2259   4D6F             
2260   4D6F             
2261   4D6F             
2262   4D6F             ; ==========================================================================
2263   4D6F             strTitle: 
2264   4D6F             	db	13,"FBLabs SDHC driver v",27,'J'
2264   4D6F 0D46424C61627320534448432064726976657220761B4A
2265   4D86             	BYTE2STR VER_MAIN
2265   4D86 31          >	db	(value % 10)+$30
2266   4D87 2E          	db	'.'
2267   4D88             	BYTE2STR VER_SEC
2267   4D88 30          >	db	(value % 10)+$30
2268   4D89 2E          	db	'.'
2269   4D8A             	BYTE2STR VER_REV
2269   4D8A 31          >	db	((value / 10) % 10)+$30
2269   4D8B 30          >	db	(value % 10)+$30
2270   4D8C 0D 0A 00    	db	13,10,0
2271   4D8F             
2272   4D8F             ;		 |-------------39 chars----------------|
2273   4D8F             strBootpaused: 
2274   4D8F             	db	"Paused. Press <i> for the copyright info",13,10,0
2274   4D8F 5061757365642E205072657373203C693E20666F722074686520636F70797269
2274   4DAF 67687420696E666F0D0A00
2275   4DBA             
2276   4DBA             strCopyright: 
2277   4DBA             	db	"(c) 2014 Fabio Belavenuto",13,10
2277   4DBA 286329203230313420466162696F2042656C6176656E75746F0D0A
2278   4DD5             	db	"(c) 2017 FRS",13,10
2278   4DD5 2863292032303137204652530D0A
2279   4DE3             	db	"Licenced under CERN OHL v1.1",13,10
2279   4DE3 4C6963656E63656420756E646572204345524E204F484C2076312E310D0A
2280   4E01             	db	"http://ohwr.org/cernohl",13,10
2280   4E01 687474703A2F2F6F6877722E6F72672F6365726E6F686C0D0A
2281   4E1A             	db	"PCB designed by Luciano Sturaro",13,10
2281   4E1A 5043422064657369676E6564206279204C756369616E6F205374757261726F0D
2281   4E3A 0A
2282   4E3B             	; will use the CR+LF+EOS bellow 
2283   4E3B             strCrLf: 
2284   4E3B 0D 0A 00    	db	13,10,0
2285   4E3E             strCartao: 
2286   4E3E             	db	"- Slot ",0
2286   4E3E 2D20536C6F742000
2287   4E46             strVazio: 
2288   4E46             	db	"Empty",13,10,0
2288   4E46 456D7074790D0A00
2289   4E4E             strNaoIdentificado: 
2290   4E4E             	db	"Unknown!",13,10,0
2290   4E4E 556E6B6E6F776E210D0A00
2291   4E59             ;		 |-------------39 chars----------------|
2292   4E59             strMr_mp_desativada: 
2293   4E59             	db	"- Slot expander & Mem Mapper disabled",13,10,0
2293   4E59 2D20536C6F7420657870616E6465722026204D656D204D617070657220646973
2293   4E79 61626C65640D0A00
2294   4E81              IFDEF HASMEGARAM
2295   4E81~            strMapper: 
2296   4E81~            	db	"- Slot expander & Mem Mapper enabled",13,10,0
2297   4E81~            strMegaram: 
2298   4E81~            	db	"- Slot expander & MegaRAM enabled",13,10,0
2299   4E81              ELSE
2300   4E81             strDrvMain: 
2301   4E81             	db	"- Main driver selected",13,10,0
2301   4E81 2D204D61696E206472697665722073656C65637465640D0A00
2302   4E9A             strDrvDev: 
2303   4E9A             	db	"- Development driver selected",13,10,0
2303   4E9A 2D20446576656C6F706D656E74206472697665722073656C65637465640D0A00
2304   4EBA              ENDIF
2305   4EBA             strSDV1: 
2306   4EBA             	db	"SDV1, ",0
2306   4EBA 534456312C2000
2307   4EC1             strSDV2: 
2308   4EC1             	db	"SDV2, ",0
2308   4EC1 534456322C2000
2309   4EC8             
2310   4EC8             ;-----------------------------------------------------------------------------
2311   4EC8             ;
2312   4EC8             ; End of the driver code
2313   4EC8             
2314   4EC8             DRV_END: 
2315   4EC8             
2316   4EC8             ;	ds	3ED0h-(DRV_END-DRV_START), $FF
2317   4EC8 FF          	ds	$7B00-$, #FF
2318   7B00             
2319   7B00             
