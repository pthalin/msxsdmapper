0001   0000             ; Projeto MSX SD Mapper
0002   0000             
0003   0000             ; Copyright (c) 2014 Fabio Belavenuto
0004   0000             ; Enhanced by FRS
0005   0000             
0006   0000             ; This documentation describes Open Hardware and is licensed under the CERN OHL v. 1.1.
0007   0000             ; You may redistribute and modify this documentation under the terms of the
0008   0000             ; CERN OHL v.1.1. (http://ohwr.org/cernohl). This documentation is distributed
0009   0000             ; WITHOUT ANY EXPRESS OR IMPLIED WARRANTY, INCLUDING OF MERCHANTABILITY,
0010   0000             ; SATISFACTORY QUALITY AND FITNESS FOR A PARTICULAR PURPOSE.
0011   0000             ; Please see the CERN OHL v.1.1 for applicable conditions
0012   0000             
0013   0000             ; Technical info:
0014   0000             ; 7B00h~7EFFh	: SPI data transfer window (read/write)
0015   0000             ; 7F00h		: Interface status and card select register (read/write)
0016   0000             ;	<read>
0017   0000             ;	If no SD card is selected:
0018   0000             ;	    b7-b2 : always 0
0019   0000             ;	    b1 : SW1 status (Driver selection)
0020   0000             ;	    b0 : SW0 status. 0=RAM disabled, 1=RAM enabled
0021   0000             ;	If any SD card is selected:
0022   0000             ;	    b7-b3 : always 0
0023   0000             ;	    b2 : 1=Write protecton enabled for SD card-slot selected
0024   0000             ;	    b1 : 0=SD card present in the selected card-slot
0025   0000             ;	    b0 : 1=SD Card on slot selected changed since last read
0026   0000             ;	<write>
0027   0000             ;	    b0 : SD card slot-0 chip-select (1=selected)
0028   0000             ;	    b1 : SD card slot-1 chip-select (1=selected)
0029   0000             
0030   0000             ; 7F02h		: 8-bit timer (97.65625 KHz frequency, 10.24uS resolution) (read/write)
0031   0000             ; When a value is written, the timer will decrease it until it reaches zero
0032   0000             
0033   0000             	output	"driver.bin"
0034   0000             
0035   0000             ;-----------------------------------------------------------------------------
0036   0000             ;
0037   0000             ; Driver configuration constants
0038   0000             ;
0039   0000             
0040   0000             ; DEFINE HASMEGARAM	; Driver for an SD-Mapper with MegaRAM
0041   0000             ; DEFINE TURBOINIT	; Disable for the interfaces with the CPLD firmware turbo bug 
0042   0000             ; DEFINE DEBUG		; Set for debugging output
0043   0000             
0044   0000             ;Driver type:
0045   0000             ;   0 for drive-based
0046   0000             ;   1 for device-based
0047   0000             
0048   0000             DRV_TYPE	equ	1
0049   0000             
0050   0000             ;Hot-plug devices support (device-based drivers only):
0051   0000             ;   0 for no hot-plug support
0052   0000             ;   1 for hot-plug support
0053   0000             
0054   0000             DRV_HOTPLUG	equ	1
0055   0000             
0056   0000             
0057   0000             ;Driver version
0058   0000             
0059   0000             VER_MAIN	equ	1
0060   0000             VER_SEC		equ	0
0061   0000             VER_REV		equ	10
0062   0000             
0063   0000             ;-----------------------------------------------------------------------------
0064   0000             ; SPI addresses. Check the Technical info above for the bit contents
0065   0000             
0066   0000             SPIDATA		= $7B00
0067   0000             SPICTRL		= $7FF0
0068   0000             SPISTATUS	= $7FF0
0069   0000             TIMERREG	= $7FF1
0070   0000             
0071   0000             ; Interface status flags
0072   0000             IF_RAM		= 0		; 1=Interface RAM is enabled
0073   0000             IF_DRVER	= 1		; RAM mode: 0=MegaRAM, 1=MemoryMapper
0074   0000             IF_M_RAM	= (1 shl IF_RAM)		; bitmask for IF_RAM
0075   0000             IF_M_DRVER	= (1 shl IF_DRVER)		; bitmask for IF_DRVER
0076   0000             
0077   0000             ; card slot status flags
0078   0000             SD_DSKCHG	= 0		; SD card changed since last status check
0079   0000             SD_PRESENT	= 1		; SD card present
0080   0000             SD_WRTPROT	= 2		; SD card is write protected
0081   0000             SD_M_DSKCHG	= (1 shl SD_DSKCHG)		; bitmask for SD_DSKCHG
0082   0000             SD_M_PRESENT	= (1 shl SD_PRESENT)		; bitmask for SD_PRESENT
0083   0000             SD_M_WRTPROT	= (1 shl SD_WRTPROT)		; bitmask for SD_WRTPROT
0084   0000             
0085   0000             ; SPI commands: 
0086   0000             CMD0	= 0  | $40
0087   0000             CMD1	= 1  | $40
0088   0000             CMD8	= 8  | $40
0089   0000             CMD9	= 9  | $40
0090   0000             CMD10	= 10 | $40
0091   0000             CMD12	= 12 | $40
0092   0000             CMD16	= 16 | $40
0093   0000             CMD17	= 17 | $40
0094   0000             CMD18	= 18 | $40
0095   0000             CMD24	= 24 | $40
0096   0000             CMD25	= 25 | $40
0097   0000             CMD55	= 55 | $40
0098   0000             CMD58	= 58 | $40
0099   0000             ACMD23	= 23 | $40
0100   0000             ACMD41	= 41 | $40
0101   0000             
0102   0000             ; Work area variables 
0103   0000              STRUCT WRKAREA
0104   0000~            BCSD 		ds 16	; Card Specific Data
0105   0000~            BCID1		ds 16	; Card-ID of card1
0106   0000~            BCID2		ds 16	; Card-ID of card2
0107   0000~            NUMSD		db 	; Currently selected card: 1 or 2 
0108   0000~            CARDFLAGS	db 	; Flags that indicate card-change or card error 
0109   0000~            NUMBLOCKS	db 	; Number of blocks in multi-block operations 
0110   0000~            BLOCKS1		ds 3	; 3 bytes. Size of card1, in blocks.
0111   0000~            BLOCKS2		ds 3	; 3 bytes. Size of card2, in blocks.
0112   0000~            TEMP		db	; Temporary data
0113   0000~            TRLDIR		ds 8	; R800 data transfer helper 
0114   0000              ENDS
0115   0000             
0116   0000             
0117   0000             ;-----------------------------------------------------------------------------
0118   0000             ;
0119   0000             ; Standard BIOS and work area entries
0120   0000             CALSLT	= $001C		; Call routine in any slot
0121   0000             CALLF	= $0030		; Call routine in any slot
0122   0000             INITXT	= $006C		; Inicializa SCREEN0
0123   0000             CHSNS	= $009C		; Sense keyboard buffer for character
0124   0000             CHGET	= $009F		; Get character from keyboard buffer
0125   0000             CHPUT	= $00A2		; A=char
0126   0000             CLS	= $00C3		; Chamar com A=0
0127   0000             ERAFNK	= $00CC		; Erase function key display
0128   0000             SNSMAT	= $0141		; Read row of keyboard matrix
0129   0000             KILBUF	= $0156		; Clear keyboard buffer
0130   0000             EXTROM	= $015F
0131   0000             CHGCPU	= $0180		; Change the turbo mode
0132   0000             GETCPU	= $0183		; Get the turbo mode
0133   0000             
0134   0000             ; subROM functions
0135   0000             SDFSCR	= $0185
0136   0000             REDCLK	= $01F5
0137   0000             
0138   0000             
0139   0000             ; System variables
0140   0000             MSXVER	= $002D
0141   0000             LINL40	= $F3AE		; Width
0142   0000             LINLEN	= $F3B0
0143   0000             INTFLG	= $FC9B
0144   0000             SCRMOD	= $FCAF
0145   0000             EXPTBL	 =$FCC1
0146   0000             
0147   0000             
0148   0000             ;-----------------------------------------------------------------------------
0149   0000             
0150   0000             
0151   0000             	org		$4000
0152   4000             
0153   4000 FF          	ds		256, $FF		; 256 dummy bytes
0154   4100             
0155   4100             DRV_START: 
0156   4100             
0157   4100             ;-----------------------------------------------------------------------------
0158   4100             ;
0159   4100             ; Miscellaneous constants
0160   4100             ;
0161   4100             
0162   4100             ;This is a 2 byte buffer to store the address of code to be executed.
0163   4100             ;It is used by some of the kernel page 0 routines.
0164   4100             
0165   4100             CODE_ADD: 	equ	0F84Ch
0166   4100             
0167   4100             
0168   4100             ;-----------------------------------------------------------------------------
0169   4100             ;
0170   4100             ; Error codes for DEV_RW
0171   4100             ;
0172   4100             
0173   4100             ENCOMP	equ	0FFh
0174   4100             EWRERR	equ	0FEh
0175   4100             EDISK	equ	0FDh
0176   4100             ENRDY	equ	0FCh
0177   4100             EDATA	equ	0FAh
0178   4100             ERNF	equ	0F9h
0179   4100             EWPROT	equ	0F8h
0180   4100             EUFORM	equ	0F7h
0181   4100             ESEEK	equ	0F3h
0182   4100             EIFORM	equ	0F0h
0183   4100             EIDEVL	equ	0B5h
0184   4100             EIPARM	equ	08Bh
0185   4100             
0186   4100             ;-----------------------------------------------------------------------------
0187   4100             ;
0188   4100             ; Macros
0189   4100             ;
0190   4100             
0191   4100              MACRO BYTE2STR value
0192   4100~            0193   4100~             IF value > 99
0194   4100~            	db	((value / 100) % 10)+$30
0195   4100~             ENDIF
0196   4100~             IF value > 9
0197   4100~            	db	((value / 10) % 10)+$30
0198   4100~             ENDIF
0199   4100~            	db	(value % 10)+$30
0200   4100~            0201   4100              ENDM
0202   4100             
0203   4100             
0204   4100             ;-----------------------------------------------------------------------------
0205   4100             ;
0206   4100             ; Routines and information available on kernel page 0
0207   4100             ;
0208   4100             
0209   4100             ;* Get in A the current slot for page 1. Corrupts F.
0210   4100             ;  Must be called by using CALBNK to bank 0:
0211   4100             ;    xor a
0212   4100             ;    ld ix,GSLOT1
0213   4100             ;    call CALBNK
0214   4100             
0215   4100             GSLOT1	equ	402Dh
0216   4100             
0217   4100             
0218   4100             ;* This routine reads a byte from another bank.
0219   4100             ;  Must be called by using CALBNK to the desired bank,
0220   4100             ;  passing the address to be read in HL:
0221   4100             ;    ld a,<bank number>
0222   4100             ;    ld hl,<byte address>
0223   4100             ;    ld ix,RDBANK
0224   4100             ;    call CALBNK
0225   4100             
0226   4100             RDBANK	equ	403Ch
0227   4100             
0228   4100             
0229   4100             ;* This routine temporarily switches kernel main bank
0230   4100             ;  (usually bank 0, but will be 3 when running in MSX-DOS 1 mode),
0231   4100             ;  then invokes the routine whose address is at (CODE_ADD).
0232   4100             ;  It is necessary to use this routine to invoke CALBAS
0233   4100             ;  (so that kernel bank is correct in case of BASIC error)
0234   4100             ;  and to invoke DOS functions via F37Dh hook.
0235   4100             ;
0236   4100             ;  Input:  Address of code to invoke in (CODE_ADD).
0237   4100             ;          AF, BC, DE, HL, IX, IY passed to the called routine.
0238   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0239   4100             
0240   4100             CALLB0	equ	403Fh
0241   4100             
0242   4100             
0243   4100             ;* Call a routine in another bank.
0244   4100             ;  Must be used if the driver spawns across more than one bank.
0245   4100             ;
0246   4100             ;  Input:  A = bank number
0247   4100             ;          IX = routine address
0248   4100             ;          AF' = AF for the routine
0249   4100             ;          HL' = Ix for the routine
0250   4100             ;          BC, DE, HL, IY = input for the routine
0251   4100             ;  Output: AF, BC, DE, HL, IX, IY returned from the called routine.
0252   4100             
0253   4100             CALBNK	equ	4042h
0254   4100             
0255   4100             
0256   4100             ;* Get in IX the address of the SLTWRK entry for the slot passed in A,
0257   4100             ;  which will in turn contain a pointer to the allocated page 3
0258   4100             ;  work area for that slot (0 if no work area was allocated).
0259   4100             ;  If A=0, then it uses the slot currently switched in page 1.
0260   4100             ;  Returns A=current slot for page 1, if A=0 was passed.
0261   4100             ;  Corrupts F.
0262   4100             ;  Must be called by using CALBNK to bank 0:
0263   4100             ;    ld a,<slot number> (xor a for current page 1 slot)
0264   4100             ;    ex af,af'
0265   4100             ;    xor a
0266   4100             ;    ld ix,GWORK
0267   4100             ;    call CALBNK
0268   4100             
0269   4100             GWORK	equ	4045h
0270   4100             
0271   4100             
0272   4100             ;* This address contains one byte that tells how many banks
0273   4100             ;  form the Nextor kernel (or alternatively, the first bank
0274   4100             ;  number of the driver).
0275   4100             
0276   4100             K_SIZE	equ	40FEh
0277   4100             
0278   4100             
0279   4100             ;* This address contains one byte with the current bank number.
0280   4100             
0281   4100             CUR_BANK	equ	40FFh
0282   4100             
0283   4100             
0284   4100             ;-----------------------------------------------------------------------------
0285   4100             ;
0286   4100             ; Built-in format choice strings
0287   4100             ;
0288   4100             
0289   4100             NULL_MSG  equ     781Fh	;Null string (disk can't be formatted)
0290   4100             SING_DBL  equ     7820h ;"1-Single side / 2-Double side"
0291   4100             
0292   4100             
0293   4100             ;-----------------------------------------------------------------------------
0294   4100             ;
0295   4100             ; Driver signature
0296   4100             ;
0297   4100             	db	"NEXTOR_DRIVER",0
0297   4100 4E4558544F525F44524956455200
0298   410E             
0299   410E             
0300   410E             ;-----------------------------------------------------------------------------
0301   410E             ;
0302   410E             ; Driver flags:
0303   410E             ;    bit 0: 0 for drive-based, 1 for device-based
0304   410E             ;    bit 1: 1 for hot-plug devices supported (device-based drivers only)
0305   410E             ;    bit 2: 1 if the driver implements the DRV_CONFIG routine
0306   410E             
0307   410E 07          	db 1+2*DRV_HOTPLUG+4
0308   410F             
0309   410F             ;-----------------------------------------------------------------------------
0310   410F             ;
0311   410F             ; Reserved byte
0312   410F             ;
0313   410F 00          	db	0
0314   4110             
0315   4110             ;-----------------------------------------------------------------------------
0316   4110             ;
0317   4110             ; Driver name
0318   4110             ;
0319   4110             ; It will be shown in the FDISK interface selection menu
0320   4110             
0321   4110             DRV_NAME: 
0322   4110             	db	"FBLabs SDHC"
0322   4110 46424C6162732053444843
0323   411B 20          	ds	32-($-DRV_NAME)," "
0324   4130             
0325   4130             
0326   4130             ;-----------------------------------------------------------------------------
0327   4130             ;
0328   4130             ; Jump table for the driver public routines
0329   4130             ;
0330   4130             
0331   4130             	; These routines are mandatory for all drivers
0332   4130                     ; (but probably you need to implement only DRV_INIT)
0333   4130             
0334   4130 C3 6C 41    	jp	DRV_TIMI
0335   4133 C3 4F 42    	jp	DRV_VERSION
0336   4136 C3 6D 41    	jp	DRV_INIT
0337   4139 C3 56 42    	jp	DRV_BASSTAT
0338   413C C3 58 42    	jp	DRV_BASDEV
0339   413F C3 5A 42    	jp	DRV_EXTBIO
0340   4142 C3 5B 42    	jp	DRV_DIRECT0
0341   4145 C3 5B 42    	jp	DRV_DIRECT1
0342   4148 C3 5B 42    	jp	DRV_DIRECT2
0343   414B C3 5B 42    	jp	DRV_DIRECT3
0344   414E C3 5B 42    	jp	DRV_DIRECT4
0345   4151 C3 5C 42    	jp	DRV_CONFIG
0346   4154             
0347   4154 00          	ds	12
0348   4160             
0349   4160             	; These routines are mandatory for device-based drivers
0350   4160             
0351   4160 C3 74 42    	jp	DEV_RW
0352   4163 C3 F9 42    	jp	DEV_INFO
0353   4166 C3 8C 43    	jp	DEV_STATUS
0354   4169 C3 D8 43    	jp	LUN_INFO
0355   416C             
0356   416C             
0357   416C             ;=====
0358   416C             ;=====  END of data that must be at fixed addresses
0359   416C             ;=====
0360   416C             
0361   416C             
0362   416C             ;-----------------------------------------------------------------------------
0363   416C             ;
0364   416C             ; Timer interrupt routine, it will be called on each timer interrupt
0365   416C             ; (at 50 or 60Hz), but only if DRV_INIT returns Cy=1 on its first execution.
0366   416C             
0367   416C             DRV_TIMI: 
0368   416C C9          	ret
0369   416D             
0370   416D             ;-----------------------------------------------------------------------------
0371   416D             ;
0372   416D             ; Driver initialization routine, it is called twice:
0373   416D             ;
0374   416D             ; 1) First execution, for information gathering.
0375   416D             ;    Input:
0376   416D             ;      A = 0
0377   416D             ;      B = number of available drives
0378   416D             ;      HL = maximum size of allocatable work area in page 3
0379   416D             ;    Output:
0380   416D             ;      A = number of required drives (for drive-based driver only)
0381   416D             ;      HL = size of required work area in page 3
0382   416D             ;      Cy = 1 if DRV_TIMI must be hooked to the timer interrupt, 0 otherwise
0383   416D             ;
0384   416D             ; 2) Second execution, for work area and hardware initialization.
0385   416D             ;    Input:
0386   416D             ;      A = 1
0387   416D             ;      B = number of allocated drives for this controller
0388   416D             ;
0389   416D             ;    The work area address can be obtained by using GWORK.
0390   416D             ;
0391   416D             ;    If first execution requests more work area than available,
0392   416D             ;    second execution will not be done and DRV_TIMI will not be hooked
0393   416D             ;    to the timer interrupt.
0394   416D             ;
0395   416D             ;    If first execution requests more drives than available,
0396   416D             ;    as many drives as possible will be allocated, and the initialization
0397   416D             ;    procedure will continue the normal way
0398   416D             ;    (for drive-based drivers only. Device-based drivers always
0399   416D             ;     get two allocated drives.)
0400   416D             
0401   416D             DRV_INIT: 
0402   416D B7          	or	a		; Is this the 1st call? 
0403   416E 20 0F       	jr	nz,.call2
0404   4170             ; 1st call:
0405   4170 21 3A 00    	ld	hl,WRKAREA.TRLDIR ; size of work area needed for the Z80
0406   4173 3A 2D 00    	ld	a,(MSXVER)
0407   4176 FE 03       	cp	3		; MSX Turbo-R?
0408   4178 3F          	ccf
0409   4179 D0          	ret	nc		; No, return with Cy off
0410   417A 21 42 00    	ld	hl,WRKAREA	; size of work area needed for the TR
0411   417D B7          	or	a		; Clear Cy
0412   417E C9          	ret
0413   417F             
0414   417F             
0415   417F             .call2: 
0416   417F             ; 2nd call: 
0417   417F              IFDEF TURBOINIT
0418   417F~            	ld	a,(CHGCPU)
0419   417F~            	cp	#C3		; IS CHGCPU present?
0420   417F~            	jr	nz,.call2ini
0421   417F~            	call	GETCPU
0422   417F~            	push	af		; Save the current CPU
0423   417F~            	ld	a,#82
0424   417F~            	call	CHGCPU		; Enable the turbo
0425   417F~            .call2ini: 
0426   417F              ENDIF ; TURBOINIT
0427   417F CD BB 48    	call	MYSETSCR		; Set the screen mode
0428   4182 CD 20 44    	call	pegaWorkArea		; IY=Work area pointer
0429   4185             
0430   4185             ;	; Clear the work area
0431   4185 FD E5       	push	iy
0432   4187 E1          	pop	hl
0433   4188 54 5D       	ld	de,hl
0434   418A 13          	inc	de
0435   418B 01 3A 00    	ld	bc,WRKAREA.TRLDIR
0436   418E 36 00       	ld	(hl),0
0437   4190 ED B0       	ldir
0438   4192             
0439   4192 11 83 4D    	ld	de,strTitle		; prints the title 
0440   4195 CD 74 47    	call	printString
0441   4198             
0442   4198             
0443   4198             .sdhcinit: 	; FBLabs SDHC Interface initialization
0444   4198 CD 30 42    	call	.printmode		; Print the switches configuration
0445   419B AF          	xor	a			; zera flags do cartao
0446   419C FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
0447   419F             
0448   419F 3E 01       	ld	a, 1			; detectar cartao 1
0449   41A1 CD BB 41    	call	.detecta
0450   41A4 3E 02       	ld	a, 2			; detectar cartao 2
0451   41A6 CD BB 41    	call	.detecta
0452   41A9 01 00 00    	ld	bc, 0
0453   41AC 1E 05       	ld	e, 5
0454   41AE             
0455   41AE CD 4E 49    	call	INSTR800HLP		; Install R800 data copy on workarea
0456   41B1             
0457   41B1 CD FF 48    	call	INICHKSTOP		; Check if the STOP key was pressed
0458   41B4             
0459   41B4 11 4F 4E    	ld	de, strCrLf
0460   41B7              
0461   41B7 CD 74 47    	call	printString
0462   41BA              IFDEF TURBOINIT
0463   41BA~            .drv_init_end: 
0464   41BA~            	; ***Workaround for a bug in Nextor that causes it to freeze if
0465   41BA~            	; CTRL+STOP was pressed on boot
0466   41BA~            	ld	a,(INTFLG)
0467   41BA~            	cp	3		; Is CTRL+STOP still signaled?
0468   41BA~            	jr	nz,.restCPU	; no, skip
0469   41BA~            	xor	a
0470   41BA~            	ld	(INTFLG),a	; Clear CTRL+STOP otherwise Nextor will freeze
0471   41BA~            0472   41BA~            .restCPU: 	; Restore the CPU if necessary
0473   41BA~            	ld	a,(CHGCPU)
0474   41BA~            	cp	#C3		; IS CHGCPU present?
0475   41BA~            	ret	nz
0476   41BA~            	pop	af
0477   41BA~            	or	#80
0478   41BA~            	jp	CHGCPU
0479   41BA              ELSE
0480   41BA C9          	ret
0481   41BB              ENDIF ; TURBOINIT
0482   41BB             
0483   41BB             
0484   41BB             ;------- DRV_INIT aux routines ----------
0485   41BB             
0486   41BB             .detecta: 
0487   41BB FD 77 30    	ld	(iy+WRKAREA.NUMSD), a	; Save the requested card slot
0488   41BE 11 52 4E    	ld	de, strCartao
0489   41C1 CD 74 47    	call	printString
0490   41C4 FD 4E 30    	ld	c, (iy+WRKAREA.NUMSD)
0491   41C7 79          	ld	a,c
0492   41C8 C6 30       	add	'0'
0493   41CA CD A2 00    	call	CHPUT
0494   41CD 3E 3A       	ld	a, ':'
0495   41CF CD A2 00    	call	CHPUT
0496   41D2 3E 20       	ld	a, ' '
0497   41D4 CD A2 00    	call	CHPUT
0498   41D7 79          	ld	a,c			; Get card slot#
0499   41D8             ;	cpl				; invert bits
0500   41D8             ;	and	3
0501   41D8 32 F0 7F    	ld	(SPICTRL), a		; Select card slot
0502   41DB 3A F0 7F    	ld	a, (SPISTATUS)		; get card slot status
0503   41DE CD C4 45    	call	disableSDs
0504   41E1 E6 02       	and	SD_M_PRESENT		; Is there an card present?
0505   41E3 28 06       	jr	z,.naoVazio		; Yes, skip
0506   41E5 11 5A 4E    	ld	de, strVazio		; Empty SD card slot message
0507   41E8 C3 74 47    	jp	printString
0508   41EB             ;	jp	.marcaErro
0509   41EB             .naoVazio: 
0510   41EB CD 77 44    	call	detectaCartao		; tem cartao no slot, inicializar e detectar
0511   41EE 30 09       	jr	nc,.detectou
0512   41F0 CD C4 45    	call	disableSDs
0513   41F3 11 62 4E    	ld	de, strNaoIdentificado
0514   41F6 C3 74 47    	jp	printString
0515   41F9             ;.marcaErro:
0516   41F9             ;	jp	marcaErroCartao		; slot vazio ou erro de deteccao, marcar nas flags
0517   41F9             .detectou: 
0518   41F9 CD 4F 44    	call	calculaCIDoffset	; calculamos em IX a posicao correta do offset CID dependendo do cartao atual
0519   41FC DD 7E 0F    	ld	a,(ix+15)	; pegar byte SDV1 ou SDV2
0520   41FF 11 CE 4E    	ld	de, strSDV1	; e imprimir
0521   4202 B7          	or	a
0522   4203 28 03       	jr	z,.pula1
0523   4205 11 D5 4E    	ld	de, strSDV2
0524   4208             .pula1: 
0525   4208 CD 74 47    	call	printString
0526   420B 3E 28       	ld	a,'('
0527   420D CD A2 00    	call	CHPUT
0528   4210 DD 7E 00    	ld	a,(ix)		; pegar byte do fabricante
0529   4213 CD C7 47    	call	printDecToAscii	; Imprimir Manufacturer ID
0530   4216 3E 29       	ld	a,')'
0531   4218 CD A2 00    	call	CHPUT
0532   421B 3E 20       	ld	a,' '
0533   421D CD A2 00    	call	CHPUT
0534   4220 DD 7E 00    	ld	a,(ix)		; pegar byte do fabricante
0535   4223 CD EE 47    	call	pegaFabricante	; achar nome do fabricante
0536   4226 EB          	ex	de,hl
0537   4227 CD 74 47    	call	printString	; e imprimir
0538   422A 11 4F 4E    	ld	de,strCrLf
0539   422D C3 74 47    	jp	printString
0540   4230             
0541   4230             
0542   4230             .printmode: 		; Print the two switches configuration
0543   4230 AF          	xor	a			; 0=Interface status
0544   4231 32 F0 7F    	ld	(SPICTRL),a
0545   4234 3A F0 7F    	ld	a, (SPISTATUS)		; Check if the mapper/megaRAM is active
0546   4237 E6 01       	and	IF_M_RAM		; Is the RAM enabled?
0547   4239 11 6D 4E    	ld	de,strMr_mp_desativada
0548   423C              IFDEF HASMEGARAM
0549   423C~            	jr	z,.print		; No, skip
0550   423C~            	ld	a, (SPISTATUS)		; ativa, testar se eh mapper ou megaram
0551   423C~            	and	IF_M_DRVER
0552   423C~            	ld	de,strMapper
0553   423C~            	jr	nz,.print
0554   423C~            	ld	de, strMegaram		; Megaram ativa
0555   423C~            .print: 
0556   423C~            	jp	printString
0557   423C              ELSE
0558   423C CC 74 47    	call	z,printString		; Yes, print
0559   423F 3A F0 7F    	ld	a, (SPISTATUS)		; Get the MainBIOS/DevBIOS switch status
0560   4242 E6 02       	and	IF_M_DRVER
0561   4244 11 95 4E    	ld	de,strDrvMain
0562   4247 20 03       	jr	nz,.printdrv
0563   4249 11 AE 4E    	ld	de, strDrvDev
0564   424C             .printdrv: 
0565   424C C3 74 47    	jp	printString
0566   424F              ENDIF
0567   424F             
0568   424F             
0569   424F             
0570   424F             
0571   424F             
0572   424F             ;-----------------------------------------------------------------------------
0573   424F             ;
0574   424F             ; Obtain driver version
0575   424F             ;
0576   424F             ; Input:  -
0577   424F             ; Output: A = Main version number
0578   424F             ;         B = Secondary version number
0579   424F             ;         C = Revision number
0580   424F             
0581   424F             DRV_VERSION: 
0582   424F 3E 01       	ld	a, VER_MAIN
0583   4251 06 00       	ld	b, VER_SEC
0584   4253 0E 0A       	ld	c, VER_REV
0585   4255 C9          	ret
0586   4256             
0587   4256             
0588   4256             ;-----------------------------------------------------------------------------
0589   4256             ;
0590   4256             ; BASIC expanded statement ("CALL") handler.
0591   4256             ; Works the expected way, except that if invoking CALBAS is needed,
0592   4256             ; it must be done via the CALLB0 routine in kernel page 0.
0593   4256             
0594   4256             DRV_BASSTAT: 
0595   4256 37          	scf
0596   4257 C9          	ret
0597   4258             
0598   4258             
0599   4258             ;-----------------------------------------------------------------------------
0600   4258             ;
0601   4258             ; BASIC expanded device handler.
0602   4258             ; Works the expected way, except that if invoking CALBAS is needed,
0603   4258             ; it must be done via the CALLB0 routine in kernel page 0.
0604   4258             
0605   4258             DRV_BASDEV: 
0606   4258 37          	scf
0607   4259 C9          	ret
0608   425A             
0609   425A             ;-----------------------------------------------------------------------------
0610   425A             ;
0611   425A             ; Extended BIOS hook.
0612   425A             ; Works the expected way, except that it must return
0613   425A             ; D'=1 if the old hook must be called, D'=0 otherwise.
0614   425A             ; It is entered with D'=1.
0615   425A             
0616   425A             DRV_EXTBIO: 
0617   425A C9          	ret
0618   425B             
0619   425B             ;-----------------------------------------------------------------------------
0620   425B             ;
0621   425B             ; Direct calls entry points.
0622   425B             ; Calls to addresses 7850h, 7853h, 7856h, 7859h and 785Ch
0623   425B             ; in kernel banks 0 and 3 will be redirected
0624   425B             ; to DIRECT0/1/2/3/4 respectively.
0625   425B             ; Receives all register data from the caller except IX and AF'.
0626   425B             
0627   425B             DRV_DIRECT0: 
0628   425B             DRV_DIRECT1: 
0629   425B             DRV_DIRECT2: 
0630   425B             DRV_DIRECT3: 
0631   425B             DRV_DIRECT4: 
0632   425B C9          	ret
0633   425C             
0634   425C             
0635   425C             ;-----------------------------------------------------------------------------
0636   425C             ;
0637   425C             ; Get driver configuration 
0638   425C             ; (bit 2 of driver flags must be set if this routine is implemented)
0639   425C             ;
0640   425C             ; Input:
0641   425C             ;   A = Configuration index
0642   425C             ;   BC, DE, HL = Depends on the configuration
0643   425C             ;
0644   425C             ; Output:
0645   425C             ;   A = 0: Ok
0646   425C             ;       1: Configuration not available for the supplied index
0647   425C             ;   BC, DE, HL = Depends on the configuration
0648   425C             ;
0649   425C             ; * Get number of drives at boot time (for device-based drivers only):
0650   425C             ;   Input:
0651   425C             ;     A = 1
0652   425C             ;     B = 0 for DOS 2 mode, 1 for DOS 1 mode
0653   425C             ;   Output:
0654   425C             ;     B = number of drives
0655   425C             ;
0656   425C             ; * Get default configuration for drive
0657   425C             ;   Input:
0658   425C             ;     A = 2
0659   425C             ;     B = 0 for DOS 2 mode, 1 for DOS 1 mode
0660   425C             ;     C = Relative drive number at boot time (0~n)
0661   425C             ;   Output:
0662   425C             ;     B = Device index (1~7)
0663   425C             ;     C = LUN index
0664   425C             
0665   425C             DRV_CONFIG: 
0666   425C B7          	or	a
0667   425D 28 12       	jr	z,.notavail
0668   425F FE 01       	cp	1
0669   4261 20 04       	jr	nz,.tryC2
0670   4263             
0671   4263             	; Config-1: Get number of drives at boot time
0672   4263 06 02       	ld	b,2
0673   4265 AF          	xor	a
0674   4266 C9          	ret
0675   4267             
0676   4267 FE 02       .tryC2:  cp	2
0677   4269 20 06       	jr	nz,.notavail
0678   426B             
0679   426B             	; Config-2: Get default configuration for drive
0680   426B 41          	ld	b,c
0681   426C 04          	inc	b
0682   426D 0E 01       	ld	c,1
0683   426F AF          	xor	a
0684   4270 C9          	ret
0685   4271             
0686   4271             
0687   4271             .notavail: 
0688   4271 3E 01       	ld	a,1
0689   4273 C9          	ret
0690   4274             
0691   4274             
0692   4274             ;=====
0693   4274             ;=====  BEGIN of DEVICE-BASED specific routines
0694   4274             ;=====
0695   4274             
0696   4274             ;-----------------------------------------------------------------------------
0697   4274             ;
0698   4274             ; Read or write logical sectors from/to a logical unit
0699   4274             ;
0700   4274             ;Input:    Cy=0 to read, 1 to write
0701   4274             ;          A = Device number, 1 to 7
0702   4274             ;          B = Number of sectors to read or write
0703   4274             ;          C = Logical unit number, 1 to 7
0704   4274             ;          HL = Source or destination memory address for the transfer
0705   4274             ;          DE = Address where the 4 byte sector number is stored.
0706   4274             ;Output:   A = Error code (the same codes of MSX-DOS are used):
0707   4274             ;              0: Ok
0708   4274             ;              .IDEVL: Invalid device or LUN
0709   4274             ;              .NRDY: Not ready
0710   4274             ;              .DISK: General unknown disk error
0711   4274             ;              .DATA: CRC error when reading
0712   4274             ;              .RNF: Sector not found
0713   4274             ;              .UFORM: Unformatted disk
0714   4274             ;              .WPROT: Write protected media, or read-only logical unit
0715   4274             ;              .WRERR: Write error
0716   4274             ;              .NCOMP: Incompatible disk.
0717   4274             ;              .SEEK: Seek error.
0718   4274             ;          B = Number of sectors actually read (in case of error only)
0719   4274             
0720   4274             DEV_RW: 
0721   4274 F5          	push	af
0722   4275 FE 03       	cp	3		; somente 2 dispositivos
0723   4277 30 1C       	jr	nc,.saicomerroidl
0724   4279 0D          	dec	c		; somente 1 logical unit
0725   427A 20 19       	jr	nz,.saicomerroidl
0726   427C CD 20 44    	call	pegaWorkArea	; IY=Work area pointer
0727   427F FD 77 30    	ld	(iy+WRKAREA.NUMSD),a
0728   4282 FD 70 32    	ld	(iy+WRKAREA.NUMBLOCKS),b	; save the number of blocks to transfer 
0729   4285 CD 66 46    	call	setaSDAtual
0730   4288 3A F0 7F    	ld	a,(SPISTATUS)	; Get this card slot status
0731   428B E6 02       	and	SD_M_PRESENT	; Is there a card present?
0732   428D 28 0C       	jr	z,.cardok	; Yes, skip
0733   428F F1          	pop	af
0734   4290 3E FC       	ld	a, ENRDY	; Not ready
0735   4292 06 00       	ld	b, 0
0736   4294 C9          	ret
0737   4295             .saicomerroidl: 
0738   4295 F1          	pop	af
0739   4296 3E B5       	ld	a, EIDEVL	; error: Invalid device or LUN 
0740   4298 06 00       	ld	b, 0
0741   429A C9          	ret
0742   429B             .cardok: 
0743   429B             ;	exx
0744   429B D5 E5       	push	de,hl
0745   429D             
0746   429D CD 6D 4D    	call	SETLDIRHLPR	; hl'=Pointer to LDIR helper in RAM
0747   42A0 CD 4F 44    	call	calculaCIDoffset	; ix=CID offset 
0748   42A3 DD 7E 0F    	ld	a,(ix+15)	; verificar se eh SDV1 ou SDV2
0749   42A6 DD 6F       	ld	ixl,a		; ixl=SDcard version
0750   42A8 E1 D1       	pop	hl,de
0751   42AA F1          	pop	af		; a=Device number, f=read/write flag 
0752   42AB             ;	exx			; hl=Source/dest Address, de=Pointer to sect#
0753   42AB             ;	ld	ixh, b 		; ixh=Number of blocks to transfer
0754   42AB 38 20       	jr	c,DEV_W	; Skip if it's a write operation 
0755   42AD             
0756   42AD             DEV_R: 
0757   42AD 1A          	ld	a, (de)		; 1. n. bloco
0758   42AE F5          	push	af
0759   42AF 13          	inc	de
0760   42B0 1A          	ld	a, (de)		; 2. n. bloco
0761   42B1 F5          	push	af
0762   42B2 13          	inc	de
0763   42B3 1A          	ld	a, (de)		; 3. n. bloco
0764   42B4 4F          	ld	c, a
0765   42B5 13          	inc	de
0766   42B6 1A          	ld	a, (de)		; 4. n. bloco
0767   42B7 13          	inc	de
0768   42B8 47          	ld	b, a
0769   42B9 F1          	pop	af
0770   42BA 57          	ld	d, a
0771   42BB F1          	pop	af		; HL = ponteiro destino
0772   42BC 5F          	ld	e, a		; BC DE = 32 bits numero do bloco
0773   42BD CD 12 47    	call	LerBloco	; chamar rotina de leitura de dados
0774   42C0 D0          	ret	nc		; Return with A=0 if no error occurred
0775   42C1 CD 38 44    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0776   42C4 FD 7E 32    	ld	a,(iy+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0777   42C7 DD 94       	sub	ixh		; subtract the number of remaining blocks
0778   42C9 47          	ld	b,a		; b=number of blocks written
0779   42CA 3E FD       	ld	a, EDISK	; General unknown disk error
0780   42CC C9          	ret
0781   42CD             
0782   42CD             DEV_W: 
0783   42CD             	; Test if the card is write protected
0784   42CD 3A F0 7F    	ld	a,(SPISTATUS)	; Get this card slot status
0785   42D0 E6 04       	and	SD_M_WRTPROT	; Is the card write protected?
0786   42D2 28 05       	jr	z,.ok
0787   42D4 3E F8       	ld	a, EWPROT	; disco protegido
0788   42D6 06 00       	ld	b,0		; 0 blocks were written
0789   42D8 C9          	ret
0790   42D9             .ok: 
0791   42D9 1A          	ld	a, (de)		; 1. n. bloco
0792   42DA F5          	push	af
0793   42DB 13          	inc	de
0794   42DC 1A          	ld	a, (de)		; 2. n. bloco
0795   42DD F5          	push	af
0796   42DE 13          	inc	de
0797   42DF 1A          	ld	a, (de)		; 3. n. bloco
0798   42E0 13          	inc	de
0799   42E1 4F          	ld	c, a
0800   42E2 1A          	ld	a, (de)		; 4. n. bloco
0801   42E3 13          	inc	de
0802   42E4 47          	ld	b, a
0803   42E5 F1          	pop	af
0804   42E6 57          	ld	d, a
0805   42E7 F1          	pop	af		; HL = ponteiro destino
0806   42E8 5F          	ld	e, a		; BC DE = 32 bits numero do bloco
0807   42E9 CD 72 46    	call	GravarBloco	; chamar rotina de gravacao de dados
0808   42EC D0          	ret	nc		; Return with A=0 if no error occurred
0809   42ED             
0810   42ED CD 38 44    	call	marcaErroCartao		; ocorreu erro, marcar nas flags
0811   42F0 FD 7E 32    	ld	a,(iy+WRKAREA.NUMBLOCKS) ; Get the number of requested blocks
0812   42F3 DD 94       	sub	ixh		; subtract the number of remaining blocks
0813   42F5 47          	ld	b,a		; b=number of blocks written
0814   42F6 3E FE       	ld	a,EWRERR	; Write error
0815   42F8 C9          	ret
0816   42F9             
0817   42F9             ;-----------------------------------------------------------------------------
0818   42F9             ;
0819   42F9             ; Device information gathering
0820   42F9             ;
0821   42F9             ;Input:   A = Device index, 1 to 7
0822   42F9             ;         B = Information to return:
0823   42F9             ;             0: Basic information
0824   42F9             ;             1: Manufacturer name string
0825   42F9             ;             2: Device name string
0826   42F9             ;             3: Serial number string
0827   42F9             ;         HL = Pointer to a buffer in RAM
0828   42F9             ;Output:  A = Error code:
0829   42F9             ;             0: Ok
0830   42F9             ;             1: Device not available or invalid device index
0831   42F9             ;             2: Information not available, or invalid information index
0832   42F9             ;         When basic information is requested,
0833   42F9             ;         buffer filled with the following information:
0834   42F9             ;
0835   42F9             ;+0 (1): Numer of logical units, from 1 to 7. 1 if the device has no logical
0836   42F9             ;        units (which is functionally equivalent to having only one).
0837   42F9             ;+1 (1): Device flags, always zero in Beta 2.
0838   42F9             ;
0839   42F9             ; The strings must be printable ASCII string (ASCII codes 32 to 126),
0840   42F9             ; left justified and padded with spaces. All the strings are optional,
0841   42F9             ; if not available, an error must be returned.
0842   42F9             ; If a string is provided by the device in binary format, it must be reported
0843   42F9             ; as an hexadecimal, upper-cased string, preceded by the prefix "0x".
0844   42F9             ; The maximum length for a string is 64 characters;
0845   42F9             ; if the string is actually longer, the leftmost 64 characters
0846   42F9             ; should be provided.
0847   42F9             ;
0848   42F9             ; In the case of the serial number string, the same rules for the strings
0849   42F9             ; apply, except that it must be provided right-justified,
0850   42F9             ; and if it is too long, the rightmost characters must be
0851   42F9             ; provided, not the leftmost.
0852   42F9             
0853   42F9             DEV_INFO: 
0854   42F9 FE 03       	cp	3		; somente 2 dispositivos
0855   42FB 38 03       	jr	c,.devok
0856   42FD 3E 01       	ld	a,1		; invalid device index
0857   42FF C9          	ret
0858   4300             .devok: 
0859   4300 CD 20 44    	call	pegaWorkArea	; IY=Work area pointer
0860   4303 FD 77 30    	ld	(iy+WRKAREA.NUMSD),a
0861   4306 CD 66 46    	call	setaSDAtual
0862   4309 04          	inc	b
0863   430A 10 06       	djnz	.naoBasic
0864   430C             
0865   430C             ; Basic information:
0866   430C 36 01       	ld	(hl),1		; 1 logical unit somente
0867   430E 23          	inc	hl
0868   430F AF          	xor	a
0869   4310 77          	ld	(hl),a		; reservado, deve ser 0
0870   4311 C9          	ret			; retorna com A=0 (OK)
0871   4312             
0872   4312             .naoBasic: 
0873   4312 E5 C5 F5    	push	hl,bc,af
0874   4315 CD 8C 43    	call	DEV_STATUS	; We need to do this because SD cards are removable devices, not just
0875   4318             				; removable media 
0876   4318 B7          	or	a		; Is this device available?
0877   4319 20 06       	jr	nz,.getinfo	; Yes, get this device info
0878   431B F1 C1 E1    	pop	af,bc,hl	; Flush the stack
0879   431E             .noinfo: 
0880   431E 3E 02       	ld	a,2		; Quit with "Info not available" status
0881   4320 C9          	ret
0882   4321             
0883   4321             .getinfo: 
0884   4321 F1          	pop	af
0885   4322 CD 4F 44    	call	calculaCIDoffset	; calculamos em IX a posicao correta do offset CID dependendo do cartao atual
0886   4325 C1 E1       	pop	bc,hl
0887   4327 10 24       	djnz	.naoManuf
0888   4329             ; Manufacturer Name:
0889   4329 E5          	push	hl		; salva ponteiro do buffer
0890   432A 06 40       	ld	b, 64		; preenche buffer com espaco
0891   432C 3E 20       	ld	a, ' '
0892   432E             .loop1: 
0893   432E 77          	ld	(hl), a
0894   432F 23          	inc	hl
0895   4330 10 FC       	djnz	.loop1
0896   4332 E1          	pop	hl		; hl=pointer to Nextor buffer 
0897   4333 36 28       	ld	(hl),'('	; Place "(xx) " on the buffer
0898   4335 23          	inc	hl
0899   4336 DD 7E 00    	ld	a, (ix)		; byte do fabricante
0900   4339 CD 7D 47    	call	DecToAscii
0901   433C 36 29       	ld	(hl),')'
0902   433E 23          	inc	hl
0903   433F 36 20       	ld	(hl),' '
0904   4341 23          	inc	hl
0905   4342 DD 7E 00    	ld	a, (ix)		; byte do fabricante
0906   4345 EB          	ex	de,hl
0907   4346 CD EE 47    	call	pegaFabricante	; pegar nome do fabricante em HL
0908   4349 ED B0       	ldir			; e colocar no buffer
0909   434B AF          	xor	a		; Return with A=0 (Ok)
0910   434C C9          	ret
0911   434D             
0912   434D             .naoManuf: 
0913   434D 10 19       	djnz	.naoProduct
0914   434F             ; Product Name:
0915   434F E5          	push	hl		; guarda HL que aponta para buffer do Nextor
0916   4350 DD E5       	push	ix
0917   4352 E1          	pop	hl		; joga IX para HL
0918   4353 11 03 00    	ld	de,3		; adiciona offset do productname em HL
0919   4356 19          	add	hl, de
0920   4357 D1          	pop	de		; recupera buffer do Nextor em DE
0921   4358 01 05 00    	ld	bc, 5		; 5 caracteres
0922   435B ED B0       	ldir			; copia nome do produto
0923   435D EB          	ex	de,hl		; troca DE com HL, agora HL aponta para Buffer do nextor atualizado
0924   435E 06 3B       	ld	b, 59		; Coloca espaco no restante do buffer
0925   4360 3E 20       	ld	a, ' '
0926   4362             .loop2: 
0927   4362 77          	ld	(hl), a
0928   4363 23          	inc	hl
0929   4364 10 FC       	djnz	.loop2
0930   4366 AF          	xor	a		; Return with A=0 (Ok)
0931   4367 C9          	ret
0932   4368             
0933   4368             .naoProduct: 
0934   4368 10 B4       	djnz	.noinfo
0935   436A             ; Serial Number:
0936   436A 36 30       	ld	(hl),'0'	; Coloca prefixo "0x"
0937   436C 23          	inc	hl
0938   436D 36 78       	ld	(hl), 'x'
0939   436F 23          	inc	hl
0940   4370 E5          	push	hl		; guarda HL que aponta para buffer do Nextor
0941   4371 DD E5       	push	ix
0942   4373 E1          	pop	hl		; joga IX para HL
0943   4374 11 09 00    	ld	de, 9		; adiciona offset do productname em HL
0944   4377 19          	add	hl, de
0945   4378 D1          	pop	de		; recupera buffer do nextor em DE
0946   4379 06 04       	ld	b, 4		; 4 bytes do serial
0947   437B             .loop3: 
0948   437B 7E          	ld	a,(hl)
0949   437C CD B3 47    	call	HexToAscii	; converter HEXA para ASCII
0950   437F 23          	inc	hl
0951   4380 10 F9       	djnz	.loop3
0952   4382 06 36       	ld	b, 54		; Coloca espaco no restante
0953   4384 3E 20       	ld	a, ' '
0954   4386             .loop4: 
0955   4386 12          	ld	(de), a
0956   4387 13          	inc	de
0957   4388 10 FC       	djnz	.loop4
0958   438A AF          	xor	a		; Return with A=0 (Ok)
0959   438B C9          	ret
0960   438C             
0961   438C             ;-----------------------------------------------------------------------------
0962   438C             ;
0963   438C             ; Obtain device status
0964   438C             ;
0965   438C             ;Input:   A = Device index, 1 to 7
0966   438C             ;         B = Logical unit number, 1 to 7
0967   438C             ;             0 to return the status of the device itself.
0968   438C             ;Output:  A = Status for the specified logical unit,
0969   438C             ;             or for the whole device if 0 was specified:
0970   438C             ;                0: The device or logical unit is not available, or the
0971   438C             ;                   device or logical unit number supplied is invalid.
0972   438C             ;                1: The device or logical unit is available and has not
0973   438C             ;                   changed since the last status request.
0974   438C             ;                2: The device or logical unit is available and has changed
0975   438C             ;                   since the last status request
0976   438C             ;                   (for devices, the device has been unplugged and a
0977   438C             ;                    different device has been plugged which has been
0978   438C             ;                    assigned the same device index; for logical units,
0979   438C             ;                    the media has been changed).
0980   438C             ;                3: The device or logical unit is available, but it is not
0981   438C             ;                   possible to determine whether it has been changed
0982   438C             ;                   or not since the last status request.
0983   438C             ;
0984   438C             ; Devices not supporting hot-plugging must always return status value 1.
0985   438C             ; Non removable logical units may return values 0 and 1.
0986   438C             ;
0987   438C             ; The returned status is always relative to the previous invokation of
0988   438C             ; DEV_STATUS itself. Please read the Driver Developer Guide for more info.
0989   438C             
0990   438C             DEV_STATUS: 
0991   438C 4F          	ld	c,a		; c=Device number
0992   438D FE 03       	cp	3		; 2 dispositivos somente
0993   438F 30 42       	jr	nc,.nodev
0994   4391 78          	ld	a,b
0995   4392 B7          	or	a		; Device itself status?
0996   4393 28 40       	jr	z,.devok	; I'm fine, thanks
0997   4395 3D          	dec	a		; Only LUN=1 are allowed
0998   4396 20 3B       	jr	nz,.nodev
0999   4398              IFDEF DEBUG
1000   4398~            	push	af
1001   4398~            	ld	a,'S'		; DEV_STATUS debug ID
1002   4398~            	call	PRTCHAR
1003   4398~            	pop	af
1004   4398~            	push	af
1005   4398~            	add	'0'		; Device number
1006   4398~            	call	PRTCHAR
1007   4398~            	pop	af
1008   4398              ENDIF
1009   4398 C5          	push	bc
1010   4399 79          	ld	a,c
1011   439A CD 20 44    	call	pegaWorkArea	; IY=Work area pointer
1012   439D C1          	pop	bc
1013   439E FD 71 30    	ld	(iy+WRKAREA.NUMSD),c	; salva numero do device atual (1 ou 2)
1014   43A1 79          	ld	a,c
1015   43A2 32 F0 7F    	ld	(SPICTRL), a	; selects SD
1016   43A5 3A F0 7F    	ld	a, (SPISTATUS)	; Get this card-slot status
1017   43A8 CD C4 45    	call	disableSDs
1018   43AB CB 4F       	bit	SD_PRESENT,a	; Any card here?
1019   43AD 20 24       	jr	nz,.saicomerro	; Report that there's no card here
1020   43AF E6 01       	and	SD_M_DSKCHG	; Has the card changed since last time?
1021   43B1 20 06       	jr	nz,.detcard	; Yes, force a detection
1022   43B3             .tsterror: 
1023   43B3 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; testar bit de erro do cartao nas flags
1024   43B6 A1          	and	c		; Test against the card #
1025   43B7 28 14       	jr	z,.semMudanca	; cartao nao marcado com erro, pula
1026   43B9             .detcard: 
1027   43B9 CD 77 44    	call	detectaCartao	; erro na deteccao do cartao, tentar re-detectar
1028   43BC 38 12       	jr	c,.cartaoComErro	; nao conseguimos detectar, sai com erro
1029   43BE FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)		; conseguimos detectar, tira erro nas flags
1030   43C1 2F          	cpl			; inverte bits para fazer o AND
1031   43C2 4F          	ld	c, a
1032   43C3 FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)
1033   43C6 A1          	and	c		; clear the error bit 
1034   43C7 FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
1035   43CA             .comMudanca: 
1036   43CA              IFDEF DEBUG
1037   43CA~            	ld	a,'2'
1038   43CA~            	call	PRTCHAR
1039   43CA              ENDIF
1040   43CA 3E 02       	ld	a, 2		; informa ao Nextor que cartao esta OK e mudou
1041   43CC C9          	ret
1042   43CD             .semMudanca: 
1043   43CD              IFDEF DEBUG
1044   43CD~            	ld	a,'1'
1045   43CD~            	call	PRTCHAR
1046   43CD              ENDIF
1047   43CD 3E 01       	ld	a, 1		; informa ao Nextor que cartao esta OK e nao mudou
1048   43CF C9          	ret
1049   43D0             .cartaoComErro: 
1050   43D0 CD 38 44    	call	marcaErroCartao	; marcar erro do cartao nas flags
1051   43D3              IFDEF DEBUG
1052   43D3~            	ld	a,'E'
1053   43D3~            	call	PRTCHAR
1054   43D3~            	xor	a
1055   43D3~            	ret
1056   43D3              ENDIF
1057   43D3             .nodev: 
1058   43D3              IFDEF DEBUG
1059   43D3~            	ld	a,'s'
1060   43D3~            	call	PRTCHAR
1061   43D3~            	xor	a
1062   43D3~            	ret
1063   43D3              ENDIF
1064   43D3             .saicomerro: 
1065   43D3              IFDEF DEBUG
1066   43D3~            	ld	a,'0'
1067   43D3~            	call	PRTCHAR
1068   43D3              ENDIF
1069   43D3 AF          	xor	a		; this device has an error 
1070   43D4 C9          	ret
1071   43D5             .devok: 
1072   43D5 3E 03       	ld	a,3
1073   43D7 C9          	ret
1074   43D8             
1075   43D8             
1076   43D8             ;-----------------------------------------------------------------------------
1077   43D8             ;
1078   43D8             ; Obtain logical unit information
1079   43D8             ;
1080   43D8             ;Input:   A  = Device index, 1 to 7
1081   43D8             ;         B  = Logical unit number, 1 to 7
1082   43D8             ;         HL = Pointer to buffer in RAM.
1083   43D8             ;Output:  A = 0: Ok, buffer filled with information.
1084   43D8             ;             1: Error, device or logical unit not available,
1085   43D8             ;                or device index or logical unit number invalid.
1086   43D8             ;         On success, buffer filled with the following information:
1087   43D8             ;
1088   43D8             ;+0 (1): Medium type:
1089   43D8             ;        0: Block device
1090   43D8             ;        1: CD or DVD reader or recorder
1091   43D8             ;        2-254: Unused. Additional codes may be defined in the future.
1092   43D8             ;        255: Other
1093   43D8             ;+1 (2): Sector size, 0 if this information does not apply or is
1094   43D8             ;        not available.
1095   43D8             ;+3 (4): Total number of available sectors.
1096   43D8             ;        0 if this information does not apply or is not available.
1097   43D8             ;+7 (1): Flags:
1098   43D8             ;        bit 0: 1 if the medium is removable.
1099   43D8             ;        bit 1: 1 if the medium is read only. A medium that can dinamically
1100   43D8             ;               be write protected or write enabled is not considered
1101   43D8             ;               to be read-only.
1102   43D8             ;        bit 2: 1 if the LUN is a floppy disk drive.
1103   43D8             ;+8 (2): Number of cylinders
1104   43D8             ;+10 (1): Number of heads
1105   43D8             ;+11 (1): Number of sectors per track
1106   43D8             ;
1107   43D8             ; Number of cylinders, heads and sectors apply to hard disks only.
1108   43D8             ; For other types of device, these fields must be zero.
1109   43D8             
1110   43D8             LUN_INFO: 
1111   43D8 FE 03       	cp	3		; somente 2 dispositivo
1112   43DA 30 41       	jr	nc,.saicomerro
1113   43DC 05          	dec	b		; somente 1 logical unit
1114   43DD 20 3E       	jr	nz,.saicomerro
1115   43DF             
1116   43DF              IFDEF DEBUG
1117   43DF~            	push	af
1118   43DF~            	ld	a,'L'		; LUN_INFO debug ID
1119   43DF~            	call	PRTCHAR
1120   43DF~            	pop	af
1121   43DF~            	push	af
1122   43DF~            	add	'0'		; Print the device number
1123   43DF~            	call	PRTCHAR
1124   43DF~            	pop	af
1125   43DF              ENDIF
1126   43DF             
1127   43DF F5 E5       	push	af,hl
1128   43E1 04          	inc	b		; b=LUN=1
1129   43E2 CD 8C 43    	call	DEV_STATUS	; Is there a card present? 
1130   43E5 E1          	pop	hl
1131   43E6 B7          	or	a
1132   43E7 20 0A       	jr	nz,.ok		; device is available
1133   43E9 F1          	pop	af
1134   43EA             .nomedia: 
1135   43EA              IFDEF DEBUG
1136   43EA~            	push	af
1137   43EA~            	ld	a,'N'
1138   43EA~            	call	PRTCHAR
1139   43EA~            	pop	af
1140   43EA              ENDIF
1141   43EA AF          	xor	a
1142   43EB 06 07       	ld	b,7
1143   43ED             .nmloop: 
1144   43ED 77          	ld	(hl),a		; 0=block device
1145   43EE 23          	inc	hl
1146   43EF 10 FC       	djnz	.nmloop		; Fill the rest with "0=information not available"
1147   43F1 18 20       	jr	.wflagsnCHS	; Fill the rest of the info about the device
1148   43F3             
1149   43F3             .ok: 
1150   43F3              IFDEF DEBUG
1151   43F3~            	ld	a,'P'
1152   43F3~            	call	PRTCHAR
1153   43F3              ENDIF
1154   43F3             
1155   43F3 F1          	pop	af
1156   43F4 E5          	push	hl
1157   43F5 CD 63 44    	call	calculaBLOCOSoffset	; calcular em IX e HL o offset correto do buffer que armazena total de blocos
1158   43F8 E1          	pop	hl		; do cartao dependendo do cartao atual solicitado
1159   43F9 AF          	xor	a
1160   43FA 77          	ld	(hl),a		; 0 = block device 
1161   43FB 23          	inc	hl
1162   43FC 77          	ld	(hl),a		; Block size lsb 
1163   43FD 23          	inc	hl
1164   43FE 36 02       	ld	(hl),2		; Block size msb = 512
1165   4400 23          	inc	hl
1166   4401 DD 7E 00    	ld	a, (ix)		; copia numero de blocos total
1167   4404 77          	ld	(hl), a
1168   4405 23          	inc	hl
1169   4406 DD 7E 01    	ld	a, (ix+1)
1170   4409 77          	ld	(hl), a
1171   440A 23          	inc	hl
1172   440B DD 7E 02    	ld	a, (ix+2)
1173   440E 77          	ld	(hl), a
1174   440F 23          	inc	hl
1175   4410 36 00       	ld	(hl), 0		; cartoes SD tem total de blocos em 24 bits, mas o Nextor pede numero de
1176   4412 23          	inc	hl 		; 32 bits, entao coloca 0 no MSB
1177   4413             
1178   4413             .wflagsnCHS: 
1179   4413 36 01       	ld	(hl),1		; flags: dispositivo R/W removivel
1180   4415 23          	inc	hl
1181   4416 AF          	xor	a		; CHS = 0
1182   4417 77          	ld	(hl), a
1183   4418 23          	inc	hl
1184   4419 77          	ld	(hl), a
1185   441A 23          	inc	hl
1186   441B 77          	ld	(hl), a
1187   441C C9          	ret			; Return with A-0: Ok, filled the buffer
1188   441D             
1189   441D             .saicomerro: 
1190   441D 3E 01       	ld	a, 1		; Return with A=1: Error
1191   441F C9          	ret
1192   4420             
1193   4420             
1194   4420             ;=====
1195   4420             ;=====  END of DEVICE-BASED specific routines
1196   4420             ;=====
1197   4420             
1198   4420             ;------------------------------------------------
1199   4420             ; Rotinas auxiliares
1200   4420             ;------------------------------------------------
1201   4420             
1202   4420             ;------------------------------------------------
1203   4420             ; Pedir ao Nextor o ponteiro de dados de trabalho
1204   4420             ; na RAM e colocar em HL e IY
1205   4420             ; Output: 
1206   4420             ; IY = WorkArea pointer
1207   4420             ; Modifies: IX
1208   4420             ;------------------------------------------------
1209   4420             pegaWorkArea: 
1210   4420 F5 E5       	push	af,hl
1211   4422 AF          	xor	a		; Pegar endereco da area de trabalho
1212   4423 08          	ex	af,af'
1213   4424 AF          	xor	a
1214   4425 DD 21 45 40 	ld	ix, GWORK
1215   4429 CD 42 40    	call	CALBNK
1216   442C DD 6E 00    	ld	l,(ix)		; em HL tem o ponteiro da nossa area da RAM
1217   442F DD 66 01    	ld	h,(ix+1)
1218   4432 E5          	push	hl
1219   4433 FD E1       	pop	iy		; em IY temos o mesmo ponteiro
1220   4435 E1 F1       	pop	hl,af
1221   4437 C9          	ret
1222   4438             
1223   4438             ;------------------------------------------------
1224   4438             ; Marcar bit de erro nas flags
1225   4438             ; Destroi AF, C
1226   4438             ;------------------------------------------------
1227   4438             marcaErroCartao: 
1228   4438 FD 4E 30    	ld	c, (iy+WRKAREA.NUMSD)		; cartao atual (1 ou 2)
1229   443B FD 7E 31    	ld	a, (iy+WRKAREA.CARDFLAGS)	; marcar erro
1230   443E B1          	or	c
1231   443F FD 77 31    	ld	(iy+WRKAREA.CARDFLAGS), a
1232   4442 C9          	ret
1233   4443             
1234   4443             ;------------------------------------------------
1235   4443             ; Testar se cartao atual esta protegido contra
1236   4443             ; gravacao, A=0 se protegido
1237   4443             ; Destroi AF, C
1238   4443             ;------------------------------------------------
1239   4443             testaWP: 
1240   4443 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; cartao atual (1 ou 2)
1241   4446 32 F0 7F    	ld	(SPICTRL), a
1242   4449 3A F0 7F    	ld	a, (SPISTATUS)	; testar se cartao esta protegido
1243   444C             ;	call	disableSDs
1244   444C E6 04       	and	$04
1245   444E C9          	ret			; se A for 0 cartao esta protegido
1246   444F             
1247   444F             ;------------------------------------------------
1248   444F             ; Calcula offset do buffer na RAM em HL e IX para
1249   444F             ; os dados do CID dependendo do cartao atual
1250   444F             ; Destroi AF, DE, HL e IX
1251   444F             ;------------------------------------------------
1252   444F             calculaCIDoffset: 
1253   444F FD E5       	push	iy		; copiamos IY para HL
1254   4451 E1          	pop	hl
1255   4452 16 00       	ld	d, 0
1256   4454 1E 10       	ld	e, WRKAREA.BCID1	; DE aponta para buffer BCID1
1257   4456 FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; vamos fazer IX apontar para o buffer correto
1258   4459 3D          	dec	a		; dependendo do cartao: BCID1 ou BCID2
1259   445A 28 02       	jr	z,.c1
1260   445C 1E 20       	ld	e, WRKAREA.BCID2	; DE aponta para buffer BCID2
1261   445E             .c1: 
1262   445E 19          	add	hl, de		; HL aponta para buffer correto
1263   445F E5          	push	hl		
1264   4460 DD E1       	pop	ix		; vamos colocar HL em IX
1265   4462 C9          	ret
1266   4463             
1267   4463             ;------------------------------------------------
1268   4463             ; Calcula offset do buffer na RAM para os dados
1269   4463             ; do total de blocos dependendo do cartao atual
1270   4463             ; Offset fica em HL e IX
1271   4463             ; Destroi AF, DE, HL e IX
1272   4463             ;------------------------------------------------
1273   4463             calculaBLOCOSoffset: 
1274   4463 FD E5       	push	iy		; copiamos IY para HL
1275   4465 E1          	pop	hl
1276   4466 16 00       	ld	d, 0
1277   4468 1E 33       	ld	e, WRKAREA.BLOCKS1	; DE aponta para buffer BLOCKS1
1278   446A FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)	; Vamos fazer IX apontar para o buffer correto
1279   446D 3D          	dec	a		; dependendo do cartao: BLOCKS1 ou BLOCKS2
1280   446E 28 02       	jr	z,.c1
1281   4470 1E 36       	ld	e, WRKAREA.BLOCKS2	; DE aponta para buffer BLOCKS2
1282   4472             .c1: 
1283   4472 19          	add	hl, de		; HL aponta para buffer correto
1284   4473 E5          	push	hl		
1285   4474 DD E1       	pop	ix		; Vamos colocar HL em IX
1286   4476 C9          	ret
1287   4477             
1288   4477             
1289   4477             ;------------------------------------------------
1290   4477             ; Minhas funcoes para cartao SD
1291   4477             ;------------------------------------------------
1292   4477             
1293   4477             ;------------------------------------------------
1294   4477             ; Processo de inicializacao e deteccao do cartao.
1295   4477             ; Detecta se cartao responde, qual versao (SDV1
1296   4477             ; ou SDV2), faz a leitura do CSD e CID e calcula
1297   4477             ; o numero de blocos do cartao, colocando o CID
1298   4477             ; e total de blocos no buffer correto dependendo
1299   4477             ; do cartao 1 ou 2.
1300   4477             ; Retorna erro no carry. Se for 0 indica deteccao
1301   4477             ; com sucesso.
1302   4477             ; Destroi todos os registradores
1303   4477             ;------------------------------------------------
1304   4477             detectaCartao: 
1305   4477 CD A5 45    	call	iniciaSD	; manda pulsos de clock e comandos iniciais
1306   447A D8          	ret	c			; retorna se erro
1307   447B CD 46 45    	call	testaSDCV2	; tenta inicializar um cartao SDV2
1308   447E D8          	ret	c
1309   447F FD E5       	push	iy		; colocar em HL buffer da RAM de trabalho
1310   4481 E1          	pop	hl		; CSD esta no offset 0, nao precisamos somar
1311   4482 3E 49       	ld	a, CMD9		; ler CSD
1312   4484 CD 67 45    	call	lerBlocoCxD
1313   4487 D8          	ret	c
1314   4488 CD 4F 44    	call	calculaCIDoffset	; calculamos em IX e HL a posicao correta do offset CID dependendo do cartao atual
1315   448B 3E 4A       	ld	a, CMD10	; ler CID
1316   448D CD 67 45    	call	lerBlocoCxD
1317   4490 D8          	ret	c
1318   4491 3E 7A       	ld	a, CMD58	; ler OCR
1319   4493 11 00 00    	ld	de, 0
1320   4496 CD F5 45    	call	SD_SEND_CMD_2_ARGS_GET_R3	; enviar comando e receber resposta tipo R3
1321   4499 D8          	ret	c
1322   449A 78          	ld	a, b		; testa bit CCS do OCR que informa se cartao eh SDV1 ou SDV2
1323   449B E6 40       	and	$40
1324   449D DD 77 0F    	ld	(ix+15), a	; salva informacao da versao do SD (V1 ou V2) no byte 15 do CID
1325   44A0 CC 3B 45    	call	z,mudarTamanhoBlocoPara512	; se bit CCS do OCR for 1, eh cartao SDV2 (Block address - SDHC ou SDXD)
1326   44A3 D8          	ret	c		; e nao precisamos mudar tamanho do bloco para 512
1327   44A4 CD C4 45    	call	disableSDs
1328   44A7             				; agora vamos calcular o total de blocos dependendo dos dados do CSD
1329   44A7 CD 63 44    	call	calculaBLOCOSoffset	; calcular em IX e HL o offset correto do buffer que armazena total de blocos
1330   44AA FD E5       	push	iy		; copiamos IY para HL
1331   44AC E1          	pop	hl
1332   44AD 16 00       	ld	d, 0
1333   44AF 1E 05       	ld	e, WRKAREA.BCSD+5
1334   44B1 19          	add	hl, de		; HL aponta para buffer BCSD+5
1335   44B2 FD 7E 00    	ld	a, (iy+WRKAREA.BCSD)
1336   44B5 E6 C0       	and	$C0		; testa versao do registro CSD
1337   44B7 28 06       	jr	z,.calculaCSD1
1338   44B9 FE 40       	cp	$40
1339   44BB 28 54       	jr	z,.calculaCSD2
1340   44BD 37          	scf			; versao do registro CSD nao reconhecida, informa erro na deteccao
1341   44BE C9          	ret
1342   44BF             
1343   44BF             ; -----------------------------------
1344   44BF             ; Registro CSD versao 1, calcular da
1345   44BF             ; maneira correta para a versao 1
1346   44BF             ; -----------------------------------
1347   44BF             .calculaCSD1: 
1348   44BF 7E          	ld	a, (hl)
1349   44C0 E6 0F       	and	$0F		; isola READ_BL_LEN
1350   44C2 F5          	push	af
1351   44C3 23          	inc	hl
1352   44C4 7E          	ld	a, (hl)		; 2 primeiros bits de C_SIZE
1353   44C5 E6 03       	and	3
1354   44C7 57          	ld	d, a
1355   44C8 23          	inc	hl
1356   44C9 5E          	ld	e, (hl)		; 8 bits de C_SIZE (DE contem os primeiros 10 bits de C_SIZE)
1357   44CA 23          	inc	hl
1358   44CB 7E          	ld	a, (hl)
1359   44CC E6 C0       	and	$C0		; 2 ultimos bits de C_SIZE
1360   44CE 87          	add	a, a		; rotaciona a esquerda
1361   44CF CB 13       	rl	e		; rotaciona para DE
1362   44D1 CB 12       	rl	d
1363   44D3 87          	add	a, a		; mais uma rotacao
1364   44D4 CB 13       	rl	e		; rotaciona para DE
1365   44D6 CB 12       	rl	d
1366   44D8 13          	inc	de		; agora DE contem todos os 12 bits de C_SIZE, incrementa 1
1367   44D9 23          	inc	hl
1368   44DA 7E          	ld	a, (hl)		; proximo byte
1369   44DB E6 03       	and	3		; 2 bits de C_SIZE_MUL
1370   44DD 47          	ld	b, a		; B contem os 2 bits de C_SIZE_MUL
1371   44DE 23          	inc	hl						
1372   44DF 7E          	ld	a, (hl)		; proximo byte
1373   44E0 E6 80       	and	$80		; 1 bit de C_SIZE_MUL
1374   44E2 87          	add	a, a		; rotaciona para esquerda jogando no carry
1375   44E3 CB 10       	rl	b		; rotaciona para B
1376   44E5 04          	inc	b		; agora B contem os 3 bits de C_SIZE_MUL
1377   44E6 04          	inc	b		; faz B = C_SIZE_MUL + 2
1378   44E7 F1          	pop	af		; volta em A o READ_BL_LEN
1379   44E8 80          	add	a, b		; A = READ_BL_LEN + (C_SIZE_MUL+2)
1380   44E9 01 00 00    	ld	bc, 0
1381   44EC CD 05 45    	call	.eleva2
1382   44EF 5A          	ld	e, d		; aqui temos 32 bits (BC DE) com o tamanho do cartao
1383   44F0 51          	ld	d, c		; ignoramos os 8 ultimos bits em E, fazemos BC DE => 0B CD (divide por 256)
1384   44F1 48          	ld	c, b
1385   44F2 06 00       	ld	b, 0
1386   44F4 CB 39       	srl	c		; rotacionamos a direita o C, carry = LSB (divide por 2)
1387   44F6 CB 1A       	rr	d		; rotacionamos D e E
1388   44F8 CB 1B       	rr	e		; no final BC DE contem tamanho do cartao / 512 = numero de blocos
1389   44FA             .salvaBlocos: 
1390   44FA DD 71 02    	ld	(ix+2), c	; colocar no buffer BLOCOS correto a quantidade de blocos
1391   44FD DD 72 01    	ld	(ix+1), d	; que o cartao (1 ou 2) tem
1392   4500 DD 73 00    	ld	(ix), e
1393   4503 AF          	xor	a		; limpa carry
1394   4504 C9          	ret
1395   4505             
1396   4505             .eleva2: 			; aqui temos: A = (READ_BL_LEN + (C_SIZE_MUL+2))
1397   4505             				; BC = 0
1398   4505             				; DE = C_SIZE
1399   4505 CB 23       	sla	e		; rotacionamos C_SIZE por 'A' vezes
1400   4507 CB 12       	rl	d
1401   4509 CB 11       	rl	c
1402   450B CB 10       	rl	b
1403   450D 3D          	dec	a		; subtraimos 1
1404   450E 20 F5       	jr	nz,.eleva2
1405   4510 C9          	ret			; em BC DE temos o tamanho do cartao (bytes) em 32 bits
1406   4511             
1407   4511             ; -----------------------------------
1408   4511             ; Registro CSD versao 2, calcular da
1409   4511             ; maneira correta para a versao 2
1410   4511             ; -----------------------------------
1411   4511             .calculaCSD2: 
1412   4511 23          	inc	hl		; HL ja aponta para BCSD+5, fazer HL apontar para BCSD+7
1413   4512 23          	inc	hl
1414   4513 7E          	ld	a, (hl)
1415   4514 E6 3F       	and	$3F
1416   4516 4F          	ld	c, a
1417   4517 23          	inc	hl
1418   4518 56          	ld	d, (hl)
1419   4519 23          	inc	hl
1420   451A 5E          	ld	e, (hl)
1421   451B CD 27 45    	call	.inc32		; soma 1
1422   451E CD 2F 45    	call	.desloca32	; multiplica por 512
1423   4521 CD 34 45    	call	.rotaciona24	; multiplica por 2
1424   4524 C3 FA 44    	jp		.salvaBlocos
1425   4527             
1426   4527             .inc32: 
1427   4527 1C          	inc	e
1428   4528 C0          	ret	nz
1429   4529 14          	inc	d
1430   452A C0          	ret	nz
1431   452B 0C          	inc	c
1432   452C C0          	ret	nz
1433   452D 04          	inc	b
1434   452E C9          	ret
1435   452F             
1436   452F             .desloca32: 
1437   452F 41          	ld	b, c
1438   4530 4A          	ld	c, d
1439   4531 53          	ld	d, e
1440   4532 1E 00       	ld	e, 0
1441   4534             .rotaciona24: 
1442   4534 CB 22       	sla	d
1443   4536 CB 11       	rl	c
1444   4538 CB 10       	rl	b
1445   453A C9          	ret
1446   453B             
1447   453B             ; ------------------------------------------------
1448   453B             ; Setar o tamanho do bloco para 512 se o cartao
1449   453B             ; for SDV1
1450   453B             ; ------------------------------------------------
1451   453B             mudarTamanhoBlocoPara512: 
1452   453B 3E 50       	ld	a, CMD16
1453   453D 01 00 00    	ld	bc, 0
1454   4540 11 00 02    	ld	de, 512
1455   4543 C3 E0 45    	jp	SD_SEND_CMD_GET_ERROR
1456   4546             
1457   4546             ; ------------------------------------------------
1458   4546             ; Tenta inicializar um cartao SDV2, se houver erro
1459   4546             ; o cartao deve ser SDV1
1460   4546             ; ------------------------------------------------
1461   4546             testaSDCV2: 
1462   4546 3E 48       	ld	a, CMD8
1463   4548 11 AA 01    	ld	de, $1AA
1464   454B CD F5 45    	call	SD_SEND_CMD_2_ARGS_GET_R3
1465   454E 21 D9 45    	ld	hl, SD_SEND_CMD1	; HL aponta para rotina correta
1466   4551 38 03       	jr	c,.pula		; cartao recusou CMD8, enviar comando CMD1
1467   4553 21 CB 45    	ld	hl, SD_SEND_ACMD41	; cartao aceitou CMD8, enviar comando ACMD41
1468   4556             .pula: 
1469   4556 01 14 00    	ld	bc, 20		; B = 0, C = 20: 5120 tentativas
1470   4559             .loop: 
1471   4559 C5          	push	bc
1472   455A CD 66 45    	call	.jumpHL		; chamar rotina correta em HL
1473   455D C1          	pop	bc
1474   455E D0          	ret	nc
1475   455F 10 F8       	djnz	.loop
1476   4561 0D          	dec	c
1477   4562 20 F5       	jr	nz,.loop
1478   4564 37          	scf
1479   4565 C9          	ret
1480   4566             .jumpHL: 
1481   4566 E9          	jp	(hl)		; chamar rotina correta em HL
1482   4567             
1483   4567             ; ------------------------------------------------
1484   4567             ; Ler registro CID ou CSD, o comando vem em A
1485   4567             ; ------------------------------------------------
1486   4567             lerBlocoCxD: 
1487   4567 CD DB 45    	call	SD_SEND_CMD_NO_ARGS
1488   456A D8          	ret	c
1489   456B CD 3A 46    	call	WAIT_RESP_FE
1490   456E D8          	ret	c
1491   456F EB          	ex	de,hl
1492   4570             
1493   4570             	; Check for a Z80 or R800
1494   4570             ;	or 	a		; Clear Cy
1495   4570 3E 14       	ld	a,20
1496   4572 ED F9       	db	#ED,#F9		; mulub a,a
1497   4574 21 00 7B    	ld	hl, SPIDATA
1498   4577 38 25       	jr	c,.r800		; Use LDIR for R800
1499   4579 ED A0       > ldi	
1499   457B ED A0       > ldi	
1499   457D ED A0       > ldi	
1499   457F ED A0       > ldi	
1499   4581 ED A0       > ldi	
1499   4583 ED A0       > ldi	
1499   4585 ED A0       > ldi	
1499   4587 ED A0       > ldi	
1499   4589 ED A0       > ldi	
1499   458B ED A0       > ldi	
1499   458D ED A0       > ldi	
1499   458F ED A0       > ldi	
1499   4591 ED A0       > ldi	
1499   4593 ED A0       > ldi	
1499   4595 ED A0       > ldi	
1499   4597 ED A0       > ldi	
1500   4599             .end
1501   4599 7E           	ld	a, (hl)
1502   459A 7E          	ld	a, (hl)		; byte de resposta
1503   459B B7          	or	a
1504   459C EB          	ex	de,hl
1505   459D             ;	jr	disableSDs
1506   459D C9          	ret
1507   459E             
1508   459E             .r800: 
1509   459E 01 10 00    	ld	bc,16
1510   45A1 ED B0       	ldir
1511   45A3 18 F4       	jr	.end
1512   45A5             
1513   45A5             ; ------------------------------------------------
1514   45A5             ; Algoritmo para inicializar um cartao SD
1515   45A5             ; Destroi AF, B, DE
1516   45A5             ; ------------------------------------------------
1517   45A5             iniciaSD: 
1518   45A5 CD C4 45    	call	disableSDs
1519   45A8             
1520   45A8 06 0A       	ld	b, 10		; enviar 80 pulsos de clock com cartao desabilitado
1521   45AA             enviaClocksInicio: 
1522   45AA 3E FF       	ld	a, $FF		; manter MOSI em 1
1523   45AC 32 00 7B    	ld	(SPIDATA), a
1524   45AF 10 F9       	djnz	enviaClocksInicio
1525   45B1 CD 66 46    	call	setaSDAtual	; ativar cartao atual
1526   45B4 06 08       	ld	b, 8		; 8 tentativas para CMD0
1527   45B6             SD_SEND_CMD0: 
1528   45B6 3E 40       	ld	a, CMD0		; primeiro comando: CMD0
1529   45B8 11 00 00    	ld	de, 0
1530   45BB C5          	push	bc
1531   45BC CD E8 45    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
1532   45BF C1          	pop	bc
1533   45C0 D0          	ret	nc			; retorna se cartao respondeu ao CMD0
1534   45C1 10 F3       	djnz	SD_SEND_CMD0
1535   45C3 37          	scf			; cartao nao respondeu ao CMD0, informar erro
1536   45C4             	; fall throw
1537   45C4             
1538   45C4             ; ------------------------------------------------
1539   45C4             ; Desabilitar (de-selecionar) todos os cartoes
1540   45C4             ; Nao destroi registradores
1541   45C4             ; ------------------------------------------------
1542   45C4             disableSDs: 
1543   45C4 F5          	push	af
1544   45C5 AF          	xor	a
1545   45C6 32 F0 7F    	ld	(SPICTRL), a
1546   45C9 F1          	pop	af
1547   45CA C9          	ret
1548   45CB             
1549   45CB             ; ------------------------------------------------
1550   45CB             ; Enviar comando ACMD41
1551   45CB             ; ------------------------------------------------
1552   45CB             SD_SEND_ACMD41: 
1553   45CB 3E 77       	ld	a, CMD55
1554   45CD CD DB 45    	call	SD_SEND_CMD_NO_ARGS
1555   45D0 3E 69       	ld	a, ACMD41
1556   45D2 01 00 40    	ld	bc, $4000
1557   45D5 51          	ld	d, c
1558   45D6 59          	ld	e, c
1559   45D7 18 07       	jr		SD_SEND_CMD_GET_ERROR
1560   45D9             
1561   45D9             ; ------------------------------------------------
1562   45D9             ; Enviar CMD1 para cartao. Carry indica erro
1563   45D9             ; Destroi AF, BC, DE
1564   45D9             ; ------------------------------------------------
1565   45D9             SD_SEND_CMD1: 
1566   45D9 3E 41       	ld	a, CMD1
1567   45DB             SD_SEND_CMD_NO_ARGS: 
1568   45DB 01 00 00    	ld	bc, 0
1569   45DE 50          	ld	d, b
1570   45DF 59          	ld	e, c
1571   45E0             SD_SEND_CMD_GET_ERROR: 
1572   45E0 CD 0E 46    	call	SD_SEND_CMD
1573   45E3 B7          	or	a
1574   45E4 C8          	ret	z			; se A=0 nao houve erro, retornar
1575   45E5             	; fall throw
1576   45E5             
1577   45E5             ; ------------------------------------------------
1578   45E5             ; Informar erro
1579   45E5             ; Nao destroi registradores
1580   45E5             ; ------------------------------------------------
1581   45E5             setaErro: 
1582   45E5 37          	scf
1583   45E6 18 DC       	jr		disableSDs
1584   45E8             
1585   45E8             ; ------------------------------------------------
1586   45E8             ; Enviar comando em A com 2 bytes de parametros
1587   45E8             ; em DE e testar retorno BUSY
1588   45E8             ; Retorna em A a resposta do cartao
1589   45E8             ; Destroi AF, BC
1590   45E8             ; ------------------------------------------------
1591   45E8             SD_SEND_CMD_2_ARGS_TEST_BUSY: 
1592   45E8 01 00 00    	ld	bc, 0
1593   45EB CD 0E 46    	call	SD_SEND_CMD
1594   45EE 47          	ld	b, a
1595   45EF E6 FE       	and	$FE		; testar bit 0 (flag BUSY)
1596   45F1 78          	ld	a, b
1597   45F2 20 F1       	jr	nz,setaErro	; BUSY em 1, informar erro
1598   45F4 C9          	ret			; sem erros
1599   45F5             
1600   45F5             ; ------------------------------------------------
1601   45F5             ; Enviar comando em A com 2 bytes de parametros
1602   45F5             ; em DE e ler resposta do tipo R3 em BC DE
1603   45F5             ; Retorna em A a resposta do cartao
1604   45F5             ; Destroi AF, BC, DE, HL
1605   45F5             ; ------------------------------------------------
1606   45F5             SD_SEND_CMD_2_ARGS_GET_R3: 
1607   45F5 CD E8 45    	call	SD_SEND_CMD_2_ARGS_TEST_BUSY
1608   45F8 D8          	ret	c
1609   45F9 F5          	push	af
1610   45FA CD 48 46    	call	WAIT_RESP_NO_FF
1611   45FD 67          	ld	h, a
1612   45FE CD 48 46    	call	WAIT_RESP_NO_FF
1613   4601 6F          	ld	l, a
1614   4602 CD 48 46    	call	WAIT_RESP_NO_FF
1615   4605 57          	ld	d, a
1616   4606 CD 48 46    	call	WAIT_RESP_NO_FF
1617   4609 5F          	ld	e, a
1618   460A 44          	ld	b, h
1619   460B 4D          	ld	c, l
1620   460C F1          	pop	af
1621   460D C9          	ret
1622   460E             
1623   460E             ; ------------------------------------------------
1624   460E             ; Enviar comando em A com 4 bytes de parametros
1625   460E             ; em BC DE e enviar CRC correto se for CMD0 ou 
1626   460E             ; CMD8 e aguardar processamento do cartao
1627   460E             ; Output  : A=0 if there was no error
1628   460E             ; Modifies:  AF, B, AF'
1629   460E             ; ------------------------------------------------
1630   460E             SD_SEND_CMD: 
1631   460E CD 66 46    	call	setaSDAtual
1632   4611 32 00 7B    	ld	(SPIDATA), a
1633   4614 F5          	push	af
1634   4615 78          	ld	a, b
1635   4616 32 00 7B    	ld	(SPIDATA), a
1636   4619 79          	ld	a, c
1637   461A 32 00 7B    	ld	(SPIDATA), a
1638   461D 7A          	ld	a, d
1639   461E 32 00 7B    	ld	(SPIDATA), a
1640   4621 7B          	ld	a, e
1641   4622 32 00 7B    	ld	(SPIDATA), a
1642   4625 F1          	pop	af
1643   4626 FE 40       	cp	CMD0
1644   4628 06 95       	ld	b, $95		; CRC para CMD0
1645   462A 28 08       	jr	z,enviaCRC
1646   462C FE 48       	cp	CMD8
1647   462E 06 87       	ld	b, $87		; CRC para CMD8
1648   4630 28 02       	jr	z,enviaCRC
1649   4632 06 FF       	ld	b, $FF		; CRC dummy
1650   4634             enviaCRC: 
1651   4634 78          	ld	a, b
1652   4635 32 00 7B    	ld	(SPIDATA), a
1653   4638 18 0E       	jr	WAIT_RESP_NO_FF
1654   463A             
1655   463A             ; ------------------------------------------------
1656   463A             ; Esperar que resposta do cartao seja $FE
1657   463A             ; Destroi AF, B
1658   463A             ; ------------------------------------------------
1659   463A             WAIT_RESP_FE: 
1660   463A 06 0A       	ld	b, 10		; 10 tentativas
1661   463C             .loop: 
1662   463C C5          	push	bc
1663   463D CD 48 46    	call	WAIT_RESP_NO_FF	; esperar resposta diferente de $FF
1664   4640 C1          	pop	bc
1665   4641 FE FE       	cp	$FE		; resposta  $FE ?
1666   4643 C8          	ret	z		; sim, retornamos com carry=0
1667   4644 10 F6       	djnz	.loop
1668   4646 37          	scf			; erro, carry=1
1669   4647 C9          	ret
1670   4648             
1671   4648             ; ------------------------------------------------
1672   4648             ; Esperar que resposta do cartao seja diferente
1673   4648             ; de $FF
1674   4648             ; Destroi AF, BC
1675   4648             ; ------------------------------------------------
1676   4648             WAIT_RESP_NO_FF: 
1677   4648 01 01 00    	ld	bc, 1		; 256 tentativas
1678   464B             .loop: 
1679   464B 3A 00 7B    	ld	a, (SPIDATA)
1680   464E FE FF       	cp	$FF		; testa $FF
1681   4650 C0          	ret	nz		; sai se nao for $FF
1682   4651 10 F8       	djnz	.loop
1683   4653 0D          	dec	c
1684   4654 20 F5       	jr	nz,.loop
1685   4656 C9          	ret
1686   4657             
1687   4657             ; ------------------------------------------------
1688   4657             ; Esperar que resposta do cartao seja diferente
1689   4657             ; de $00
1690   4657             ; Destroi A, BC
1691   4657             ; ------------------------------------------------
1692   4657             WAIT_RESP_NO_00: 
1693   4657 01 80 00    	ld	bc, 128		; 32768 tentativas
1694   465A             .loop: 
1695   465A 3A 00 7B    	ld	a, (SPIDATA)
1696   465D B7          	or	a
1697   465E C0          	ret	nz			; se resposta for <> $00, sai
1698   465F 10 F9       	djnz	.loop
1699   4661 0D          	dec	c
1700   4662 20 F6       	jr	nz,.loop
1701   4664 37          	scf			; erro
1702   4665 C9          	ret
1703   4666             
1704   4666             ; ------------------------------------------------
1705   4666             ; Sets the requested card slot and check its status
1706   4666             ; In case it detects that the card was changed, it will call the detection
1707   4666             ; routine to re-dectect the card type
1708   4666             ; Input: Target card slot
1709   4666             ; Output: Cy = No SD card is present
1710   4666             ;         A: 0=The same card is still present
1711   4666             ;            1=The card was changed since the last check
1712   4666             ; ------------------------------------------------
1713   4666             setaSDAtual: 
1714   4666 F5          	push	af
1715   4667 3A 00 7B    	ld	a, (SPIDATA)	; dummy read
1716   466A FD 7E 30    	ld	a, (iy+WRKAREA.NUMSD)
1717   466D 32 F0 7F    	ld	(SPICTRL), a
1718   4670 F1          	pop	af
1719   4671 C9          	ret
1720   4672             
1721   4672              IFDEF BLA
1722   4672~            	ld	a, (SPIDATA)	; dummy read
1723   4672~            	ld	a, (iy+WRKAREA.NUMSD)
1724   4672~            ;	cpl			; invert bits
1725   4672~            ;	and	3
1726   4672~            	ld	(SPICTRL), a
1727   4672~            	;
1728   4672~            	ld	a,(SPISTATUS)	; Get this card slot status
1729   4672~            	bit	SD_PRESENT,a	; Is there a card present?
1730   4672~            	scf
1731   4672~            	ret	nz		; No, return with error
1732   4672~            1733   4672~            	; ***Workaround for the problem that Nextor doesn't call DEV_STATUS to
1734   4672~            	; check if the media has changed before every disk operation, so we
1735   4672~            	; need to always check if it changed.
1736   4672~            	and	SD_M_DSKCHG	; Was the card changed since last checked?
1737   4672~            	ret	z		; No, return
1738   4672~            	push	bc,de,hl,ix
1739   4672~            	call	detectaCartao	; Detect the new card
1740   4672~            	pop	ix,hl,de,bc
1741   4672~            	ret	c		; Error? Then return
1742   4672~            	ld	a,1
1743   4672~            	ret
1744   4672              ENDIF ; BLA
1745   4672             
1746   4672             ; ------------------------------------------------
1747   4672             ; Grava um bloco de 512 bytes no cartao
1748   4672             ; HL = aponta para o inicio dos dados
1749   4672             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
1750   4672             ; IXH = Number of blocks
1751   4672             ; IXL = SDcard version (0 or 1)
1752   4672             ; Modifies:  AF, BC, DE, HL, IXL
1753   4672             ; ------------------------------------------------
1754   4672             GravarBloco: 
1755   4672              IFDEF DEBUG
1756   4672~            	push	af
1757   4672~            	ld	a,'G'
1758   4672~            	call	PRTCHAR
1759   4672~            	pop	af
1760   4672              ENDIF
1761   4672             ;	ld	a, (ix+15)	; verificar se eh SDV1 ou SDV2
1762   4672 DD 7D       	ld	a,ixl
1763   4674 B7          	or	a
1764   4675 CC 68 47    	call	z,blocoParaByte		; se for SDV1 coverter blocos para bytes
1765   4678             ;	call	setaSDAtual	; selecionar cartao atual
1766   4678 FD 7E 32    	ld	a, (iy+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
1767   467B DD 67       	ld	ixh,a		; ixh=Number of blocks
1768   467D 3D          	dec	a
1769   467E CA E1 46    	jp	z,.umBloco	; somente um bloco, gravar usando CMD24
1770   4681             
1771   4681             ; multiplos blocos
1772   4681              IFDEF DEBUG
1773   4681~            	push	af
1774   4681~            	ld	a,'M'
1775   4681~            	call	PRTCHAR
1776   4681~            	pop	af
1777   4681              ENDIF
1778   4681 C5          	push	bc
1779   4682 D5          	push	de
1780   4683 3E 77       	ld	a, CMD55	; Multiplos blocos, mandar ACMD23 com total de blocos
1781   4685 CD DB 45    	call	SD_SEND_CMD_NO_ARGS
1782   4688 3E 57       	ld	a, ACMD23
1783   468A 01 00 00    	ld	bc, 0
1784   468D 51          	ld	d, c
1785   468E FD 5E 32    	ld	e, (iy+WRKAREA.NUMBLOCKS)	; parametro = total de blocos a gravar
1786   4691 CD E0 45    	call	SD_SEND_CMD_GET_ERROR
1787   4694 D1          	pop	de
1788   4695 C1          	pop	bc
1789   4696 DA 0E 47    	jp	c,terminaLeituraEscritaBloco	; erro no ACMD23
1790   4699              IFDEF DEBUG
1791   4699~            	call	PRTDOT
1792   4699              ENDIF
1793   4699 3E 59       	ld	a, CMD25	; comando CMD25 = write multiple blocks
1794   469B CD E0 45    	call	SD_SEND_CMD_GET_ERROR
1795   469E DA 0E 47    	jp	c,terminaLeituraEscritaBloco	; erro
1796   46A1              IFDEF DEBUG
1797   46A1~            	call	PRTDOT
1798   46A1              ENDIF
1799   46A1             .loop: 
1800   46A1              IFDEF DEBUG
1801   46A1~            	call	PRTDASH
1802   46A1              ENDIF
1803   46A1 3E FC       	ld	a, $FC		; mandar $FC para indicar que os proximos dados sao
1804   46A3 32 00 7B    	ld	(SPIDATA),a	; dados para gravacao
1805   46A6             
1806   46A6 11 00 7B    	ld	de,SPIDATA
1807   46A9 CD 6B 4D    	call	RUN_HLPR
1808   46AC             
1809   46AC 3E FF       	ld	a,$FF		; envia dummy CRC
1810   46AE 32 00 7B    	ld	(SPIDATA),a	; Can't be done with ld (SPIDATA),de. It's too fast
1811   46B1 32 00 7B    	ld	(SPIDATA),a
1812   46B4 CD 48 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1813   46B7 E6 1F       	and	$1F		; testa bits erro
1814   46B9 FE 05       	cp	5
1815   46BB 37          	scf
1816   46BC C2 0E 47    	jp	nz,terminaLeituraEscritaBloco	; resposta errada, informar erro
1817   46BF CD 57 46    	call	WAIT_RESP_NO_00	; esperar cartao
1818   46C2 DA 0E 47    	jp	c,terminaLeituraEscritaBloco
1819   46C5 DD 25       	dec	ixh		; Next block
1820   46C7 C2 A1 46    	jp	nz,.loop
1821   46CA             
1822   46CA 3A 00 7B    	ld	a, (SPIDATA)	; acabou os blocos, fazer 2 dummy reads
1823   46CD 3A 00 7B    	ld	a, (SPIDATA)
1824   46D0 3E FD       	ld	a, $FD		; enviar $FD para informar ao cartao que acabou os dados
1825   46D2 32 00 7B    	ld	(SPIDATA),a
1826   46D5 3A 00 7B    	ld	a,(SPIDATA)	; 2 dummy reads
1827   46D8 3A 00 7B    	ld	a,(SPIDATA)
1828   46DB CD 57 46    	call	WAIT_RESP_NO_00	; esperar cartao
1829   46DE C3 0D 47    	jp	.fim		; CMD25 concluido, sair informando nenhum erro
1830   46E1             
1831   46E1             .umBloco: 
1832   46E1              IFDEF DEBUG
1833   46E1~            	push	af
1834   46E1~            	ld	a,'S'
1835   46E1~            	call	PRTCHAR
1836   46E1~            	pop	af
1837   46E1              ENDIF
1838   46E1 3E 58       	ld	a, CMD24	; gravar somente um bloco com comando CMD24 = Write Single Block
1839   46E3 CD E0 45    	call	SD_SEND_CMD_GET_ERROR
1840   46E6 DA 0E 47    	jp	c,terminaLeituraEscritaBloco	; erro
1841   46E9             
1842   46E9              IFDEF DEBUG
1843   46E9~            	call	PRTDOT
1844   46E9              ENDIF
1845   46E9 3E FE       	ld	a, $FE		; mandar $FE para indicar que vamos mandar dados para gravacao
1846   46EB 32 00 7B    	ld	(SPIDATA),a
1847   46EE             
1848   46EE 11 00 7B    	ld	de,SPIDATA
1849   46F1 CD 6B 4D    	call	RUN_HLPR
1850   46F4             
1851   46F4 3E FF       	ld	a,$FF		; envia dummy CRC
1852   46F6 32 00 7B    	ld	(SPIDATA),a	; Can't be done with ld (SPIDATA),de. It's too fast
1853   46F9 32 00 7B    	ld	(SPIDATA),a
1854   46FC             
1855   46FC CD 48 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1856   46FF E6 1F       	and	$1F		; testa bits erro
1857   4701 FE 05       	cp	5
1858   4703 37          	scf
1859   4704 C2 0E 47    	jp	nz,terminaLeituraEscritaBloco	; resposta errada, informar erro
1860   4707             .esp: 
1861   4707 CD 48 46    	call	WAIT_RESP_NO_FF	; esperar cartao
1862   470A B7          	or	a
1863   470B 28 FA       	jr	z,.esp
1864   470D             .fim: 
1865   470D AF          	xor	a		; zera carry e informa nenhum erro
1866   470E             terminaLeituraEscritaBloco: 
1867   470E             ;	push	af
1868   470E CD C4 45    	call	disableSDs	; desabilitar todos os cartoes
1869   4711             ;	pop	af
1870   4711 C9          	ret
1871   4712             
1872   4712             
1873   4712             ; ------------------------------------------------
1874   4712             ; Ler um bloco de 512 bytes do cartao
1875   4712             ; HL =  aponta para o inicio dos dados
1876   4712             ; BC:DE = contem o numero do bloco (BCDE = 32 bits)
1877   4712             ; IXH = Number of blocks
1878   4712             ; IXL = SDcard version (0 or 1)
1879   4712             ; Destroi AF, BC, DE, HL, IXL
1880   4712             ; ------------------------------------------------
1881   4712             LerBloco: 
1882   4712             ;	ld	a, (ix+15)	; verificar se eh SDV1 ou SDV2
1883   4712 DD 7D       	ld	a,ixl
1884   4714 B7          	or	a
1885   4715 CC 68 47    	call	z,blocoParaByte	; se for SDV1 coverter blocos para bytes
1886   4718             ;	call	setaSDAtual
1887   4718             
1888   4718 FD 7E 32    	ld	a, (iy+WRKAREA.NUMBLOCKS)	; Get the number of blocka 
1889   471B DD 67       	ld	ixh,a		; ixh=Number of blocks
1890   471D 3D          	dec	a
1891   471E CA 49 47    	jp	z,.umBloco	; only one block
1892   4721             
1893   4721             ; multiplos blocos
1894   4721 3E 52       	ld	a, CMD18	; ler multiplos blocos com CMD18 = Read Multiple Blocks
1895   4723 CD E0 45    	call	SD_SEND_CMD_GET_ERROR
1896   4726 DA 0E 47    	jp	c,terminaLeituraEscritaBloco
1897   4729 EB          	ex	de,hl		; de=Destination address
1898   472A             .loop: 
1899   472A CD 3A 46    	call	WAIT_RESP_FE
1900   472D DA 0E 47    	jp	c,terminaLeituraEscritaBloco
1901   4730             
1902   4730 21 00 7B    	ld	hl, SPIDATA
1903   4733 CD 6B 4D    	call	RUN_HLPR
1904   4736             
1905   4736             ;	ld	hl, (SPIDATA)	; descarta CRC
1906   4736 3A 00 7B    	ld	a, (SPIDATA)
1907   4739 3A 00 7B    	ld	a, (SPIDATA)
1908   473C DD 25       	dec	ixh
1909   473E C2 2A 47    	jp	nz,.loop
1910   4741 3E 4C       	ld	a, CMD12	; acabou os blocos, mandar CMD12 para cancelar leitura
1911   4743 CD DB 45    	call	SD_SEND_CMD_NO_ARGS
1912   4746 C3 64 47    	jp	.fim
1913   4749             
1914   4749             .umBloco: 
1915   4749 3E 51       	ld	a, CMD17	; ler somente um bloco com CMD17 = Read Single Block
1916   474B CD E0 45    	call	SD_SEND_CMD_GET_ERROR
1917   474E DA 0E 47    	jp	c,terminaLeituraEscritaBloco
1918   4751             
1919   4751 CD 3A 46    	call	WAIT_RESP_FE
1920   4754 DA 0E 47    	jp	c,terminaLeituraEscritaBloco
1921   4757 EB          	ex	de,hl
1922   4758             
1923   4758 21 00 7B    	ld	hl, SPIDATA
1924   475B CD 6B 4D    	call	RUN_HLPR
1925   475E             
1926   475E             ;	ld	hl, (SPIDATA)	; descarta CRC
1927   475E 3A 00 7B    	ld	a, (SPIDATA)
1928   4761 3A 00 7B    	ld	a, (SPIDATA)
1929   4764             .fim: 
1930   4764 AF          	xor	a		; zera carry para informar leitura sem erros
1931   4765 C3 0E 47    	jp	terminaLeituraEscritaBloco
1932   4768             
1933   4768             
1934   4768             ; ------------------------------------------------
1935   4768             ; Converte blocos para bytes. Na pratica faz
1936   4768             ; BC DE = (BC DE) * 512
1937   4768             ; ------------------------------------------------
1938   4768             blocoParaByte: 
1939   4768 41          	ld	b, c
1940   4769 4A          	ld	c, d
1941   476A 53          	ld	d, e
1942   476B 1E 00       	ld	e, 0
1943   476D CB 22       	sla	d
1944   476F CB 11       	rl	c
1945   4771 CB 10       	rl	b
1946   4773 C9          	ret
1947   4774             
1948   4774             ; ------------------------------------------------
1949   4774             ; Funcoes utilitarias
1950   4774             ; ------------------------------------------------
1951   4774             
1952   4774             
1953   4774             ; ------------------------------------------------
1954   4774             ; Imprime string na tela apontada por DE
1955   4774             ; Destroi todos os registradores
1956   4774             ; ------------------------------------------------
1957   4774             printString: 
1958   4774 1A          	ld	a, (de)
1959   4775 B7          	or	a
1960   4776 C8          	ret	z
1961   4777 CD A2 00    	call	CHPUT
1962   477A 13          	inc	de
1963   477B 18 F7       	jr	printString
1964   477D             
1965   477D             
1966   477D             ; ------------------------------------------------
1967   477D             ; Converte o byte em A para string em decimal no
1968   477D             ; buffer apontado por hl
1969   477D             ; Destroi AF, BC, HL, DE
1970   477D             ; Output: hl=pointer to the end of the buffer
1971   477D             ; ------------------------------------------------
1972   477D             DecToAscii: 
1973   477D EB          	ex	de,hl		; de=pointer to buffer
1974   477E 26 00       	ld	h, 0
1975   4780 6F          	ld	l, a		; copiar A para HL
1976   4781 FD 36 39 01 	ld	(iy+WRKAREA.TEMP),1	; flag para indicar que devemos cortar os zeros a esquerda
1977   4785 01 9C FF    	ld	bc, -100	; centenas
1978   4788 CD 9B 47    	call	.num1
1979   478B 0E F6       	ld	c, -10		; dezenas
1980   478D CD 9B 47    	call	.num1
1981   4790 FD 36 39 02 	ld	(iy+WRKAREA.TEMP),2	; unidade deve exibir 0 se for zero e nao corta-lo
1982   4794 0E FF       	ld	c, -1		; unidades
1983   4796 CD 9B 47    	call	.num1
1984   4799 EB          	ex	de,hl
1985   479A C9          	ret
1986   479B             
1987   479B             .num1: 
1988   479B 3E 2F       	ld	a, '0'-1
1989   479D             .num2: 
1990   479D 3C          	inc	a		; contar o valor em ascii de '0' a '9'
1991   479E 09          	add	hl, bc		; somar com negativo
1992   479F 38 FC       	jr	c,.num2		; ainda nao zeramos
1993   47A1 ED 42       	sbc	hl, bc		; retoma valor original
1994   47A3 FD 35 39    	dec	(iy+WRKAREA.TEMP)	; se flag do corte do zero indicar para nao cortar, pula
1995   47A6 20 08       	jr	nz,.naozero
1996   47A8 FE 30       	cp	'0'		; devemos cortar os zeros a esquerda. Eh zero?
1997   47AA 20 04       	jr	nz,.naozero
1998   47AC FD 34 39    	inc	(iy+WRKAREA.TEMP)	; se for zero, nao salvamos e voltamos a flag
1999   47AF C9          	ret
2000   47B0             .naozero: 
2001   47B0 12          	ld	(de), a		; eh zero ou eh outro numero, salvar
2002   47B1 13          	inc	de		; incrementa ponteiro de destino
2003   47B2 C9          	ret
2004   47B3             
2005   47B3             ; ------------------------------------------------
2006   47B3             ; Converte o byte em A para string em hexa no
2007   47B3             ; buffer apontado por DE
2008   47B3             ; Destroi AF, C, DE
2009   47B3             ; ------------------------------------------------
2010   47B3             HexToAscii: 
2011   47B3 4F          	ld	c, a
2012   47B4 1F          	rra
2013   47B5 1F          	rra
2014   47B6 1F          	rra
2015   47B7 1F          	rra
2016   47B8 CD BC 47    	call	.conv
2017   47BB 79          	ld  	a, c
2018   47BC             .conv: 
2019   47BC E6 0F       	and	$0F
2020   47BE C6 90       	add	a, $90
2021   47C0 27          	daa
2022   47C1 CE 40       	adc	a, $40
2023   47C3 27          	daa
2024   47C4 12          	ld	(de), a
2025   47C5 13          	inc	de
2026   47C6 C9          	ret
2027   47C7             
2028   47C7             ; ------------------------------------------------
2029   47C7             ; Converte o byte em A para string em decimal e
2030   47C7             ; imprime na tela
2031   47C7             ; Destroi AF, BC, HL, DE
2032   47C7             ; ------------------------------------------------
2033   47C7             printDecToAscii: 
2034   47C7 26 00       	ld	h, 0
2035   47C9 6F          	ld	l, a		; copiar A para HL
2036   47CA 06 01       	ld	b, 1		; flag para indicar que devemos cortar os zeros a esquerda
2037   47CC 11 9C FF    	ld	de, -100	; centenas
2038   47CF CD DB 47    	call	.num1
2039   47D2 1E F6       	ld	e, -10		; dezenas
2040   47D4 CD DB 47    	call	.num1
2041   47D7 06 02       	ld	b, 2		; unidade deve exibir 0 se for zero e nao corta-lo
2042   47D9 1E FF       	ld	e, -1		; unidades
2043   47DB             .num1: 
2044   47DB 3E 2F       	ld	a, '0'-1
2045   47DD             .num2: 
2046   47DD 3C          	inc	a		; contar o valor em ascii de '0' a '9'
2047   47DE 19          	add	hl, de		; somar com negativo
2048   47DF 38 FC       	jr	c,.num2		; ainda nao zeramos
2049   47E1 ED 52       	sbc	hl, de		; retoma valor original
2050   47E3 10 06       	djnz	.naozero	; se flag do corte do zero indicar para nao cortar, pula
2051   47E5 FE 30       	cp	'0'		; devemos cortar os zeros a esquerda. Eh zero?
2052   47E7 20 02       	jr	nz,.naozero
2053   47E9 04          	inc	b		; se for zero, nao imprimimos e voltamos a flag
2054   47EA C9          	ret
2055   47EB             .naozero: 
2056   47EB             ;	push	hl		; nao eh zero ou eh outro numero, imprimir
2057   47EB             ;	push	bc
2058   47EB             ;	call	CHPUT
2059   47EB             ;	pop	bc
2060   47EB             ;	pop	hl
2061   47EB             ;	ret
2062   47EB C3 A2 00    	jp	CHPUT
2063   47EE             
2064   47EE             ; ------------------------------------------------
2065   47EE             ; Procura pelo nome do fabricante em uma tabela.
2066   47EE             ; A contem o byte do fabricante
2067   47EE             ; Devolve HL apontando para o buffer do fabricante
2068   47EE             ; e BC com o comprimento do texto
2069   47EE             ; Destroi AF, BC, HL
2070   47EE             ; ------------------------------------------------
2071   47EE             pegaFabricante: 
2072   47EE 4F          	ld	c, a
2073   47EF 21 10 48    	ld	hl, tblFabricantes
2074   47F2             
2075   47F2             .loop: 
2076   47F2 7E          	ld	a, (hl)
2077   47F3 23          	inc	hl
2078   47F4 B9          	cp	c
2079   47F5 28 0C       	jr	z,.achado
2080   47F7 B7          	or	a
2081   47F8 28 09       	jr	z,.achado
2082   47FA C5          	push	bc
2083   47FB CD 03 48    	call	.achado
2084   47FE 09          	add	hl, bc
2085   47FF 23          	inc	hl
2086   4800 C1          	pop	bc
2087   4801 18 EF       	jr	.loop
2088   4803             
2089   4803             .achado: 
2090   4803 0E 00       	ld	c, 0
2091   4805 E5          	push	hl
2092   4806 AF          	xor	a
2093   4807             .loop2: 
2094   4807 0C          	inc	c
2095   4808 23          	inc	hl
2096   4809 BE          	cp	(hl)
2097   480A 20 FB       	jr	nz,.loop2
2098   480C E1          	pop	hl
2099   480D 06 00       	ld	b, 0
2100   480F C9          	ret
2101   4810             
2102   4810             tblFabricantes: 
2103   4810 01          	db	1
2104   4811             	db	"Panasonic",0
2104   4811 50616E61736F6E696300
2105   481B 02          	db	2
2106   481C             	db	"Toshiba",0
2106   481C 546F736869626100
2107   4824 03          	db	3
2108   4825             	db	"SanDisk",0
2108   4825 53616E4469736B00
2109   482D 04          	db	4
2110   482E             	db	"SMI-S",0
2110   482E 534D492D5300
2111   4834 06          	db	6
2112   4835             	db	"Renesas",0
2112   4835 52656E6573617300
2113   483D 11          	db	17
2114   483E             	db	"Dane-Elec",0
2114   483E 44616E652D456C656300
2115   4848 13          	db	19
2116   4849             	db	"KingMax",0
2116   4849 4B696E674D617800
2117   4851 15          	db	21
2118   4852             	db	"Samsung",0
2118   4852 53616D73756E6700
2119   485A 18          	db	24
2120   485B             	db	"Infineon",0
2120   485B 496E66696E656F6E00
2121   4864 1A          	db	26
2122   4865 50 51 49 00 	db	"PQI",0
2123   4869 1B          	db	27
2124   486A 536F6E7900  	db	"Sony",0
2125   486F 1C          	db	28
2126   4870             	db	"Transcend",0
2126   4870 5472616E7363656E6400
2127   487A 1D          	db	29
2128   487B             	db	"A-DATA",0
2128   487B 412D4441544100
2129   4882 1F          	db	31
2130   4883             	db	"SiliconPower",0
2130   4883 53696C69636F6E506F77657200
2131   4890 27          	db	39
2132   4891             	db	"Verbatim",0
2132   4891 566572626174696D00
2133   489A 41          	db	65
2134   489B 4F 4B 49 00 	db	"OKI",0
2135   489F 73          	db	115
2136   48A0             	db	"SilverHT",0
2136   48A0 53696C766572485400
2137   48A9 89          	db	137
2138   48AA             	db	"L.Data",0
2138   48AA 4C2E4461746100
2139   48B1 00          	db	0
2140   48B2             	db	"Generico",0
2140   48B2 47656E657269636F00
2141   48BB             
2142   48BB             
2143   48BB             ; ------------------------------------------------
2144   48BB             ; Restore screen parameters on MSX>=2 if they're
2145   48BB             ; not set yet
2146   48BB             ; ------------------------------------------------
2147   48BB             MYSETSCR: 
2148   48BB 3A 2D 00    	ld	a,(MSXVER)
2149   48BE B7          	or	a			; MSX1?
2150   48BF 20 08       	jr	nz,.notMSX1		; No, skip
2151   48C1             .MSX1: 
2152   48C1 3A AF FC    	ld	a,(SCRMOD)
2153   48C4 B7          	or	a			; SCREEN0 already?
2154   48C5 C8          	ret	z			; Yes, quit
2155   48C6 C3 6C 00    	jp	INITXT			; set screen0
2156   48C9             
2157   48C9             .notMSX1: 
2158   48C9 0E 23       	ld	c,$23			; Block-2, R#3
2159   48CB DD 21 F5 01 	ld 	ix,REDCLK
2160   48CF CD 5F 01    	call	EXTROM
2161   48D2 E6 01       	and	1
2162   48D4 47          	ld	b,a
2163   48D5 3A AF FC    	ld	a,(SCRMOD)
2164   48D8 B8          	cp	b
2165   48D9 20 1C       	jr	nz,.restore
2166   48DB 0C          	inc	c
2167   48DC DD 21 F5 01 	ld 	ix,REDCLK
2168   48E0 CD 5F 01    	call	EXTROM
2169   48E3 47          	ld	b,a
2170   48E4 0C          	inc	c
2171   48E5 DD 21 F5 01 	ld 	ix,REDCLK
2172   48E9 CD 5F 01    	call	EXTROM
2173   48EC 87          	add	a,a
2174   48ED 87          	add	a,a
2175   48EE 87          	add	a,a
2176   48EF 87          	add	a,a
2177   48F0 B0          	or	b
2178   48F1 47          	ld	b,a
2179   48F2 3A B0 F3    	ld	a,(LINLEN)
2180   48F5 B8          	cp	b
2181   48F6 C8          	ret	z
2182   48F7             .restore: 
2183   48F7 AF          	xor	a		; Don't displat the function keys
2184   48F8 DD 21 85 01 	ld	ix,SDFSCR
2185   48FC C3 5F 01    	jp	EXTROM
2186   48FF             
2187   48FF             ; ------------------------------------------------
2188   48FF             ; Check if the STOP key was signaled on DRV_INIT
2189   48FF             ; ------------------------------------------------
2190   48FF             INICHKSTOP: 
2191   48FF 3A 9B FC    	ld	a,(INTFLG)
2192   4902 FE 04       	cp	4			; Was STOP pressed?
2193   4904 C0          	ret	nz			; No, quit as fast as possible 
2194   4905             
2195   4905             	; Handle STOP to pause and read messages, and ask for the copyright info
2196   4905 11 A3 4D    	ld	de,strBootpaused
2197   4908 CD 74 47    	call	printString
2198   490B 3E 07       .wait1: 	ld	a,7
2199   490D CD 41 01    	call	SNSMAT
2200   4910 E6 10       	and	$10			; Is STOP still pressed?
2201   4912 28 F7       	jr	z,.wait1		; Wait for STOP to be released
2202   4914 AF          	xor	a
2203   4915 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2204   4918 06 00       	ld	b,0			; b=inhibit 'i' key flag
2205   491A CD 9C 00    .wait2:  call	CHSNS
2206   491D C4 3A 49    	call	nz,.chkikey		; Wait until a key is pressed
2207   4920 3A 9B FC    	ld	a,(INTFLG)
2208   4923 FE 04       	cp	4			; Was STOP pressed?
2209   4925 20 F3       	jr	nz,.wait2		; No, return
2210   4927 AF          	xor	a
2211   4928 32 9B FC    	ld	(INTFLG),a		; Clear STOP flag
2212   492B CD 56 01    	call	KILBUF
2213   492E 06 1E       	ld	b,30			; Since the user is trying pause the
2214   4930 76          .wait3: 	halt				; boot messages, this gives him enough
2215   4931             					; time to react and pause the next
2216   4931             					; driver
2217   4931 3A 9B FC    	ld	a,(INTFLG)
2218   4934 FE 04       	cp	4			; Was STOP pressed?
2219   4936 C8          	ret	z			; quit so the next driver can process it
2220   4937 10 F7       	djnz	.wait3			; The user will have the impression
2221   4939             					; that he has a perfect timing.   ;)
2222   4939 C9          	ret
2223   493A             
2224   493A             .chkikey: 
2225   493A CB 40       	bit	0,b			; Was the copyright message shown?
2226   493C C0          	ret	nz			; Yes, return
2227   493D CD 9F 00    	call	CHGET
2228   4940 FE 69       	cp	'i'
2229   4942 28 03       	jr	z,.showcopyright
2230   4944 FE 49       	cp	'I'
2231   4946 C0          	ret	nz
2232   4947             .showcopyright: 
2233   4947 04          	inc	b			; Inhibit further presses of the i key 
2234   4948 11 CE 4D    	ld	de,strCopyright
2235   494B C3 74 47    	jp	printString
2236   494E             
2237   494E             
2238   494E             
2239   494E             ; ------------------------------------------------
2240   494E             ; Install the R800 data transfer helper routine on WorkArea 
2241   494E             ; ------------------------------------------------
2242   494E             INSTR800HLP: 
2243   494E 3A 2D 00    	ld	a,(MSXVER)
2244   4951 FE 03       	cp	3		; MSX Turbo-R?
2245   4953 D8          	ret	c		; No, return
2246   4954 CD 7A 4D    	call	GTR800LDIR
2247   4957 D9          	exx
2248   4958 EB          	ex	de,hl
2249   4959 21 62 49    	ld	hl,R800DATHLP
2250   495C 01 07 00    	ld	bc,R800DATHLP.end-R800DATHLP
2251   495F ED B0       	ldir
2252   4961 C9          	ret
2253   4962             
2254   4962             ; ------------------------------------------------
2255   4962             ; R800 optimized data transfer routine, copied to the WorkArea
2256   4962             ; ------------------------------------------------
2257   4962             R800DATHLP: 
2258   4962 D9          	exx
2259   4963 01 00 02    	ld	bc,512
2260   4966 ED B0       	ldir
2261   4968 C9          	ret
2262   4969             .end
2263   4969              
2264   4969             
2265   4969             ; ------------------------------------------------
2266   4969             ; Z80 optimized data transfer routine, kept in ROM 
2267   4969             ; ------------------------------------------------
2268   4969             LDI512: 	; Z80 optimized 512 byte transfer
2269   4969 D9          	exx
2270   496A ED A0       > ldi
2270   496C ED A0       > ldi
2270   496E ED A0       > ldi
2270   4970 ED A0       > ldi
2270   4972 ED A0       > ldi
2270   4974 ED A0       > ldi
2270   4976 ED A0       > ldi
2270   4978 ED A0       > ldi
2270   497A ED A0       > ldi
2270   497C ED A0       > ldi
2270   497E ED A0       > ldi
2270   4980 ED A0       > ldi
2270   4982 ED A0       > ldi
2270   4984 ED A0       > ldi
2270   4986 ED A0       > ldi
2270   4988 ED A0       > ldi
2270   498A ED A0       > ldi
2270   498C ED A0       > ldi
2270   498E ED A0       > ldi
2270   4990 ED A0       > ldi
2270   4992 ED A0       > ldi
2270   4994 ED A0       > ldi
2270   4996 ED A0       > ldi
2270   4998 ED A0       > ldi
2270   499A ED A0       > ldi
2270   499C ED A0       > ldi
2270   499E ED A0       > ldi
2270   49A0 ED A0       > ldi
2270   49A2 ED A0       > ldi
2270   49A4 ED A0       > ldi
2270   49A6 ED A0       > ldi
2270   49A8 ED A0       > ldi
2270   49AA ED A0       > ldi
2270   49AC ED A0       > ldi
2270   49AE ED A0       > ldi
2270   49B0 ED A0       > ldi
2270   49B2 ED A0       > ldi
2270   49B4 ED A0       > ldi
2270   49B6 ED A0       > ldi
2270   49B8 ED A0       > ldi
2270   49BA ED A0       > ldi
2270   49BC ED A0       > ldi
2270   49BE ED A0       > ldi
2270   49C0 ED A0       > ldi
2270   49C2 ED A0       > ldi
2270   49C4 ED A0       > ldi
2270   49C6 ED A0       > ldi
2270   49C8 ED A0       > ldi
2270   49CA ED A0       > ldi
2270   49CC ED A0       > ldi
2270   49CE ED A0       > ldi
2270   49D0 ED A0       > ldi
2270   49D2 ED A0       > ldi
2270   49D4 ED A0       > ldi
2270   49D6 ED A0       > ldi
2270   49D8 ED A0       > ldi
2270   49DA ED A0       > ldi
2270   49DC ED A0       > ldi
2270   49DE ED A0       > ldi
2270   49E0 ED A0       > ldi
2270   49E2 ED A0       > ldi
2270   49E4 ED A0       > ldi
2270   49E6 ED A0       > ldi
2270   49E8 ED A0       > ldi
2270   49EA ED A0       > ldi
2270   49EC ED A0       > ldi
2270   49EE ED A0       > ldi
2270   49F0 ED A0       > ldi
2270   49F2 ED A0       > ldi
2270   49F4 ED A0       > ldi
2270   49F6 ED A0       > ldi
2270   49F8 ED A0       > ldi
2270   49FA ED A0       > ldi
2270   49FC ED A0       > ldi
2270   49FE ED A0       > ldi
2270   4A00 ED A0       > ldi
2270   4A02 ED A0       > ldi
2270   4A04 ED A0       > ldi
2270   4A06 ED A0       > ldi
2270   4A08 ED A0       > ldi
2270   4A0A ED A0       > ldi
2270   4A0C ED A0       > ldi
2270   4A0E ED A0       > ldi
2270   4A10 ED A0       > ldi
2270   4A12 ED A0       > ldi
2270   4A14 ED A0       > ldi
2270   4A16 ED A0       > ldi
2270   4A18 ED A0       > ldi
2270   4A1A ED A0       > ldi
2270   4A1C ED A0       > ldi
2270   4A1E ED A0       > ldi
2270   4A20 ED A0       > ldi
2270   4A22 ED A0       > ldi
2270   4A24 ED A0       > ldi
2270   4A26 ED A0       > ldi
2270   4A28 ED A0       > ldi
2270   4A2A ED A0       > ldi
2270   4A2C ED A0       > ldi
2270   4A2E ED A0       > ldi
2270   4A30 ED A0       > ldi
2270   4A32 ED A0       > ldi
2270   4A34 ED A0       > ldi
2270   4A36 ED A0       > ldi
2270   4A38 ED A0       > ldi
2270   4A3A ED A0       > ldi
2270   4A3C ED A0       > ldi
2270   4A3E ED A0       > ldi
2270   4A40 ED A0       > ldi
2270   4A42 ED A0       > ldi
2270   4A44 ED A0       > ldi
2270   4A46 ED A0       > ldi
2270   4A48 ED A0       > ldi
2270   4A4A ED A0       > ldi
2270   4A4C ED A0       > ldi
2270   4A4E ED A0       > ldi
2270   4A50 ED A0       > ldi
2270   4A52 ED A0       > ldi
2270   4A54 ED A0       > ldi
2270   4A56 ED A0       > ldi
2270   4A58 ED A0       > ldi
2270   4A5A ED A0       > ldi
2270   4A5C ED A0       > ldi
2270   4A5E ED A0       > ldi
2270   4A60 ED A0       > ldi
2270   4A62 ED A0       > ldi
2270   4A64 ED A0       > ldi
2270   4A66 ED A0       > ldi
2270   4A68 ED A0       > ldi
2270   4A6A ED A0       > ldi
2270   4A6C ED A0       > ldi
2270   4A6E ED A0       > ldi
2270   4A70 ED A0       > ldi
2270   4A72 ED A0       > ldi
2270   4A74 ED A0       > ldi
2270   4A76 ED A0       > ldi
2270   4A78 ED A0       > ldi
2270   4A7A ED A0       > ldi
2270   4A7C ED A0       > ldi
2270   4A7E ED A0       > ldi
2270   4A80 ED A0       > ldi
2270   4A82 ED A0       > ldi
2270   4A84 ED A0       > ldi
2270   4A86 ED A0       > ldi
2270   4A88 ED A0       > ldi
2270   4A8A ED A0       > ldi
2270   4A8C ED A0       > ldi
2270   4A8E ED A0       > ldi
2270   4A90 ED A0       > ldi
2270   4A92 ED A0       > ldi
2270   4A94 ED A0       > ldi
2270   4A96 ED A0       > ldi
2270   4A98 ED A0       > ldi
2270   4A9A ED A0       > ldi
2270   4A9C ED A0       > ldi
2270   4A9E ED A0       > ldi
2270   4AA0 ED A0       > ldi
2270   4AA2 ED A0       > ldi
2270   4AA4 ED A0       > ldi
2270   4AA6 ED A0       > ldi
2270   4AA8 ED A0       > ldi
2270   4AAA ED A0       > ldi
2270   4AAC ED A0       > ldi
2270   4AAE ED A0       > ldi
2270   4AB0 ED A0       > ldi
2270   4AB2 ED A0       > ldi
2270   4AB4 ED A0       > ldi
2270   4AB6 ED A0       > ldi
2270   4AB8 ED A0       > ldi
2270   4ABA ED A0       > ldi
2270   4ABC ED A0       > ldi
2270   4ABE ED A0       > ldi
2270   4AC0 ED A0       > ldi
2270   4AC2 ED A0       > ldi
2270   4AC4 ED A0       > ldi
2270   4AC6 ED A0       > ldi
2270   4AC8 ED A0       > ldi
2270   4ACA ED A0       > ldi
2270   4ACC ED A0       > ldi
2270   4ACE ED A0       > ldi
2270   4AD0 ED A0       > ldi
2270   4AD2 ED A0       > ldi
2270   4AD4 ED A0       > ldi
2270   4AD6 ED A0       > ldi
2270   4AD8 ED A0       > ldi
2270   4ADA ED A0       > ldi
2270   4ADC ED A0       > ldi
2270   4ADE ED A0       > ldi
2270   4AE0 ED A0       > ldi
2270   4AE2 ED A0       > ldi
2270   4AE4 ED A0       > ldi
2270   4AE6 ED A0       > ldi
2270   4AE8 ED A0       > ldi
2270   4AEA ED A0       > ldi
2270   4AEC ED A0       > ldi
2270   4AEE ED A0       > ldi
2270   4AF0 ED A0       > ldi
2270   4AF2 ED A0       > ldi
2270   4AF4 ED A0       > ldi
2270   4AF6 ED A0       > ldi
2270   4AF8 ED A0       > ldi
2270   4AFA ED A0       > ldi
2270   4AFC ED A0       > ldi
2270   4AFE ED A0       > ldi
2270   4B00 ED A0       > ldi
2270   4B02 ED A0       > ldi
2270   4B04 ED A0       > ldi
2270   4B06 ED A0       > ldi
2270   4B08 ED A0       > ldi
2270   4B0A ED A0       > ldi
2270   4B0C ED A0       > ldi
2270   4B0E ED A0       > ldi
2270   4B10 ED A0       > ldi
2270   4B12 ED A0       > ldi
2270   4B14 ED A0       > ldi
2270   4B16 ED A0       > ldi
2270   4B18 ED A0       > ldi
2270   4B1A ED A0       > ldi
2270   4B1C ED A0       > ldi
2270   4B1E ED A0       > ldi
2270   4B20 ED A0       > ldi
2270   4B22 ED A0       > ldi
2270   4B24 ED A0       > ldi
2270   4B26 ED A0       > ldi
2270   4B28 ED A0       > ldi
2270   4B2A ED A0       > ldi
2270   4B2C ED A0       > ldi
2270   4B2E ED A0       > ldi
2270   4B30 ED A0       > ldi
2270   4B32 ED A0       > ldi
2270   4B34 ED A0       > ldi
2270   4B36 ED A0       > ldi
2270   4B38 ED A0       > ldi
2270   4B3A ED A0       > ldi
2270   4B3C ED A0       > ldi
2270   4B3E ED A0       > ldi
2270   4B40 ED A0       > ldi
2270   4B42 ED A0       > ldi
2270   4B44 ED A0       > ldi
2270   4B46 ED A0       > ldi
2270   4B48 ED A0       > ldi
2270   4B4A ED A0       > ldi
2270   4B4C ED A0       > ldi
2270   4B4E ED A0       > ldi
2270   4B50 ED A0       > ldi
2270   4B52 ED A0       > ldi
2270   4B54 ED A0       > ldi
2270   4B56 ED A0       > ldi
2270   4B58 ED A0       > ldi
2270   4B5A ED A0       > ldi
2270   4B5C ED A0       > ldi
2270   4B5E ED A0       > ldi
2270   4B60 ED A0       > ldi
2270   4B62 ED A0       > ldi
2270   4B64 ED A0       > ldi
2270   4B66 ED A0       > ldi
2270   4B68 ED A0       > ldi
2270   4B6A ED A0       > ldi
2270   4B6C ED A0       > ldi
2270   4B6E ED A0       > ldi
2270   4B70 ED A0       > ldi
2270   4B72 ED A0       > ldi
2270   4B74 ED A0       > ldi
2270   4B76 ED A0       > ldi
2270   4B78 ED A0       > ldi
2270   4B7A ED A0       > ldi
2270   4B7C ED A0       > ldi
2270   4B7E ED A0       > ldi
2270   4B80 ED A0       > ldi
2270   4B82 ED A0       > ldi
2270   4B84 ED A0       > ldi
2270   4B86 ED A0       > ldi
2270   4B88 ED A0       > ldi
2270   4B8A ED A0       > ldi
2270   4B8C ED A0       > ldi
2270   4B8E ED A0       > ldi
2270   4B90 ED A0       > ldi
2270   4B92 ED A0       > ldi
2270   4B94 ED A0       > ldi
2270   4B96 ED A0       > ldi
2270   4B98 ED A0       > ldi
2270   4B9A ED A0       > ldi
2270   4B9C ED A0       > ldi
2270   4B9E ED A0       > ldi
2270   4BA0 ED A0       > ldi
2270   4BA2 ED A0       > ldi
2270   4BA4 ED A0       > ldi
2270   4BA6 ED A0       > ldi
2270   4BA8 ED A0       > ldi
2270   4BAA ED A0       > ldi
2270   4BAC ED A0       > ldi
2270   4BAE ED A0       > ldi
2270   4BB0 ED A0       > ldi
2270   4BB2 ED A0       > ldi
2270   4BB4 ED A0       > ldi
2270   4BB6 ED A0       > ldi
2270   4BB8 ED A0       > ldi
2270   4BBA ED A0       > ldi
2270   4BBC ED A0       > ldi
2270   4BBE ED A0       > ldi
2270   4BC0 ED A0       > ldi
2270   4BC2 ED A0       > ldi
2270   4BC4 ED A0       > ldi
2270   4BC6 ED A0       > ldi
2270   4BC8 ED A0       > ldi
2270   4BCA ED A0       > ldi
2270   4BCC ED A0       > ldi
2270   4BCE ED A0       > ldi
2270   4BD0 ED A0       > ldi
2270   4BD2 ED A0       > ldi
2270   4BD4 ED A0       > ldi
2270   4BD6 ED A0       > ldi
2270   4BD8 ED A0       > ldi
2270   4BDA ED A0       > ldi
2270   4BDC ED A0       > ldi
2270   4BDE ED A0       > ldi
2270   4BE0 ED A0       > ldi
2270   4BE2 ED A0       > ldi
2270   4BE4 ED A0       > ldi
2270   4BE6 ED A0       > ldi
2270   4BE8 ED A0       > ldi
2270   4BEA ED A0       > ldi
2270   4BEC ED A0       > ldi
2270   4BEE ED A0       > ldi
2270   4BF0 ED A0       > ldi
2270   4BF2 ED A0       > ldi
2270   4BF4 ED A0       > ldi
2270   4BF6 ED A0       > ldi
2270   4BF8 ED A0       > ldi
2270   4BFA ED A0       > ldi
2270   4BFC ED A0       > ldi
2270   4BFE ED A0       > ldi
2270   4C00 ED A0       > ldi
2270   4C02 ED A0       > ldi
2270   4C04 ED A0       > ldi
2270   4C06 ED A0       > ldi
2270   4C08 ED A0       > ldi
2270   4C0A ED A0       > ldi
2270   4C0C ED A0       > ldi
2270   4C0E ED A0       > ldi
2270   4C10 ED A0       > ldi
2270   4C12 ED A0       > ldi
2270   4C14 ED A0       > ldi
2270   4C16 ED A0       > ldi
2270   4C18 ED A0       > ldi
2270   4C1A ED A0       > ldi
2270   4C1C ED A0       > ldi
2270   4C1E ED A0       > ldi
2270   4C20 ED A0       > ldi
2270   4C22 ED A0       > ldi
2270   4C24 ED A0       > ldi
2270   4C26 ED A0       > ldi
2270   4C28 ED A0       > ldi
2270   4C2A ED A0       > ldi
2270   4C2C ED A0       > ldi
2270   4C2E ED A0       > ldi
2270   4C30 ED A0       > ldi
2270   4C32 ED A0       > ldi
2270   4C34 ED A0       > ldi
2270   4C36 ED A0       > ldi
2270   4C38 ED A0       > ldi
2270   4C3A ED A0       > ldi
2270   4C3C ED A0       > ldi
2270   4C3E ED A0       > ldi
2270   4C40 ED A0       > ldi
2270   4C42 ED A0       > ldi
2270   4C44 ED A0       > ldi
2270   4C46 ED A0       > ldi
2270   4C48 ED A0       > ldi
2270   4C4A ED A0       > ldi
2270   4C4C ED A0       > ldi
2270   4C4E ED A0       > ldi
2270   4C50 ED A0       > ldi
2270   4C52 ED A0       > ldi
2270   4C54 ED A0       > ldi
2270   4C56 ED A0       > ldi
2270   4C58 ED A0       > ldi
2270   4C5A ED A0       > ldi
2270   4C5C ED A0       > ldi
2270   4C5E ED A0       > ldi
2270   4C60 ED A0       > ldi
2270   4C62 ED A0       > ldi
2270   4C64 ED A0       > ldi
2270   4C66 ED A0       > ldi
2270   4C68 ED A0       > ldi
2270   4C6A ED A0       > ldi
2270   4C6C ED A0       > ldi
2270   4C6E ED A0       > ldi
2270   4C70 ED A0       > ldi
2270   4C72 ED A0       > ldi
2270   4C74 ED A0       > ldi
2270   4C76 ED A0       > ldi
2270   4C78 ED A0       > ldi
2270   4C7A ED A0       > ldi
2270   4C7C ED A0       > ldi
2270   4C7E ED A0       > ldi
2270   4C80 ED A0       > ldi
2270   4C82 ED A0       > ldi
2270   4C84 ED A0       > ldi
2270   4C86 ED A0       > ldi
2270   4C88 ED A0       > ldi
2270   4C8A ED A0       > ldi
2270   4C8C ED A0       > ldi
2270   4C8E ED A0       > ldi
2270   4C90 ED A0       > ldi
2270   4C92 ED A0       > ldi
2270   4C94 ED A0       > ldi
2270   4C96 ED A0       > ldi
2270   4C98 ED A0       > ldi
2270   4C9A ED A0       > ldi
2270   4C9C ED A0       > ldi
2270   4C9E ED A0       > ldi
2270   4CA0 ED A0       > ldi
2270   4CA2 ED A0       > ldi
2270   4CA4 ED A0       > ldi
2270   4CA6 ED A0       > ldi
2270   4CA8 ED A0       > ldi
2270   4CAA ED A0       > ldi
2270   4CAC ED A0       > ldi
2270   4CAE ED A0       > ldi
2270   4CB0 ED A0       > ldi
2270   4CB2 ED A0       > ldi
2270   4CB4 ED A0       > ldi
2270   4CB6 ED A0       > ldi
2270   4CB8 ED A0       > ldi
2270   4CBA ED A0       > ldi
2270   4CBC ED A0       > ldi
2270   4CBE ED A0       > ldi
2270   4CC0 ED A0       > ldi
2270   4CC2 ED A0       > ldi
2270   4CC4 ED A0       > ldi
2270   4CC6 ED A0       > ldi
2270   4CC8 ED A0       > ldi
2270   4CCA ED A0       > ldi
2270   4CCC ED A0       > ldi
2270   4CCE ED A0       > ldi
2270   4CD0 ED A0       > ldi
2270   4CD2 ED A0       > ldi
2270   4CD4 ED A0       > ldi
2270   4CD6 ED A0       > ldi
2270   4CD8 ED A0       > ldi
2270   4CDA ED A0       > ldi
2270   4CDC ED A0       > ldi
2270   4CDE ED A0       > ldi
2270   4CE0 ED A0       > ldi
2270   4CE2 ED A0       > ldi
2270   4CE4 ED A0       > ldi
2270   4CE6 ED A0       > ldi
2270   4CE8 ED A0       > ldi
2270   4CEA ED A0       > ldi
2270   4CEC ED A0       > ldi
2270   4CEE ED A0       > ldi
2270   4CF0 ED A0       > ldi
2270   4CF2 ED A0       > ldi
2270   4CF4 ED A0       > ldi
2270   4CF6 ED A0       > ldi
2270   4CF8 ED A0       > ldi
2270   4CFA ED A0       > ldi
2270   4CFC ED A0       > ldi
2270   4CFE ED A0       > ldi
2270   4D00 ED A0       > ldi
2270   4D02 ED A0       > ldi
2270   4D04 ED A0       > ldi
2270   4D06 ED A0       > ldi
2270   4D08 ED A0       > ldi
2270   4D0A ED A0       > ldi
2270   4D0C ED A0       > ldi
2270   4D0E ED A0       > ldi
2270   4D10 ED A0       > ldi
2270   4D12 ED A0       > ldi
2270   4D14 ED A0       > ldi
2270   4D16 ED A0       > ldi
2270   4D18 ED A0       > ldi
2270   4D1A ED A0       > ldi
2270   4D1C ED A0       > ldi
2270   4D1E ED A0       > ldi
2270   4D20 ED A0       > ldi
2270   4D22 ED A0       > ldi
2270   4D24 ED A0       > ldi
2270   4D26 ED A0       > ldi
2270   4D28 ED A0       > ldi
2270   4D2A ED A0       > ldi
2270   4D2C ED A0       > ldi
2270   4D2E ED A0       > ldi
2270   4D30 ED A0       > ldi
2270   4D32 ED A0       > ldi
2270   4D34 ED A0       > ldi
2270   4D36 ED A0       > ldi
2270   4D38 ED A0       > ldi
2270   4D3A ED A0       > ldi
2270   4D3C ED A0       > ldi
2270   4D3E ED A0       > ldi
2270   4D40 ED A0       > ldi
2270   4D42 ED A0       > ldi
2270   4D44 ED A0       > ldi
2270   4D46 ED A0       > ldi
2270   4D48 ED A0       > ldi
2270   4D4A ED A0       > ldi
2270   4D4C ED A0       > ldi
2270   4D4E ED A0       > ldi
2270   4D50 ED A0       > ldi
2270   4D52 ED A0       > ldi
2270   4D54 ED A0       > ldi
2270   4D56 ED A0       > ldi
2270   4D58 ED A0       > ldi
2270   4D5A ED A0       > ldi
2270   4D5C ED A0       > ldi
2270   4D5E ED A0       > ldi
2270   4D60 ED A0       > ldi
2270   4D62 ED A0       > ldi
2270   4D64 ED A0       > ldi
2270   4D66 ED A0       > ldi
2270   4D68 ED A0       > ldi
2271   4D6A C9          	ret
2272   4D6B             
2273   4D6B             ; ------------------------------------------------
2274   4D6B             ; Jumps to a helper routine, usually in RAM
2275   4D6B             ; Input: HL': Address of the target routine
2276   4D6B             ; ------------------------------------------------
2277   4D6B             RUN_HLPR: 
2278   4D6B D9          	exx
2279   4D6C E9          	jp	(hl)
2280   4D6D             
2281   4D6D             ; ------------------------------------------------
2282   4D6D             ; Setup the arbitrary block size LDIR helper to be used
2283   4D6D             ; Input   : none
2284   4D6D             ; Output  : HL': Address of the block transfer routine to be used 
2285   4D6D             ; Modifies: AF, DE', HL'
2286   4D6D             ; ------------------------------------------------
2287   4D6D             SETLDIRHLPR: 
2288   4D6D D9          	exx
2289   4D6E             	; Check for a Z80 or R800
2290   4D6E AF          	xor	a		; Clear Cy
2291   4D6F 3D          	dec	a		; A=#FF
2292   4D70 ED F9       	db	#ED,#F9		; mulub a,a
2293   4D72 38 05       	jr	c,.useLDIR	; Always use LDIR in RAM for the R800
2294   4D74             
2295   4D74 21 69 49    	ld	hl,LDI512
2296   4D77 D9          	exx
2297   4D78 C9          	ret
2298   4D79             
2299   4D79             .useLDIR: 
2300   4D79 D9          	exx
2301   4D7A             	; ***Continues on GTR800LDIR
2302   4D7A             
2303   4D7A             ; ------------------------------------------------
2304   4D7A             ; Obtain the pointer to the R800 data transfer helper routine
2305   4D7A             ; Input   : IY=Pointer to the WorkArea
2306   4D7A             ; Output  : HL=pointer to R800 data transfer helper routine 
2307   4D7A             ; Modifies: DE
2308   4D7A             ;	    - Does an exx at the end
2309   4D7A             ; ------------------------------------------------
2310   4D7A             GTR800LDIR: 
2311   4D7A FD E5       	push	iy
2312   4D7C E1          	pop	hl			; hl=WorkArea
2313   4D7D 11 3A 00    	ld	de,WRKAREA.TRLDIR
2314   4D80 19          	add	hl,de
2315   4D81 D9          	exx
2316   4D82 C9          	ret
2317   4D83             
2318   4D83             
2319   4D83             ; ------------------------------------------------
2320   4D83             ; Debugging routines
2321   4D83             ; ------------------------------------------------
2322   4D83              IFDEF DEBUG
2323   4D83~            PRTCHAR: 
2324   4D83~            	push	ix,iy
2325   4D83~            	ld	ix,CHPUT
2326   4D83~            	ld	iy,(EXPTBL-1)
2327   4D83~            	call	CALSLT
2328   4D83~            	pop	iy,ix
2329   4D83~            	ret
2330   4D83~            PRTDOT: 
2331   4D83~            	push	af
2332   4D83~            	ld	a,'.'
2333   4D83~            	call	PRTCHAR
2334   4D83~            	pop	af
2335   4D83~            	ret
2336   4D83~            PRTDASH: 
2337   4D83~            	push	af
2338   4D83~            	ld	a,'-'
2339   4D83~            	call	PRTCHAR
2340   4D83~            	pop	af
2341   4D83~            	ret
2342   4D83              ENDIF
2343   4D83             
2344   4D83             
2345   4D83             
2346   4D83             ; ==========================================================================
2347   4D83             strTitle: 
2348   4D83             	db	13,"FBLabs SDHC driver v",27,'J'
2348   4D83 0D46424C61627320534448432064726976657220761B4A
2349   4D9A             	BYTE2STR VER_MAIN
2349   4D9A 31          >	db	(value % 10)+$30
2350   4D9B 2E          	db	'.'
2351   4D9C             	BYTE2STR VER_SEC
2351   4D9C 30          >	db	(value % 10)+$30
2352   4D9D 2E          	db	'.'
2353   4D9E             	BYTE2STR VER_REV
2353   4D9E 31          >	db	((value / 10) % 10)+$30
2353   4D9F 30          >	db	(value % 10)+$30
2354   4DA0 0D 0A 00    	db	13,10,0
2355   4DA3             
2356   4DA3             ;		 |-------------39 chars----------------|
2357   4DA3             strBootpaused: 
2358   4DA3             	db	"Paused. Press <i> for the copyright info",13,10,0
2358   4DA3 5061757365642E205072657373203C693E20666F722074686520636F70797269
2358   4DC3 67687420696E666F0D0A00
2359   4DCE             
2360   4DCE             strCopyright: 
2361   4DCE             	db	"(c) 2014 Fabio Belavenuto",13,10
2361   4DCE 286329203230313420466162696F2042656C6176656E75746F0D0A
2362   4DE9             	db	"(c) 2017 FRS",13,10
2362   4DE9 2863292032303137204652530D0A
2363   4DF7             	db	"Licenced under CERN OHL v1.1",13,10
2363   4DF7 4C6963656E63656420756E646572204345524E204F484C2076312E310D0A
2364   4E15             	db	"http://ohwr.org/cernohl",13,10
2364   4E15 687474703A2F2F6F6877722E6F72672F6365726E6F686C0D0A
2365   4E2E             	db	"PCB designed by Luciano Sturaro",13,10
2365   4E2E 5043422064657369676E6564206279204C756369616E6F205374757261726F0D
2365   4E4E 0A
2366   4E4F             	; will use the CR+LF+EOS bellow 
2367   4E4F             strCrLf: 
2368   4E4F 0D 0A 00    	db	13,10,0
2369   4E52             strCartao: 
2370   4E52             	db	"- Slot ",0
2370   4E52 2D20536C6F742000
2371   4E5A             strVazio: 
2372   4E5A             	db	"Empty",13,10,0
2372   4E5A 456D7074790D0A00
2373   4E62             strNaoIdentificado: 
2374   4E62             	db	"Unknown!",13,10,0
2374   4E62 556E6B6E6F776E210D0A00
2375   4E6D             ;		 |-------------39 chars----------------|
2376   4E6D             strMr_mp_desativada: 
2377   4E6D             	db	"- Slot expander & Mem Mapper disabled",13,10,0
2377   4E6D 2D20536C6F7420657870616E6465722026204D656D204D617070657220646973
2377   4E8D 61626C65640D0A00
2378   4E95              IFDEF HASMEGARAM
2379   4E95~            strMapper: 
2380   4E95~            	db	"- Slot expander & Mem Mapper enabled",13,10,0
2381   4E95~            strMegaram: 
2382   4E95~            	db	"- Slot expander & MegaRAM enabled",13,10,0
2383   4E95              ELSE
2384   4E95             strDrvMain: 
2385   4E95             	db	"- Main driver selected",13,10,0
2385   4E95 2D204D61696E206472697665722073656C65637465640D0A00
2386   4EAE             strDrvDev: 
2387   4EAE             	db	"- Development driver selected",13,10,0
2387   4EAE 2D20446576656C6F706D656E74206472697665722073656C65637465640D0A00
2388   4ECE              ENDIF
2389   4ECE             strSDV1: 
2390   4ECE             	db	"SDV1, ",0
2390   4ECE 534456312C2000
2391   4ED5             strSDV2: 
2392   4ED5             	db	"SDV2, ",0
2392   4ED5 534456322C2000
2393   4EDC             
2394   4EDC             ;-----------------------------------------------------------------------------
2395   4EDC             ;
2396   4EDC             ; End of the driver code
2397   4EDC             
2398   4EDC             DRV_END: 
2399   4EDC             
2400   4EDC             ;	ds	3ED0h-(DRV_END-DRV_START), $FF
2401   4EDC FF          	ds	$7B00-$, #FF
2402   7B00             
2403   7B00             
